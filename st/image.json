{
  "className": "Object",
  "instance_methods": {
    "isMemberOf:": {
      "src": "isMemberOf: aClass\n    \"Returns true if the receiver is an instance of the class 'aClass'\"\n    ^self class == aClass",
      "literals": [],
      "methodName": "isMemberOf:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "broadcast:with:": {
      "src": "broadcast: aSymbol with: anObject\n    \"Send the message aSymbol to each of the receiver's dependents, passing\n     anObject\"\n    | dependencies |\n    dependencies := Smalltalk dependenciesAt: self.\n    dependencies notNil ifTrue:\n    \t[ dependencies do:\n\t    [ :dependent | dependent perform: aSymbol with: anObject ] ]",
      "literals": [],
      "methodName": "broadcast:with:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "release": {
      "src": "release\n    \"Remove all of the receiver's dependents from the set and allow the\n     receiver to be garbage collected.\"\n\n    Dependencies removeKey: self ifAbsent: [ ]",
      "literals": [],
      "methodName": "release",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "broadcast:withBlock:": {
      "src": "broadcast: aSymbol withBlock: aBlock\n    \"Send the message aSymbol to each of the receiver's dependents, passing\n     the result of evaluating aBlock with each dependent as the parameter\"\n    | dependencies |\n    dependencies := Smalltalk dependenciesAt: self.\n    dependencies notNil ifTrue:\n    \t[ dependencies do:\n\t    [ :dependent | dependent\n\t\tperform: aSymbol\n\t\twith: (aBlock value: dependent) ] ]",
      "literals": [],
      "methodName": "broadcast:withBlock:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "mutate:startAt:newClass:": {
      "src": "mutate: instVarMap startAt: start newClass: class\n    \"Private - Mutate object to a new class representation. instVarMap\n     maps between old instVarAt: indices and new instVarAt:put: indices.\n     start is the first instance variable to change.\"\n\n    | aCopy mappedValue end adjustment |\n    \n    adjustment := self class instSize - class instSize.\n\n    aCopy := self class isVariable\n\tifTrue: [ class basicNew: self basicSize ]\n\tifFalse: [ class basicNew ].\n\n    end := instVarMap size + start - 1.\n\t\n    \"Copy the instance variables, if any\"\n    1 to: start - 1 do: [ :i |\n\taCopy instVarAt: i put: (self instVarAt: i)\n    ].\n\t\t\t\t \n    \"Copy old instance variables to their new positions using instVarMap\"\n    start to: end do: [ :i |\n\tmappedValue := instVarMap at: i - start + 1. \n\tmappedValue notNil ifTrue: [\n\t    aCopy instVarAt: i put: (self instVarAt: mappedValue)\n\t]\n    ].\n\n    end + 1 to: self class instSize do: [ :i |\n\taCopy instVarAt: i put: (self instVarAt: i + adjustment)\n    ].\n\n    \"Copy the indexed variables, if any.\"\n    1 to: self basicSize do: [ :i |\n\taCopy basicAt: i put: (self basicAt: i).\n    ].\n    ^self become: aCopy",
      "literals": [],
      "methodName": "mutate:startAt:newClass:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isKindOf:": {
      "src": "isKindOf: aClass\n    \"Answer whether the receiver's class is aClass or\n     a subclass of aClass\"\n    ^self class == aClass or:\n    \t[ self class inheritsFrom: aClass ]",
      "literals": [],
      "methodName": "isKindOf:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isInteger": {
      "src": "isInteger\n    ^false",
      "literals": [],
      "methodName": "isInteger",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "respondsTo:": {
      "src": "respondsTo: aSymbol\n    \"Returns true if the receiver understands the given selector\"\n    ^self class canUnderstand: aSymbol",
      "literals": [],
      "methodName": "respondsTo:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "breakpoint:return:": {
      "src": "breakpoint: context return: return\n    \"Called back by the system. Must return the value passed through the\n     second parameter\"\n\n    context method removeBreakpointAt: context ip.\n    ^return",
      "literals": [],
      "methodName": "breakpoint:return:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isNumber": {
      "src": "isNumber\n    ^false",
      "literals": [],
      "methodName": "isNumber",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "update:": {
      "src": "update: aParameter\n    \"Default behavior is to do nothing. Called by #changed and #changed:\"",
      "literals": [],
      "methodName": "update:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "postStore": {
      "src": "postStore\n    \"Called after an object is dumped; must restore it to the state before\n     `preStore' was called.  Call #postLoad by default\"\n    self postLoad.",
      "literals": [],
      "methodName": "postStore",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "yourself": {
      "src": "yourself\n    \"Answer the receiver\"\n    ^self",
      "literals": [],
      "methodName": "yourself",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isMetaClass": {
      "src": "isMetaClass\n    \"Same as isMetaclass\"\n    ^self isMetaclass",
      "literals": [],
      "methodName": "isMetaClass",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "removeDependent:": {
      "src": "removeDependent: anObject\n    \"Remove anObject to the set of the receiver's dependents. No problem\n     if anObject is not in the set of the receiver's dependents.\"\n    | dependencies |\n    dependencies := Dependencies at: self ifAbsent: [ ^anObject ].\n    dependencies remove: anObject ifAbsent: [].\n    dependencies size < 1 ifTrue: [ self release ].\n    ^anObject",
      "literals": [],
      "methodName": "removeDependent:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "broadcast:with:with:": {
      "src": "broadcast: aSymbol with: arg1 with: arg2\n    \"Send the message aSymbol to each of the receiver's dependents, passing\n     arg1 and arg2 as parameters\"\n    | dependencies |\n    dependencies := Smalltalk dependenciesAt: self.\n    dependencies notNil ifTrue:\n    \t[ dependencies do:\n\t    [ :dependent | dependent perform: aSymbol with: arg1 with: arg2 ] ]",
      "literals": [],
      "methodName": "broadcast:with:with:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "postCopy": {
      "src": "postCopy\n    \"Performs any changes required to do on a copied object. This is the\n     place where one could, for example, put code to replace objects with\n     copies of the objects\"\n    ^self",
      "literals": [],
      "methodName": "postCopy",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "broadcast:": {
      "src": "broadcast: aSymbol\n    \"Send the unary message aSymbol to each of the receiver's dependents\"\n    | dependencies |\n    dependencies := Smalltalk dependenciesAt: self.\n    dependencies notNil ifTrue:\n    \t[ dependencies do:\n\t    [ :dependent | dependent perform: aSymbol ] ]",
      "literals": [],
      "methodName": "broadcast:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isSymbol": {
      "src": "isSymbol\n    ^false",
      "literals": [],
      "methodName": "isSymbol",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isNamespace": {
      "src": "isNamespace\n    ^false",
      "literals": [],
      "methodName": "isNamespace",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "->": {
      "src": "-> anObject\n    \"Creates a new instance of Association with the receiver being the key\n     and the argument becoming the value\"\n    ^Association key: self value: anObject",
      "literals": [],
      "methodName": "->",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "printOn:": {
      "src": "printOn: aStream\n    \"Print a represention of the receiver on aStream\"\n    aStream nextPutAll: self class article; space;\n\t    nextPutAll: self class name",
      "literals": [],
      "methodName": "printOn:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isCharacterArray": {
      "src": "isCharacterArray\n    ^false",
      "literals": [],
      "methodName": "isCharacterArray",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "inspect": {
      "src": "inspect\n    \"Print all the instance variables of the receiver on the Transcript\"\n    | class instVars instVal |\n    class := self class.\n    instVars := class allInstVarNames.\n    Transcript nextPutAll: 'An instance of '.\n    class printNl.\n    1 to: instVars size do:\n    \t[ :i | Transcript nextPutAll: '  ';\n\t\t   nextPutAll: (instVars at: i);\n\t\t   nextPutAll: ': '.\n\t       (self instVarAt: i)  printNl ].\n\n    1 to: self validSize do:\n\t[ :i | Transcript nextPutAll: '  [';\n\t       print: i;\n\t       nextPutAll: ']: ';\n\t       print: (self basicAt: i);\n\t       nl ]",
      "literals": [],
      "methodName": "inspect",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "notNil": {
      "src": "notNil\n    \"Answer whether the receiver is not nil\"\n    ^true",
      "literals": [],
      "methodName": "notNil",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isArray": {
      "src": "isArray\n    ^false",
      "literals": [],
      "methodName": "isArray",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "dependents": {
      "src": "dependents\n    \"Answer a collection of the receiver's dependents.\"\n    | dependencies |\n    dependencies := Dependencies at: self ifAbsent: [ ^OrderedCollection new ].\n    ^dependencies asOrderedCollection",
      "literals": [],
      "methodName": "dependents",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "binaryRepresentationObject": {
      "src": "binaryRepresentationObject\n    \"This method must be implemented if PluggableProxies are used with\n     the receiver's class.  The default implementation raises an exception.\"\n    (ObjectDumper proxyClassFor: self) == PluggableProxy\n\tifTrue: [ self subclassResponsibility ]\n\tifFalse: [ self shouldNotImplement ]",
      "literals": [],
      "methodName": "binaryRepresentationObject",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "ifNil:ifNotNil:": {
      "src": "ifNil: nilBlock ifNotNil: notNilBlock\n    \"Evaluate nilBlock if the receiver is nil, else evaluate\n     notNilBlock, passing the receiver.\"\n    ^notNilBlock value: self",
      "literals": [],
      "methodName": "ifNil:ifNotNil:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isMetaclass": {
      "src": "isMetaclass\n    ^false",
      "literals": [],
      "methodName": "isMetaclass",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "asValue": {
      "src": "asValue\n    \"Return a ValueHolder that holds the receiver\"\n    ^ValueHolder new value: self",
      "literals": [],
      "methodName": "asValue",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "addDependent:": {
      "src": "addDependent: anObject\n    \"Add anObject to the set of the receiver's dependents. Important:\n     if an object has dependents, it won't be garbage collected.\"\n\n    ^(Dependencies at: self ifAbsentPut: [ OrderedCollection new ])\n\tadd: anObject",
      "literals": [],
      "methodName": "addDependent:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "printString": {
      "src": "printString\n    \"Answer a String representing the receiver\"\n    | stream |\n    stream := WriteStream on: (String new: 0).\n    self printOn: stream.\n    ^stream contents",
      "literals": [],
      "methodName": "printString",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "basicPrintOn:": {
      "src": "basicPrintOn: aStream\n    \"Print a represention of the receiver on aStream\"\n    aStream nextPutAll: self class article; space;\n\t    nextPutAll: self class name",
      "literals": [],
      "methodName": "basicPrintOn:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "postLoad": {
      "src": "postLoad\n    \"Called after loading an object; must restore it to the state before\n     `preStore' was called.  Do nothing by default\"",
      "literals": [],
      "methodName": "postLoad",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "ifNotNil:": {
      "src": "ifNotNil: notNilBlock\n    \"Evaluate notNiilBlock if the receiver is not nil, passing the receiver.\n     Else answer nil.\"\n    ^notNilBlock value: self",
      "literals": [],
      "methodName": "ifNotNil:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "changed": {
      "src": "changed\n    \"Send update: for each of the receiver's dependents, passing them the\n     receiver\"\n    self changed: self",
      "literals": [],
      "methodName": "changed",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "~~": {
      "src": "~~ anObject\n    \"Answer whether the receiver and anObject are not the same object\"\n    ^(self == anObject) == false",
      "literals": [],
      "methodName": "~~",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "storeOn:": {
      "src": "storeOn: aStream\n    \"Put Smalltalk code compiling to the receiver on aStream\"\n    | class hasSemi |\n    class := self class.\n    aStream nextPut: $(.\n    aStream nextPutAll: self classNameString.\n    hasSemi := false.\n    class isVariable\n    \tifTrue: [ aStream nextPutAll: ' basicNew: '.\n\t    \t  self basicSize printOn: aStream ]\n    \tifFalse: [ aStream nextPutAll: ' basicNew' ].\n    1 to: class instSize do:\n    \t[ :i | aStream nextPutAll: ' instVarAt: '.\n\t       i printOn: aStream.\n\t       aStream nextPutAll: ' put: '.\n\t       (self instVarAt: i) storeOn: aStream.\n\t       aStream nextPut: $;.\n\t       hasSemi := true ].\n    class isVariable ifTrue: \n    \t[ 1 to: self validSize do:\n\t    [ :i | aStream nextPutAll: ' basicAt: '.\n\t    \t   i printOn: aStream.\n\t\t   aStream nextPutAll: ' put: '.\n\t\t   (self basicAt: i) storeOn: aStream.\n\t\t   aStream nextPut: $;.\n\t\t   hasSemi := true ] ].\n    hasSemi ifTrue: [ aStream nextPutAll: ' yourself' ].\n    aStream nextPut: $)",
      "literals": [],
      "methodName": "storeOn:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "classNameString": {
      "src": "classNameString\n    \"Answer the name of the receiver's class\"\n    | name |\n    name := self class name.\n    name isNil\n    \tifTrue: [ name := self name , ' class' ].\n    ^name",
      "literals": [],
      "methodName": "classNameString",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "validSize": {
      "src": "validSize\n    \"Answer how many elements in the receiver should be inspected\"\n    ^self basicSize",
      "literals": [],
      "methodName": "validSize",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "storeNl": {
      "src": "storeNl\n    \"Put a String of Smalltalk code compiling to the receiver, followed by\n     a new line, on the Transcript (stdout the GUI is not active)\"\n    Transcript showCr: self storeString",
      "literals": [],
      "methodName": "storeNl",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "displayString": {
      "src": "displayString\n    \"Answer a String representing the receiver. For most objects\n     this is simply its #printString, but for strings and characters,\n     superfluous dollars or extra pair of quotes are stripped.\"\n    | stream |\n    stream := WriteStream on: (String new: 0).\n    self displayOn: stream.\n    ^stream contents",
      "literals": [],
      "methodName": "displayString",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "preStore": {
      "src": "preStore\n    \"Called before dumping an object; it must *change* it (it must not answer\n    a new object) if necessary.  Do nothing by default\"",
      "literals": [],
      "methodName": "preStore",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "storeString": {
      "src": "storeString\n    \"Answer a String of Smalltalk code compiling to the receiver\"\n    | stream |\n    stream := WriteStream on: (String new: 0).\n    self storeOn: stream.\n    ^stream contents",
      "literals": [],
      "methodName": "storeString",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isString": {
      "src": "isString\n    ^false",
      "literals": [],
      "methodName": "isString",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isBehavior": {
      "src": "isBehavior\n    ^false",
      "literals": [],
      "methodName": "isBehavior",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "copy": {
      "src": "copy\n    \"Returns a shallow copy of the receiver (the instance variables are\n     not copied). The shallow copy receives the message postCopy and the\n     result of postCopy is passed back.\"\n    ^self shallowCopy postCopy",
      "literals": [],
      "methodName": "copy",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "ifNotNil:ifNil:": {
      "src": "ifNotNil: notNilBlock ifNil: nilBlock\n    \"Evaluate nilBlock if the receiver is nil, else evaluate\n     notNilBlock, passing the receiver.\"\n    ^notNilBlock value: self",
      "literals": [],
      "methodName": "ifNotNil:ifNil:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isClass": {
      "src": "isClass\n    ^false",
      "literals": [],
      "methodName": "isClass",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "displayNl": {
      "src": "displayNl\n    \"Print a represention of the receiver, then put a new line on\n     the Transcript (stdout the GUI is not active). For most objects this\n     is simply its #printNl representation, but for strings and\n     characters, superfluous dollars or extra pair of quotes are stripped.\"\n    Transcript showCr: self displayString",
      "literals": [],
      "methodName": "displayNl",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "displayOn:": {
      "src": "displayOn: aStream\n    \"Print a represention of the receiver on aStream. For most objects\n     this is simply its #printOn: representation, but for strings and\n     characters, superfluous dollars or extra pair of quotes are stripped.\"\n    self printOn: aStream",
      "literals": [],
      "methodName": "displayOn:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "changed:": {
      "src": "changed: aParameter\n    \"Send update: for each of the receiver's dependents, passing them\n     aParameter\"\n    | dependencies |\n    dependencies := Smalltalk dependenciesAt: self.\n    dependencies notNil ifTrue:\n    \t[ dependencies do:\n\t    [ :dependent | dependent update: aParameter ] ]",
      "literals": [],
      "methodName": "changed:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isCharacter": {
      "src": "isCharacter\n    ^false",
      "literals": [],
      "methodName": "isCharacter",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "display": {
      "src": "display\n    \"Print a represention of the receiver on the Transcript (stdout the GUI\n     is not active). For most objects this is simply its #print\n     representation, but for strings and characters, superfluous dollars\n     or extra pair of quotes are stripped.\"\n    Transcript show: self displayString",
      "literals": [],
      "methodName": "display",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "ifNil:": {
      "src": "ifNil: nilBlock\n    \"Evaluate nilBlock if the receiver is nil, else answer self\"\n    ^self",
      "literals": [],
      "methodName": "ifNil:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isFloat": {
      "src": "isFloat\n    ^false",
      "literals": [],
      "methodName": "isFloat",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isMeta": {
      "src": "isMeta\n    \"Same as isMetaclass\"\n    ^self isMetaclass",
      "literals": [],
      "methodName": "isMeta",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "store": {
      "src": "store\n    \"Put a String of Smalltalk code compiling to the receiver on\n     the Transcript (stdout the GUI is not active)\"\n    Transcript show: self storeString",
      "literals": [],
      "methodName": "store",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isSmallInteger": {
      "src": "isSmallInteger\n    ^false",
      "literals": [],
      "methodName": "isSmallInteger",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "deepCopy": {
      "src": "deepCopy\n    \"Returns a deep copy of the receiver (the instance variables are\n     copies of the receiver's instance variables)\"\n    | class aCopy num |\n    class := self class.\n    aCopy := self shallowCopy.\n    class isPointers\n    \tifTrue: [ num := class instSize + self basicSize ]\n\tifFalse: [ num := class instSize ].\n\n    \" copy the instance variables (if any) \"\n    1 to: num do: [ :i |\n    \taCopy instVarAt: i put: (self instVarAt: i) copy.\n    ].\n    ^aCopy",
      "literals": [],
      "methodName": "deepCopy",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "broadcast:withArguments:": {
      "src": "broadcast: aSymbol withArguments: anArray\n    \"Send the message aSymbol to each of the receiver's dependents, passing\n     the parameters in anArray\"\n    | dependencies |\n    dependencies := Smalltalk dependenciesAt: self.\n    dependencies notNil ifTrue:\n    \t[ dependencies do:\n\t    [ :dependent | dependent perform: aSymbol withArguments: anArray ] ]",
      "literals": [],
      "methodName": "broadcast:withArguments:",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "print": {
      "src": "print\n    \"Print a represention of the receiver on the Transcript (stdout the GUI\n     is not active)\"\n    Transcript show: self printString",
      "literals": [],
      "methodName": "print",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "species": {
      "src": "species\n    \"This method has no unique definition. Generally speaking, methods which\n     always return the same type usually don't use #class, but #species.\n     For example, a PositionableStream's species is the class of the collection\n     on which it is streaming (used by upTo:, upToAll:, upToEnd). Stream uses\n     species for obtaining the class of next:'s return value, Collection uses\n     it in its #copyEmpty: message, which in turn is used by all collection-re-\n     turning methods. An Interval's species is Array (used by collect:, select:,\n     reject:, etc.).\"\n    ^self class",
      "literals": [],
      "methodName": "species",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "printNl": {
      "src": "printNl\n    \"Print a represention of the receiver on stdout, put a new line\n     the Transcript (stdout the GUI is not active)\"\n    Transcript showCr: self printString",
      "literals": [],
      "methodName": "printNl",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "reconstructOriginalObject": {
      "src": "reconstructOriginalObject\n    \"Used if an instance of the receiver's class is returned as the\n     #binaryRepresentationObject of another object.  The default implementation\n     raises an exception.\"\n    self subclassResponsibility",
      "literals": [],
      "methodName": "reconstructOriginalObject",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "isNil": {
      "src": "isNil\n    \"Answer whether the receiver is nil\"\n    ^false",
      "literals": [],
      "methodName": "isNil",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "finalize": {
      "src": "finalize\n    \"Do nothing by default\"",
      "literals": [],
      "methodName": "finalize",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "basicPrintNl": {
      "src": "basicPrintNl\n    \"Print a basic representation of the receiver, followed by a new line.\"\n    stdout flush.\n    self basicPrint.\n    stdout nextPutAllFlush: Character nl",
      "literals": [],
      "methodName": "basicPrintNl",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    },
    "~=": {
      "src": "~= anObject\n    \"Answer whether the receiver and anObject are not equal\"\n    ^(self = anObject) == false",
      "literals": [],
      "methodName": "~=",
      "className": "Object",
      "category": "private",
      "byteCodes": []
    }
  },
  "class_methods": {},
  "subclasses": [
    {
      "className": "Behavior",
      "instance_methods": {
        "subclassInstVarNames": {
          "src": "subclassInstVarNames\n    \"Answer the names of the instance variables the receiver inherited from its\n     superclass\"\n    | superVars |\n    instanceVariables isNil ifTrue: [ ^#() ].\n    superClass isNil ifTrue: [ ^#() ].\n\n    ^superClass allInstVarNames.",
          "literals": [],
          "methodName": "subclassInstVarNames",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "addInstVarName:": {
          "src": "addInstVarName: aString\n    \"Add the given instance variable to instance of the receiver\"\n    instanceVariables := instanceVariables isNil\n        ifTrue: [ { aString asSymbol } ]\n        ifFalse: [ instanceVariables copyWith: aString asSymbol ].\n\n    instanceSpec := instanceSpec + 4096.    \"Highly implementation specific\"\n\n    self\n\tupdateInstanceVars: instanceVariables\n\tvariable: self isVariable\n\twords: self isWords\n\tpointers: self isPointers",
          "literals": [],
          "methodName": "addInstVarName:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "superclass": {
          "src": "superclass\n    \"Answer the receiver's superclass (if any, otherwise answer nil)\"\n    ^superClass",
          "literals": [],
          "methodName": "superclass",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "extractEvalChunk:": {
          "src": "extractEvalChunk: aStream\n    \"Private - Extract the code in the next evaluation chunk (i.e. the code\n     until the next bang which is outside string literals or comments)\"\n\n    | code ch |\n    code := WriteStream on: (String new: 100).\n    [   aStream atEnd ] whileFalse: [\n\tch := aStream next.\n\tch = $! ifTrue: [ ^code contents ].\n\n\tcode nextPut: ch.\n\tch = $\" ifTrue: [ code nextPutAll: (aStream upTo: ch); nextPut: ch ].\n\tch = $' ifTrue: [\n\t    [\n\t\tcode\n\t\t    nextPutAll: (aStream upTo: ch);\n\t\t    nextPut: $'.\n\t\taStream atEnd not and: [ aStream peekFor: ch ]\n\t    ]   whileTrue: [\n\t\tcode nextPut: ch.\n\t    ]\n\t].\n    ].\n    ^code contents",
          "literals": [],
          "methodName": "extractEvalChunk:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "classVarNames": {
          "src": "classVarNames\n    \"Answer all the class variables for instances of the receiver\"\n    ^self superclass isNil\n\tifTrue: [ #() ]\n\tifFalse: [ self superclass classVarNames ]",
          "literals": [],
          "methodName": "classVarNames",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "decompile:": {
          "src": "decompile: selector\n    \"Decompile the bytecodes for the given selector.\"\n\n    | method source |\n    method := self compiledMethodAt: selector.\n    source := method methodSourceString.\n    ^source isNil & Decompiler notNil\n\tifTrue: [ Decompiler decompile: selector in: self ]\n    \tifFalse: [ source ]",
          "literals": [],
          "methodName": "decompile:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSelectors": {
          "src": "allSelectors\n    \"Answer a Set of all the selectors understood by the receiver\"\n    | aSet |\n    aSet := self selectors.\n    self allSuperclassesDo:\n    \t[ :superclass | aSet addAll: superclass selectors ].\n    ^aSet",
          "literals": [],
          "methodName": "allSelectors",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compile:": {
          "src": "compile: code\n    \"Compile method source.  If there are parsing errors, answer nil.\n     Else, return a CompiledMethod result of compilation\"\n    (code isKindOf: PositionableStream)\n    \tifTrue: [ ^self compileString: code contents ].\n    (code isMemberOf: String)\n    \tifFalse: [ ^self compileString: code asString ].\n    ^self compileString: code",
          "literals": [],
          "methodName": "compile:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "sharedPoolDictionaries": {
          "src": "sharedPoolDictionaries\n    \"Return the shared pools (not the names!) defined by the class\"\n    ^self superclass sharedPoolDictionaries",
          "literals": [],
          "methodName": "sharedPoolDictionaries",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "newInFixedSpace": {
          "src": "newInFixedSpace\n    \"Create a new instance of a class without indexed instance variables. \n     The instance is guaranteed not to move across garbage collections.\n     If a subclass overrides #new, the changes will apply to this method too.\"\n    ^self new makeFixed",
          "literals": [],
          "methodName": "newInFixedSpace",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSubinstancesDo:": {
          "src": "allSubinstancesDo: aBlock\n    \"Invokes aBlock for all instances of each of the receiver's subclasses.\"\n    self allSubclassesDo:\n    \t[ :subclass | subclass allInstancesDo: aBlock ]",
          "literals": [],
          "methodName": "allSubinstancesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allInstances": {
          "src": "allInstances\n    \"Returns a set of all instances of the receiver\"\n    | result weakResult anInstance |\n    result := WriteStream on: (Array new: 100).\n    anInstance := self someInstance.\n    [ anInstance notNil ] whileTrue: [\n\tresult nextPut: anInstance.\n    \tanInstance := anInstance nextInstance ].\n\n    result := result contents.\n    weakResult := WeakArray new: result size.\n    1 to: result size do: [ :i |\n\tweakResult at: i put: (result at: i)\n    ].\n    ^weakResult",
          "literals": [],
          "methodName": "allInstances",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allInstancesDo:": {
          "src": "allInstancesDo: aBlock\n    \"Invokes aBlock for all instances of the receiver\"\n    self allInstances do: [ :each |\n\teach isNil ifFalse: [ aBlock value: each ]\n    ]",
          "literals": [],
          "methodName": "allInstancesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "createGetMethod:default:": {
          "src": "createGetMethod: what default: value\n    \"Create a method accessing the variable `what', with a default value\n    of `value', using lazy initialization\"\n\n    ^self compile: ('%1\n    \"Answer the receiver''s %1. Its default value is %2\"\n    %1 isNil ifTrue: [ %1 := %2 ].\n    ^%1' bindWith: what with: value)",
          "literals": [],
          "methodName": "createGetMethod:default:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "privateMethods": {
          "src": "privateMethods\n    \"Don't use this, it's only present to file in from IBM Smalltalk\"\n    ^self methodsFor: 'private'",
          "literals": [],
          "methodName": "privateMethods",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "canUnderstand:": {
          "src": "canUnderstand: selector\n    \"Returns true if the instances of the receiver understand\n     the given selector\"\n    (self includesSelector: selector)\n    \tifTrue: [ ^true ].\n    self allSuperclassesDo:\n    \t[ :superclass | (superclass includesSelector: selector)\n\t    \t    \t    ifTrue: [ ^true ] ].\n    ^false",
          "literals": [],
          "methodName": "canUnderstand:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evaluate:": {
          "src": "evaluate: code\n    \"Evaluate Smalltalk expression in 'code' and return result.\"\n\n    (code isKindOf: PositionableStream)\n\tifTrue: [ ^self evalString: code contents to: nil ].\n    (code isMemberOf: String)\n\tifFalse: [ ^self evalString: code asString to: nil ].\n    ^self evalString: code to: nil",
          "literals": [],
          "methodName": "evaluate:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allClassVarNames": {
          "src": "allClassVarNames\n    \"Return all the class variables understood by the receiver\"\n    | result |\n    result := WriteStream with: self classVarNames asArray.\n    self allSuperclassesDo: [ :each |\n\tresult nextPutAll: each classVarNames\n    ].\n    ^result contents",
          "literals": [],
          "methodName": "allClassVarNames",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "withAllSuperclassesDo:": {
          "src": "withAllSuperclassesDo: aBlock\n    \"Invokes aBlock for the receiver and all superclasses, both direct\n     and indirect.\"\n    | class |\n    class := self.\n    [ aBlock value: class.\n      class := class superclass.\n      class notNil ] whileTrue",
          "literals": [],
          "methodName": "withAllSuperclassesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "whichClassIncludesSelector:": {
          "src": "whichClassIncludesSelector: selector\n    \"Answer which class in the receiver's hierarchy contains the implementation\n     of selector used by instances of the class (nil if none does)\"\n    self withAllSuperclassesDo:\n    \t[ :superclass | (superclass includesSelector: selector)\n\t    \t    \t    ifTrue: [ ^superclass ] ].\n    ^nil",
          "literals": [],
          "methodName": "whichClassIncludesSelector:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isWords": {
          "src": "isWords\n    \"Answer whether the instance variables of the receiver's\n     instances are words\"\n    ^(self instanceSpec bitAt: 3) ~= 0",
          "literals": [],
          "methodName": "isWords",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "asClass": {
          "src": "asClass\n    \"Answer the first superclass that is a full-fledged Class object\"\n    ^self superclass asClass",
          "literals": [],
          "methodName": "asClass",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "selectSubclasses:": {
          "src": "selectSubclasses: aBlock\n    \"Return a Set of subclasses of the receiver satisfying aBlock.\"\n    | aSet |\n    aSet := Set new.\n    self allSubclassesDo: [ :subclass | (aBlock value: subclass)\n    \t    \t    \t    \t    \t    ifTrue: [ aSet add: subclass ] ].\n    ^aSet",
          "literals": [],
          "methodName": "selectSubclasses:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "addSelector:withMethod:": {
          "src": "addSelector: selector withMethod: compiledMethod\n    \"Add the given compiledMethod to the method dictionary, giving it\n     the passed selector. Answer compiledMethod\"\n\n    methodDictionary isNil ifTrue: [ methodDictionary := MethodDictionary new ].\n    ^methodDictionary\n\tat: selector\n\tput: (compiledMethod withNewMethodClass: self selector: selector).",
          "literals": [],
          "methodName": "addSelector:withMethod:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evalString:to:": {
          "src": "evalString: aString to: anObject\n    \"Answer the stack top at the end of the evaluation of the code in\n     aString. The code is executed as part of anObject\"\n    | s result next method |\n    s := ReadStream on: aString.\n    [\n\tnext := self extractEvalChunk: s.\n\tmethod := anObject class\n\t    compileString: 'Doit ^ [\n', next, ' ] value ' ifError: [ :fname :line :error | nil ]. \n\n\tmethod isNil | (next allSatisfy: [ :each | each = Character space ])\n\t    ifFalse: [ [ result := anObject perform: method ] valueWithUnwind ].\n\n\ts atEnd ] whileFalse.\n\n    anObject class removeSelector: #Doit ifAbsent: [].\n    ^result",
          "literals": [],
          "methodName": "evalString:to:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "methodsFor": {
          "src": "methodsFor\n    \"Don't use this, it's only present to file in from Dolphin Smalltalk\"\n    ^self methodsFor: 'no category'",
          "literals": [],
          "methodName": "methodsFor",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "methods": {
          "src": "methods\n    \"Don't use this, it's only present to file in from Smalltalk/V\"\n    ^self methodsFor: 'no category'",
          "literals": [],
          "methodName": "methods",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evaluate:to:": {
          "src": "evaluate: code to: anObject \n    \"Evaluate Smalltalk expression as part of anObject's method definition\"\n\n    (code isKindOf: PositionableStream)\n\tifTrue: [ ^self evalString: code contents to: anObject ].\n    (code isMemberOf: String)\n\tifFalse: [ ^self evalString: code asString to: anObject ].\n    ^self evalString: code to: anObject.",
          "literals": [],
          "methodName": "evaluate:to:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "whichSelectorsReferToByteCode:": {
          "src": "whichSelectorsReferToByteCode: aByteCode\n    \"Return the collection of selectors in the class which\n     reference the byte code, aByteCode\"\n    | s method specialSelector |\n    s := Set new.\n    methodDictionary isNil\n\tifTrue: [ ^s ].\n    methodDictionary associationsDo:\n\t[ :assoc |  method := assoc value.\n\t\t\t\t((1 to: method numBytecodes) detect:\n\t\t\t\t[ :i | aByteCode = (method bytecodeAt: i)]\n\t\t\t\tifNone: [0]) > 0 \n\t\t\t\t\tifTrue: [ s add: assoc key ].\n\t].\n    ^s",
          "literals": [],
          "methodName": "whichSelectorsReferToByteCode:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "defineCFunc:withSelectorArgs:forClass:returning:args:": {
          "src": "defineCFunc: cFuncNameString\n    withSelectorArgs: selectorAndArgs\n    forClass: aClass \n    returning: returnTypeSymbol \n    args: argsArray\n\n    \"Lookup the part on the C interface in this manual -- it is too complex to\n     describe it here ;-) Anyway this is private and kept for backward com-\n     patibility. You should use defineCFunc:withSelectorArgs:returning:args:.\"\n\n    | code gensym descriptor |\n\n    \"This is pretty complex.  What I want to provide is a very\n     efficient way of calling a C function.  I create a descriptor object that\n     holds the relevant information regarding the C function.  I then compile\n     the method that's to be invoked to call the C function.  This method\n     uses the primitive VMpr_callout to perform the actual call-out.  To let\n     the primitive know which descriptor to use, I arrange for the first and only\n     method literal of the compiled method to be an association that contains\n     as its value the C function descriptor object.  I add new\n     associations to the global shared pool 'CFunctionDescs', and reference\n     the newly generated key in the text of the compiled method.\"\n\n    (CFunctionDescriptor isFunction: cFuncNameString) ifFalse: [\n\t('C function ', cFuncNameString, ' not defined') printNl\n    ].\n\n    descriptor := CFunctionDescriptor\n\tfor: cFuncNameString\n    \treturning: returnTypeSymbol\n\twithArgs: argsArray.\n\n    gensym := ('CFunction' , descriptor asOop printString) asSymbol.\n\n    CFunctionDescs at: gensym put: descriptor.\n\n    code := ('%1\n    \"C call-out to %2. Do not modify!\"\n    <primitive: VMpr_callout>\n    #{Smalltalk.CFunctionDescs.%3}.\n    SystemExceptions CInterfaceError signal: ''Invalid C call-out %2''\n')\n\t\n\tbindWith: selectorAndArgs\n\twith: cFuncNameString\n\twith: gensym asString.\n\n    ^aClass compile: code ifError: [ :file :line :error | code error: error ].",
          "literals": [],
          "methodName": "defineCFunc:withSelectorArgs:forClass:returning:args:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "recompile:notifying:": {
          "src": "recompile: selector notifying: aNotifier\n    \"Recompile the given selector.  If there are parsing errors, send #error:\n     to the aNotifier object, else return a CompiledMethod result of\n     compilation\"\n\n    | source category ok |\n    ok := [\n\tsource := self sourceCodeAt: selector.\n    \tcategory := (self compiledMethodAt: selector) methodCategory.\n\ttrue\n    ] on: Error do: [ :ex | ex return: false ].\n\n    ok ifFalse: [ ^nil ].\n    Transcript\n\tnextPutAll: 'Recompiling selector: ';\n\tprint: selector asSymbol; nl.\n\n    ^self compile: source classified: category notifying: aNotifier",
          "literals": [],
          "methodName": "recompile:notifying:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "sourceMethodAt:": {
          "src": "sourceMethodAt: selector\n    \"This is too dependent on the original implementation\"\n    self shouldNotImplement",
          "literals": [],
          "methodName": "sourceMethodAt:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compileAllSubclasses": {
          "src": "compileAllSubclasses\n    \"Recompile all selector of all subclasses. Notify aNotifier by sen-\n     ding #error: messages if something goes wrong.\"\n    self allSubclassesDo: [ :subclass | subclass compileAll ]",
          "literals": [],
          "methodName": "compileAllSubclasses",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "scopeHas:ifTrue:": {
          "src": "scopeHas: name ifTrue: aBlock\n    \"If methods understood by the receiver's instances have access to a\n     symbol named 'name', evaluate aBlock\"\n\n    | nameSym |\n    nameSym := name asSymbol.\n    (self allInstVarNames includes: nameSym) ifTrue: [ ^aBlock value ].\n    (self allClassVarNames includes: nameSym) ifTrue: [ ^aBlock value ].\n    (self environment includesKey: nameSym) ifTrue: [ ^aBlock value ].\n\n    self allSharedPools do: [ :dictName |\n\t((self environment at: dictName asSymbol) includesKey: nameSym)\n\t\t\t  ifTrue: [ ^aBlock value ] ]",
          "literals": [],
          "methodName": "scopeHas:ifTrue:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "superclass:": {
          "src": "superclass: aClass\n    \"Set the receiver's superclass.\"\n    superClass := aClass.\n    instanceSpec isNil ifTrue: [\n\tinstanceSpec := aClass isNil\n\t    ifTrue: [ 0 ]\n\t    ifFalse: [ aClass instanceSpec ]\n    ].",
          "literals": [],
          "methodName": "superclass:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "publicMethods": {
          "src": "publicMethods\n    \"Don't use this, it's only present to file in from IBM Smalltalk\"\n    ^self methodsFor: 'public'",
          "literals": [],
          "methodName": "publicMethods",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "sourceCodeAt:": {
          "src": "sourceCodeAt: selector\n    \"Answer source code (if available) for the given compiledMethod\"\n    | source |\n    source := (self compiledMethodAt: selector) methodSourceCode.\n    source isNil ifTrue: [ ^'\" *** SOURCE CODE NOT AVAILABLE *** \"' copy ].\n    ^source asString",
          "literals": [],
          "methodName": "sourceCodeAt:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSubclasses": {
          "src": "allSubclasses\n    \"Answer the direct and indirect subclasses of the receiver in a Set\"\n    | aSet |\n    aSet := Set new.\n    self allSubclassesDo: [ :subclass | aSet add: subclass ].\n    ^aSet",
          "literals": [],
          "methodName": "allSubclasses",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isBehavior": {
          "src": "isBehavior\n    ^true",
          "literals": [],
          "methodName": "isBehavior",
          "className": "Metaclass",
          "category": "testing functionality",
          "byteCodes": []
        },
        "recompile:": {
          "src": "recompile: selector\n    \"Recompile the given selector, answer nil if something goes wrong or\n     the new CompiledMethod if everything's ok.\"\n\n    | source category ok |\n    ok := [\n\tsource := self sourceCodeAt: selector.\n    \tcategory := (self compiledMethodAt: selector) methodCategory.\n\ttrue\n    ] on: Error do: [ :ex | ex return: false ].\n\n    ok ifFalse: [ ^nil ].\n    Transcript\n\tnextPutAll: 'Recompiling selector: ';\n\tprint: selector asSymbol; nl.\n\n    ^self compile: source classified: category",
          "literals": [],
          "methodName": "recompile:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "whichSelectorsReferTo:": {
          "src": "whichSelectorsReferTo: anObject\n    \"Returns a Set of selectors that refer to anObject\"\n    | md |\n    md := self methodDictionary.\n    md isNil ifTrue: [ ^Set new ].\n    ^(md select: [ :each | each refersTo: anObject ])\n\tkeys",
          "literals": [],
          "methodName": "whichSelectorsReferTo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "whichSelectorsAccess:": {
          "src": "whichSelectorsAccess: instVarName\n    \"Answer a Set of selectors which access the given instance variable\"\n    | md index |\n    index := self allInstVarNames\n\tindexOf: instVarName\n\tifAbsent: [ ^Set new ].   \" ### should it raise an error?\"\n    \n    md := self methodDictionary.\n    md isNil ifTrue: [ ^Set new ].\n    ^(md select: [ :each | each accesses: index - 1 ])\n\tkeys",
          "literals": [],
          "methodName": "whichSelectorsAccess:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compile:ifError:": {
          "src": "compile: code ifError: block\n    \"Compile method source.  If there are parsing errors, invoke\n     exception block, 'block' passing file name, line number and error.\n     description. Return a CompiledMethod result of compilation\"\n    (code isKindOf: PositionableStream)\n\tifTrue: [ ^self compileString: code contents ifError: block ].\n    (code isMemberOf: String)\n\tifFalse: [ ^self compileString: code asString ifError: block ].\n    ^self compileString: code ifError: block.",
          "literals": [],
          "methodName": "compile:ifError:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "removeSubclass:": {
          "src": "removeSubclass: aClass\n    \"Remove aClass from the list of the receiver's subclasses\"\n    subClasses := subClasses copyWithout: aClass",
          "literals": [],
          "methodName": "removeSubclass:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "removeSelector:ifAbsent:": {
          "src": "removeSelector: selector ifAbsent: aBlock\n    \"Remove the given selector from the method dictionary, answer\n     the CompiledMethod attached to that selector. If the selector cannot\n     be found, answer the result of evaluating aBlock.\"\n\n    methodDictionary isNil ifTrue: [ ^aBlock value ].\n    (methodDictionary includesKey: selector) ifFalse: [ ^aBlock value ].\n    ^methodDictionary removeKey: selector ifAbsent: [ self error: 'huh?!?' ]",
          "literals": [],
          "methodName": "removeSelector:ifAbsent:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evaluate:notifying:": {
          "src": "evaluate: code notifying: requestor\n    \"Evaluate Smalltalk expression in 'code'. If a parsing error is encountered, \n    send #error: to requestor\"\n    | method aStream |\n    ^self evaluate: code ifError: [:fname :lineNo :errorString | \n\t\trequestor error: ('line ', lineNo printString, ': ' , errorString) ].",
          "literals": [],
          "methodName": "evaluate:notifying:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "methodDictionary": {
          "src": "methodDictionary\n    \"Answer the receiver's method dictionary. Don't modify the method\n     dictionary unless you exactly know what you're doing\"\n    ^methodDictionary",
          "literals": [],
          "methodName": "methodDictionary",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "withAllSubclasses": {
          "src": "withAllSubclasses\n    \"Answer a Set containing the receiver together with its direct and\n     indirect subclasses\"\n    | aSet |\n    aSet := Set with: self.\n    aSet addAll: (self allSubclasses).\n    ^aSet",
          "literals": [],
          "methodName": "withAllSubclasses",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "instanceCount": {
          "src": "instanceCount\n    \"Return a count of all the instances of the receiver\"\n    | count anInstance |\n    count := 0.\n    anInstance := self someInstance.\n    [ anInstance notNil ]\n    \twhileTrue: [ count := count + 1.\n\t    \t     anInstance := anInstance nextInstance ].    \n    ^count",
          "literals": [],
          "methodName": "instanceCount",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "instSize": {
          "src": "instSize\n    \"Answer how many fixed instance variables are reserved to each of the\n     receiver's instances\"\n    ^self instanceSpec bitShift: -12",
          "literals": [],
          "methodName": "instSize",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "defineCFunc:withSelectorArgs:returning:args:": {
          "src": "defineCFunc: cFuncNameString\n    withSelectorArgs: selectorAndArgs\n    returning: returnTypeSymbol \n    args: argsArray\n\n    \"Lookup the C interface in the manual. Too complex to describe it here ;-)\"\n    ^Behavior\n\tdefineCFunc: cFuncNameString\n\twithSelectorArgs: selectorAndArgs\n\tforClass: self\n\treturning: returnTypeSymbol \n\targs: argsArray",
          "literals": [],
          "methodName": "defineCFunc:withSelectorArgs:returning:args:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "removeSelector:": {
          "src": "removeSelector: selector\n    \"Remove the given selector from the method dictionary, answer\n     the CompiledMethod attached to that selector\"\n    ^self\n\tremoveSelector: selector\n\tifAbsent: [ SystemExceptions NotFound signalOn: selector what: 'method' ]",
          "literals": [],
          "methodName": "removeSelector:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "updateInstanceVars:variable:words:pointers:": {
          "src": "updateInstanceVars: variableArray\n    variable: variableBoolean\n    words: wordBoolean \n    pointers: pointerBoolean\n\n    \"Update instance variables and instance spec of the class and all its subclasses\"\n\n    | instVarMap startOfInstanceVars endOfInstanceVars newInstanceVars \n       oldInstVars map oldClass instances |\n\n    startOfInstanceVars := self superclass instSize + 1.\n    endOfInstanceVars :=  self instSize.\n    newInstanceVars := variableArray\n\tcopyFrom: startOfInstanceVars \n\tto: variableArray size. \n\n    oldInstVars :=  self allInstVarNames. \n    instVarMap := Array new: newInstanceVars size.\n    startOfInstanceVars to: endOfInstanceVars do: [ :i | \n\tmap := newInstanceVars indexOf: (oldInstVars  at: i). \n\tmap > 0 ifTrue: [instVarMap at: map put: i]\n    ].\n\n    \"Fix up all subclasses.\"\n    self allSubclassesDo: [ :sc || iv |\n\toldClass := Behavior new.\n\toldClass superclass: sc.\n\tinstances := sc allInstances.\n\tinstances do: [ :each | each changeClassTo: oldClass ].\n\n\tiv := sc allInstVarNames\n\t    copyReplaceFrom: startOfInstanceVars \n\t    to: endOfInstanceVars\n\t    with: newInstanceVars.\n\n\tsc setInstanceVariables: iv.\n\n\tsc setInstanceSpec: sc isVariable\n\t    words: sc isWords\n\t    pointers: sc isPointers\n\t    instVars: sc allInstVarNames size.\n\n\t\"Mutate all instances of the class to conform to new memory model\n\t of the class.\"\n\n\tinstances do: [ :each |\n\t    each mutate: instVarMap\n\t\t startAt: startOfInstanceVars\n\t\t newClass: sc\n\t]\n    ].\n\n    \"Now update this class' instance vars \"       \n    oldClass := Behavior new.\n    oldClass superclass: self.\n    instances := self allInstances.\n    instances do: [ :each | each changeClassTo: oldClass ].\n\n    self setInstanceVariables: variableArray.\n\n    self setInstanceSpec: variableBoolean words: wordBoolean\n\tpointers: pointerBoolean instVars: variableArray size.\n\n    instances do: [ :each |\n\teach\n\t    mutate: instVarMap\n\t    startAt: startOfInstanceVars\n\t    newClass: self\n    ].",
          "literals": [],
          "methodName": "updateInstanceVars:variable:words:pointers:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "nameIn:": {
          "src": "nameIn: aNamespace\n    \"Answer the class name when the class is referenced from aNamespace\n     - a dummy one, since Behavior does not support names.\"\n    ^'<no name>'",
          "literals": [],
          "methodName": "nameIn:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSubclassesDo:": {
          "src": "allSubclassesDo: aBlock\n    \"Invokes aBlock for all subclasses, both direct and indirect.\"\n    subClasses isNil ifTrue: [ ^self ].\n\n    subClasses do: [ :class |\n\taBlock value: class.\n\tclass allSubclassesDo: aBlock\n    ].",
          "literals": [],
          "methodName": "allSubclassesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "setInstanceSpec:words:pointers:instVars:": {
          "src": "setInstanceSpec: variableBoolean\n  words: wordsBoolean\n  pointers: pointersBoolean\n  instVars: anIntegerSize\n    \"hasFinalize is cleared by this method -- should it be? \"\n    instanceSpec := 0.\n    pointersBoolean\n    \tifTrue: [ instanceSpec := instanceSpec bitOr: ( 1 bitShift: 3 ) ].\n    wordsBoolean\n\tifTrue: [ instanceSpec := instanceSpec bitOr: ( 1 bitShift: 2 ) ].\n    variableBoolean\n\tifTrue: [ instanceSpec := instanceSpec bitOr: ( 1 bitShift: 1 ) ].\n    instanceSpec := instanceSpec bitOr: (anIntegerSize bitShift: 12).",
          "literals": [],
          "methodName": "setInstanceSpec:words:pointers:instVars:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "methodsFor:ifFeatures:": {
          "src": "methodsFor: category ifFeatures: features\n    \"Start compiling methods in the receiver if this implementation of\n     Smalltalk has the given features, else skip the section\"\n    ^self methodsFor: category ifTrue: (Smalltalk hasFeatures: features)",
          "literals": [],
          "methodName": "methodsFor:ifFeatures:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compileAll": {
          "src": "compileAll\n    \"Recompile all selectors in the receiver. Ignore errors.\"\n    methodDictionary notNil\n\tifTrue: [\n\t    Transcript nextPutAll: 'Recompiling class: '; print: self; nl.\n\t    methodDictionary keysDo: \n\t\t      [ :selector | self recompile: selector ] ]",
          "literals": [],
          "methodName": "compileAll",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSharedPools": {
          "src": "allSharedPools\n    \"Return the names of the shared pools defined by the class and any of\n     its superclasses\"\n    | result |\n    result := self sharedPools asSet.\n    self environment withAllSuperspacesDo: [ :each |\n\tresult add: each name asSymbol\n    ].\n    self allSuperclassesDo: [ :each |\n\tresult addAll: each sharedPools\n    ].\n    ^result asArray",
          "literals": [],
          "methodName": "allSharedPools",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evalString:to:ifError:": {
          "src": "evalString: aString to: anObject ifError: aBlock\n    \"Answer the stack top at the end of the evaluation of the code in\n     aString. If aString cannot be parsed, evaluate aBlock (see\n     compileString:ifError:). The code is executed as part of anObject\"\n    | s result next method |\n\n    s := ReadStream on: aString.\n    [\n\tnext := self extractEvalChunk: s.\n\tmethod := anObject class\n\t    compileString: 'Doit ^ [\n', next, ' ] value '\n\t    ifError: [:fname :lineNo :errorString | \n\t\taBlock value: fname value: lineNo - 1 value: errorString.\n\t\tnil\n\t    ].\n\n\tmethod isNil | (next allSatisfy: [ :each | each = Character space ])\n\t    ifFalse: [ [ result := anObject perform: method ] valueWithUnwind ].\n\n\ts atEnd ] whileFalse.\n\n    anObject class removeSelector: #Doit ifAbsent: [].\n    ^result",
          "literals": [],
          "methodName": "evalString:to:ifError:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "hasMethods": {
          "src": "hasMethods\n    \"Return whether the receiver has any methods defined\"\n\n    ^methodDictionary notNil and: [ methodDictionary size ~= 0 ]",
          "literals": [],
          "methodName": "hasMethods",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isPointers": {
          "src": "isPointers\n    \"Answer whether the instance variables of the receiver's instances\n     are objects\"\n    ^(self instanceSpec bitAt: 4) ~= 0",
          "literals": [],
          "methodName": "isPointers",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSuperclassesDo:": {
          "src": "allSuperclassesDo: aBlock\n    \"Invokes aBlock for all superclasses, both direct and indirect.\"\n    | class superclass |\n    class := self.\n    [ superclass := class superclass.\n      class := superclass.\n      superclass notNil ] whileTrue:\n      \t[ aBlock value: superclass ]",
          "literals": [],
          "methodName": "allSuperclassesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isIdentity": {
          "src": "isIdentity\n    \"Answer whether x = y implies x == y for instances of the receiver\"\n    ^false",
          "literals": [],
          "methodName": "isIdentity",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "sharedPools": {
          "src": "sharedPools\n    \"Return the names of the shared pools defined by the class\"\n    ^self superclass isNil\n\tifTrue: [ #() ]\n\tifFalse: [ self superclass sharedPools ]",
          "literals": [],
          "methodName": "sharedPools",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "selectSuperclasses:": {
          "src": "selectSuperclasses: aBlock\n    \"Return a Set of superclasses of the receiver satisfying aBlock.\"\n    | aSet |\n    aSet := Set new.\n    self allSuperclassesDo: [ :superclass | (aBlock value: superclass)\n    \t    \t    \t    \t    \t    ifTrue: [ aSet add: superclass ] ].\n    ^aSet",
          "literals": [],
          "methodName": "selectSuperclasses:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "withAllSubclassesDo:": {
          "src": "withAllSubclassesDo: aBlock\n    \"Invokes aBlock for the receiver and all subclasses, both direct\n     and indirect.\"\n    aBlock value: self.\n    self allSubclassesDo: aBlock.",
          "literals": [],
          "methodName": "withAllSubclassesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "article": {
          "src": "article\n    \"Answer an article (`a' or `an') which is ok for the receiver's name\"\n    ^self superclass article",
          "literals": [],
          "methodName": "article",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "methodsFor:stamp:": {
          "src": "methodsFor: category stamp: notUsed\n    \"Don't use this, it's only present to file in from Squeak\"\n    ^self methodsFor: category",
          "literals": [],
          "methodName": "methodsFor:stamp:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evaluate:to:ifError:": {
          "src": "evaluate: code to: anObject ifError: block\n   \"Evaluate Smalltalk expression as part of anObject's method definition.  This \n    method is used to support Inspector expression evaluation.  If a parsing error \n    is encountered, invoke error block, 'block'\" \n\n   (code isKindOf: PositionableStream)\n\tifTrue: [ ^self evalString: code contents to: anObject ifError: block ].\n    (code isMemberOf: String)\n\tifFalse: [ ^self evalString: code asString to: anObject ifError: block ].\n    ^self evalString: code to: anObject ifError: block.",
          "literals": [],
          "methodName": "evaluate:to:ifError:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "inheritsFrom:": {
          "src": "inheritsFrom: aClass\n    \"Returns true if aClass is a superclass of the receiver\"\n    | sc |\n    sc := self.\n    [ sc := sc superclass.\n      sc isNil ]\n    \twhileFalse:\n\t    [ sc == aClass ifTrue: [ ^true ] ].\n    ^false",
          "literals": [],
          "methodName": "inheritsFrom:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compiledMethodAt:": {
          "src": "compiledMethodAt: selector\n    \"Return the compiled method associated with selector, from the local\n    method dictionary.  Error if not found.\"\n    methodDictionary isNil\n\tifTrue: [ SystemExceptions NotFound signalOn: selector what: 'key' ].\n    ^methodDictionary at: selector",
          "literals": [],
          "methodName": "compiledMethodAt:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "name": {
          "src": "name\n    \"Answer the class name; this prints to the name of the superclass\n     enclosed in braces.  This class name is used, for example, to print\n     the receiver.\"\n    ^'{%1}' bindWith: self asClass name",
          "literals": [],
          "methodName": "name",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "subclasses": {
          "src": "subclasses\n    \"Answer the direct subclasses of the receiver in a Set\"\n    subClasses isNil\n\tifTrue: [ ^Set new ]\n\tifFalse: [ ^subClasses asSet ]",
          "literals": [],
          "methodName": "subclasses",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "selectorAt:": {
          "src": "selectorAt: method\n    \"Return selector for the given compiledMethod\"\n    ^methodDictionary keyAtValue: method.",
          "literals": [],
          "methodName": "selectorAt:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "addSubclass:": {
          "src": "addSubclass: aClass\n    \"Add aClass asone of the receiver's subclasses.\"\n    subClasses isNil \n\tifTrue: [ subClasses := Array new: 0 ]\n\tifFalse: [ \"remove old class if any\"\n\t\t  subClasses := subClasses copyWithout: aClass ].\n    subClasses := subClasses copyWith: aClass",
          "literals": [],
          "methodName": "addSubclass:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        ">>": {
          "src": ">> selector\n    \"Return the compiled method associated with selector, from the local\n    method dictionary.  Error if not found.\"\n    methodDictionary isNil\n\tifTrue: [ SystemExceptions NotFound signalOn: selector what: 'key' ].\n    ^methodDictionary at: selector",
          "literals": [],
          "methodName": ">>",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "instVarNames": {
          "src": "instVarNames\n    \"Answer an Array containing the instance variables defined by the receiver\"\n    | superVars |\n    instanceVariables isNil ifTrue: [ ^#() ].\n    superClass isNil\n\tifTrue: [ ^instanceVariables copy ]\n\tifFalse: [ superVars := superClass allInstVarNames.\n\t\t   ^instanceVariables copyFrom: superVars size+1 \n\t\t\t\t      to: instanceVariables size ]",
          "literals": [],
          "methodName": "instVarNames",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allInstVarNames": {
          "src": "allInstVarNames\n    \"Answer the names of every instance variables the receiver contained in the\n     receiver's instances\"\n    ^instanceVariables isNil ifTrue: [#()] ifFalse: [instanceVariables].",
          "literals": [],
          "methodName": "allInstVarNames",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "removeInstVarName:": {
          "src": "removeInstVarName: aString\n    \"Remove the given instance variable from the receiver and recompile\n     all of the receiver's subclasses\"\n    instanceVariables := instanceVariables copyWithout: aString asSymbol.\n    instanceSpec := instanceSpec - 4096.    \"Highly implementation specific\"\n    self asClass compileAll; compileAllSubclasses.\n    self asMetaclass compileAll; compileAllSubclasses.\n\n    self\n\tupdateInstanceVars: instanceVariables\n\tvariable: self isVariable\n\twords: self isWords\n\tpointers: self isPointers",
          "literals": [],
          "methodName": "removeInstVarName:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "kindOfSubclass": {
          "src": "kindOfSubclass\n    \"Return a string indicating the type of class the receiver is\"\n    self isVariable ifFalse: [ ^'subclass: ' ].\n    self isBytes ifTrue: [ ^'variableByteSubclass: ' ].\n\n    ^self isPointers\n\tifTrue: [ 'variableSubclass: ' ]\n\tifFalse: [ 'variableWordSubclass: ' ]",
          "literals": [],
          "methodName": "kindOfSubclass",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "selectors": {
          "src": "selectors\n    \"Answer a Set of the receiver's selectors\"\n    methodDictionary isNil\n    \tifTrue: [ ^Set new ]\n\tifFalse: [ ^methodDictionary keys ]",
          "literals": [],
          "methodName": "selectors",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "edit:": {
          "src": "edit: selector\n    \"Open Emacs to edit the method with the passed selector, then compile it\"\n    | method sourceFile sourcePos |\n    method := self compiledMethodAt: selector.\n    sourceFile := method methodSourceFile.\n    sourceFile isNil\n    \tifTrue: [ ^self error: 'decompiler can''t edit methods without source' ].\n    sourcePos := method methodSourcePos.\n    Smalltalk system: 'emacs -l st -smalltalk ', sourceFile, ' ', sourcePos printString\n\n\"   Possible Windows code follows: \"\"\n    method := self >> selector.\n    sourceFile := method methodSourceCode asString.\n    sourcePos := sourceFile size.\n\n    (sourceFile at: sourcePos) = $!\n\tifTrue: [ sourcePos := sourcePos - 1 ].\n\n    (FileStream open: 'st.tmp' mode: FileStream write)\n\tnextPutAll: (sourceFile copyFrom: 1 to: sourcePos);\n\tclose.\n\n    Smalltalk system: 'notepad st.tmp'.\n\n    sourceFile := FileStream open: 'st.tmp' mode: FileStream read.\n    self compile: sourceFile contents.\n    sourceFile close.\n\n    (self >> selector) methodCategory: method methodCategory.\n\n    Smalltalk system: 'del st.tmp' \"",
          "literals": [],
          "methodName": "edit:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "createGetMethod:": {
          "src": "createGetMethod: what\n    \"Create a method accessing the variable `what'.\"\n\n    ^self compile: ('%1\n    \"Answer the receiver''s %1\"\n    ^%1' bindWith: what)",
          "literals": [],
          "methodName": "createGetMethod:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "methodDictionary:": {
          "src": "methodDictionary: aDictionary\n    \"Set the receiver's method dictionary to aDictionary\"\n    | newDictionary |\n    newDictionary := aDictionary collect: [ :each |\n\teach withNewMethodClass: self\n    ].\n    aDictionary become: newDictionary.\n    Behavior flushCache.\n    methodDictionary := aDictionary.",
          "literals": [],
          "methodName": "methodDictionary:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "createSetMethod:": {
          "src": "createSetMethod: what\n    \"Create a method which sets the variable `what'.\"\n\n    | parameter |\n    parameter := (what = 'value') ifTrue: [ 'theValue' ] ifFalse: [ 'value' ].\n    \n    ^self compile: ('%1: %2\n    \"Set the receiver''s %1 to %2\"\n    %1 := %2' bindWith: what with: parameter)",
          "literals": [],
          "methodName": "createSetMethod:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compileAll:": {
          "src": "compileAll: aNotifier\n    \"Recompile all selectors in the receiver. Notify aNotifier by sen-\n     ding #error: messages if something goes wrong.\"\n    methodDictionary notNil\n\tifTrue: [\n\t    Transcript nextPutAll: 'Recompiling class: '; print: self; nl.\n\t    methodDictionary keysDo: \n\t\t      [ :selector | self recompile: selector notifying: aNotifier] ]",
          "literals": [],
          "methodName": "compileAll:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "subclassesDo:": {
          "src": "subclassesDo: aBlock\n    \"Invokes aBlock for all direct subclasses.\"\n    subClasses isNil ifTrue: [ ^self ].\n    subClasses do: aBlock",
          "literals": [],
          "methodName": "subclassesDo:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isFixed": {
          "src": "isFixed\n    \"Answer whether the receiver's instances have no indexed\n     instance variables\"\n    ^self isVariable not",
          "literals": [],
          "methodName": "isFixed",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "classPool": {
          "src": "classPool\n    \"Answer the class pool dictionary. Since Behavior does not support\n     classes with class variables, we answer an empty one; adding\n     variables to it results in an error.\"\n    ^Dictionary new makeReadOnly: true; yourself",
          "literals": [],
          "methodName": "classPool",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "withAllSuperclasses": {
          "src": "withAllSuperclasses\n    \"Answer the receiver and all of its superclasses in a collection\"\n    | supers |\n    supers := OrderedCollection with: self.\n    self allSuperclassesDo:\n    \t[ :superclass | supers addLast: superclass ].\n    ^supers",
          "literals": [],
          "methodName": "withAllSuperclasses",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "includesSelector:": {
          "src": "includesSelector: selector\n    \"Returns true if the local method dictionary contains the given selector\"\n    ^methodDictionary notNil and: [ methodDictionary includesKey: selector ]",
          "literals": [],
          "methodName": "includesSelector:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compile:notifying:": {
          "src": "compile: code notifying: requestor\n    \"Compile method source.  If there are parsing errors, send #error:\n     to the requestor object, else return a CompiledMethod result of\n     compilation\"\n    | method |\n    method := self compile: code.\n    method isNil ifTrue:\n\t[ ^requestor error: 'Compilation failed' ].\n    ^method",
          "literals": [],
          "methodName": "compile:notifying:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "evaluate:ifError:": {
          "src": "evaluate: code ifError: block\n    \"Evaluate 'code'.  If a parsing error is detected, invoke 'block'\"\n\n    (code isKindOf: PositionableStream)\n\tifTrue: [ ^self evalString: code contentsto: nil ifError: block ].\n    (code isMemberOf: String)\n\tifFalse: [ ^self evalString: code asString to: nil ifError: block ].\n    ^self evalString: code to: nil ifError: block.",
          "literals": [],
          "methodName": "evaluate:ifError:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isImmediate": {
          "src": "isImmediate\n    \"Answer whether, if x is an instance of the receiver, x copy == x\"\n    ^false",
          "literals": [],
          "methodName": "isImmediate",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "newInFixedSpace:": {
          "src": "newInFixedSpace: numInstanceVariables\n    \"Create a new instance of a class with indexed instance variables. The\n     instance has numInstanceVariables indexed instance variables.  The\n     instance is guaranteed not to move across garbage collections.  If\n     a subclass overrides #new:, the changes will apply to this method too.\"\n    ^(self new: numInstanceVariables) makeFixed",
          "literals": [],
          "methodName": "newInFixedSpace:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isBytes": {
          "src": "isBytes\n    \"Answer whether the instance variables of the receiver's\n     instances are bytes\"\n    ^self isPointers not & self isWords not",
          "literals": [],
          "methodName": "isBytes",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "setInstanceVariables:": {
          "src": "setInstanceVariables: instVariableArray\n    instanceVariables := instVariableArray",
          "literals": [],
          "methodName": "setInstanceVariables:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "compileAllSubclasses:": {
          "src": "compileAllSubclasses: aNotifier\n    \"Recompile all selector of all subclasses. Notify aNotifier by sen-\n     ding #error: messages if something goes wrong.\"\n    self allSubclassesDo: [ :subclass | subclass compileAll: aNotifier ]",
          "literals": [],
          "methodName": "compileAllSubclasses:",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "allSuperclasses": {
          "src": "allSuperclasses\n    \"Answer all the receiver's superclasses in a collection\"\n    | supers |\n    supers := OrderedCollection new.\n    self allSuperclassesDo:\n    \t[ :superclass | supers addLast: superclass ].\n    ^supers",
          "literals": [],
          "methodName": "allSuperclasses",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isBits": {
          "src": "isBits\n    \"Answer whether the instance variables of the receiver's instances\n     are bytes or words\"\n    ^self isPointers not",
          "literals": [],
          "methodName": "isBits",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "environment": {
          "src": "environment\n    \"Answer the namespace that this class belongs to - the same as the\n     superclass, since Behavior does not support namespaces yet.\"\n    ^self superclass environment",
          "literals": [],
          "methodName": "environment",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "instanceSpec": {
          "src": "instanceSpec\n    ^instanceSpec",
          "literals": [],
          "methodName": "instanceSpec",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        },
        "isVariable": {
          "src": "isVariable\n    \"Answer whether the receiver's instances have indexed instance variables\"\n    ^(self instanceSpec bitAt: 2) ~= 0",
          "literals": [],
          "methodName": "isVariable",
          "className": "Behavior",
          "category": "testing functionality",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "ClassDescription",
          "instance_methods": {
            "copyAll:from:": {
              "src": "copyAll: arrayOfSelectors from: class\n    \"Copy all the selectors in arrayOfSelectors from class, assigning them the\n     same category they have in class\"\n    arrayOfSelectors do:\n\t[ :selector | self copy: selector\n\t\t\t   from: class ]",
              "literals": [],
              "methodName": "copyAll:from:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "nameIn:": {
              "src": "nameIn: aNamespace\n    \"Answer the class name when the class is referenced from aNamespace\"\n    ^self environment == aNamespace\n\tifTrue: [ self printString ]\n\tifFalse: [ (self environment nameIn: aNamespace), ' ',\n\t  self printString ]",
              "literals": [],
              "methodName": "nameIn:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "classVariableString": {
              "src": "classVariableString\n    self subclassResponsibility",
              "literals": [],
              "methodName": "classVariableString",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "createGetMethod:": {
              "src": "createGetMethod: what\n    \"Create a method accessing the variable `what'.\"\n\n    ^(super createGetMethod: what)\n\tmethodCategory: 'accessing'",
              "literals": [],
              "methodName": "createGetMethod:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "sharedVariableString": {
              "src": "sharedVariableString\n    self subclassResponsibility",
              "literals": [],
              "methodName": "sharedVariableString",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "createSetMethod:": {
              "src": "createSetMethod: what\n    \"Create a method which sets the variable `what'.\"\n\n    ^(super createSetMethod: what)\n\tmethodCategory: 'accessing'",
              "literals": [],
              "methodName": "createSetMethod:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "asMetaclass": {
              "src": "asMetaclass\n    \"Answer the metaclass associated to the receiver\"\n    ^self asClass class",
              "literals": [],
              "methodName": "asMetaclass",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "copyAllCategoriesFrom:": {
              "src": "copyAllCategoriesFrom: aClass\n    \"Copy all the selectors in aClass, assigning them the original category\"\n    | method |\n    aClass selectors do:\n\t[ :selector | self copy: selector from: aClass ]",
              "literals": [],
              "methodName": "copyAllCategoriesFrom:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "collectCategories": {
              "src": "collectCategories\n    \"Answer all the method categories, sorted by name\"\n\n    | categories |\n    methodDictionary isNil ifTrue: [ ^#() ].\n\n    categories := Set new.\n    methodDictionary do:\n\t[ :method | categories add: (method methodCategory) ].\n\n    ^categories asSortedCollection",
              "literals": [],
              "methodName": "collectCategories",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "copyCategory:from:classified:": {
              "src": "copyCategory: categoryName from: aClass classified: newCategoryName\n    \"Copy all the selectors in from aClass that belong to the given category,\n     reclassifying them as belonging to the given category\"\n    | method |\n    aClass selectors do:\n\t[ :selector | method := aClass compiledMethodAt: selector.\n\t\t      method methodCategory = categoryName\n\t\t\t  ifTrue: [ self copy: selector\n\t\t\t\t\t from: aClass\n\t\t\t\t\t classified: newCategoryName ] ]",
              "literals": [],
              "methodName": "copyCategory:from:classified:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "copyAll:from:classified:": {
              "src": "copyAll: arrayOfSelectors from: class classified: categoryName\n    \"Copy all the selectors in arrayOfSelectors from aClass, assigning them\n     the given category\"\n    arrayOfSelectors do:\n\t[ :selector | self copy: selector\n\t\t\t   from: class\n\t\t\t   classified: categoryName ]",
              "literals": [],
              "methodName": "copyAll:from:classified:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "classify:under:": {
              "src": "classify: aSelector under: aString\n    \"Put the method identified by the selector aSelector\n     under the category given by aString.\"\n    ^(self >> aSelector) methodCategory: aString",
              "literals": [],
              "methodName": "classify:under:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "copy:from:classified:": {
              "src": "copy: selector from: aClass classified: categoryName\n    \"Copy the given selector from aClass, assigning it the given category\"\n    | method |\n    method := (aClass compiledMethodAt: selector) withNewMethodClass: self.\n    method methodCategory: categoryName.\n    methodDictionary at: selector put: method",
              "literals": [],
              "methodName": "copy:from:classified:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "compile:classified:notifying:": {
              "src": "compile: code classified: categoryName notifying: requestor\n    \"Compile method source and install in method category, categoryName.  If\n     there are parsing errors, send an error message to requestor\"\n    | method |\n    method := self compile: code notifying: requestor.\n    method notNil \n\t\tifTrue: [method methodCategory: categoryName].\n    ^method",
              "literals": [],
              "methodName": "compile:classified:notifying:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "removeCategory:": {
              "src": "removeCategory: aString\n    \"Remove from the receiver every method belonging to the given category\"\n    | selector method category |\n    methodDictionary isNil\n    \tifTrue: [ ^self ].\n\n    methodDictionary copy associationsDo: [ :assoc |\n\tmethod := assoc value.\n\tmethod methodCategory = category ifTrue: [\n\t   methodDictionary removeAssociation: assoc\n\t]\n    ].",
              "literals": [],
              "methodName": "removeCategory:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "createGetMethod:default:": {
              "src": "createGetMethod: what default: value\n    \"Create a method accessing the variable `what', with a default value\n    of `value', using lazy initialization\"\n\n    ^(super createGetMethod: what default: value)\n\tmethodCategory: 'accessing'",
              "literals": [],
              "methodName": "createGetMethod:default:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "compile:classified:ifError:": {
              "src": "compile: code classified: categoryName ifError: block\n    \"Compile method source and install in method category, categoryName.  If\n     there are parsing errors, invoke exception block, 'block' (see\n     compile:ifError:).  Return the method\"\n    | method |\n    method := self compile: code ifError: [ :f :l :e |\n        ^block value: f value: l value: e\n    ].\n\n    method methodCategory: categoryName.\n    ^method",
              "literals": [],
              "methodName": "compile:classified:ifError:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "fileOut:": {
              "src": "fileOut: fileName\n    \"Open the given file and to file out a complete class description to it\"\n\n    | aFileStream  |\n    aFileStream := FileStream open: fileName mode: FileStream write.\n\n    Transcript nextPutAll: 'Filing out class to: '; nextPutAll: fileName.\n    \n    self fileOutOn: aFileStream. \n    aFileStream close.",
              "literals": [],
              "methodName": "fileOut:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "fileOutCategory:toStream:": {
              "src": "fileOutCategory: category toStream: aFileStream\n    \"File out all the methods belonging to the method category, categoryName,\n     to aFileStream\"\n\n    | methods |\n    self selectors isNil ifTrue: [ ^self ].\n\n    aFileStream\n\tnextPut: $!;\n\tprint: self;\n\tnextPutAll: ' methodsFor: ';\n\tstore: category;\n\tnextPut: $!.\n\n    methods := self selectors select: [ :selector |\n\t(self compiledMethodAt: selector) methodCategory = category\n    ].\n\n    methods asSortedCollection do: [ :selector |\n\taFileStream\n\t    nextPutAll: '\n\n';\t    nextPutAll: (self sourceCodeAt: selector);\n\t    nextPut: $!\n    ].\n    aFileStream nextPutAll: ' !\n\n'",
              "literals": [],
              "methodName": "fileOutCategory:toStream:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "compile:classified:": {
              "src": "compile: code classified: categoryName\n    \"Compile code in the receiver, assigning the method to the given category.\n     Answer the newly created CompiledMethod, or nil if an error was found.\"\n    | method |\n    method := self compile: code.\n    method notNil \n\t\tifTrue: [method methodCategory: categoryName].\n    ^method",
              "literals": [],
              "methodName": "compile:classified:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "fileOutSelector:to:": {
              "src": "fileOutSelector: selector to: fileName\n    \"File out the given selector to fileName\"\n\n    | aFileStream |\n    aFileStream := FileStream open: fileName mode: FileStream write.\n\n    Transcript nextPutAll: 'Filing out a selector to: '; nextPutAll: fileName.\n    self fileOutHeaderOn: aFileStream.\n    aFileStream nextPutAll: '!';\n\tprint: self;\n\tnextPutAll: ' methodsFor: ';\n\tstore: (self compiledMethodAt: selector) methodCategory;\n\tnextPut: $!;\n\tnl;\n\tnextPutAll: (self sourceCodeAt: selector) ;\n\tnextPutAll: '! !';\n\tclose",
              "literals": [],
              "methodName": "fileOutSelector:to:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "copyCategory:from:": {
              "src": "copyCategory: categoryName from: aClass\n    \"Copy all the selectors in from aClass that belong to the given category\"\n    | method |\n    aClass selectors do:\n\t[ :selector | method := aClass compiledMethodAt: selector.\n\t\t      method methodCategory = categoryName\n\t\t\t  ifTrue: [ self copy: selector from: aClass ] ]",
              "literals": [],
              "methodName": "copyCategory:from:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "fileOutOn:": {
              "src": "fileOutOn: aFileStream\n    \"File out complete class description:  class definition, class and\n     instance methods\"\n\n    self subclassResponsibility",
              "literals": [],
              "methodName": "fileOutOn:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "asClass": {
              "src": "asClass\n    self subclassResponsibility",
              "literals": [],
              "methodName": "asClass",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "defineCFunc:withSelectorArgs:returning:args:": {
              "src": "defineCFunc: cFuncNameString\n  withSelectorArgs: selectorAndArgs\n  returning: returnTypeSymbol \n  args: argsArray\n    \"See documentation. Too complex to describe it here ;-)\"\n\n    ^(super defineCFunc: cFuncNameString\n\t     withSelectorArgs: selectorAndArgs\n\t     returning: returnTypeSymbol \n\t     args: argsArray) methodCategory: 'C functions'",
              "literals": [],
              "methodName": "defineCFunc:withSelectorArgs:returning:args:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "fileOutCategory:to:": {
              "src": "fileOutCategory: categoryName to: fileName\n    \"File out all the methods belonging to the method category, categoryName,\n     to the fileName file\"\n\n    | aFileStream |\n    aFileStream := FileStream open: fileName mode: FileStream write.\n\n    Transcript nextPutAll: 'Filing out a category to: '; nextPutAll: fileName.\n\n    self fileOutCategory: categoryName toStream: aFileStream.\n    aFileStream close",
              "literals": [],
              "methodName": "fileOutCategory:to:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "whichCategoryIncludesSelector:": {
              "src": "whichCategoryIncludesSelector: selector\n    \"Answer the category for the given selector, or nil if the selector is\n     not found\"\n    \n    | method |\n    methodDictionary isNil ifTrue: [ ^nil ].\n    method := methodDictionary at: selector ifAbsent: [ ^nil ].\n    ^method methodCategory",
              "literals": [],
              "methodName": "whichCategoryIncludesSelector:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "copy:from:": {
              "src": "copy: selector from: aClass\n    \"Copy the given selector from aClass, assigning it the same category\"\n    | method |\n    method := aClass compiledMethodAt: selector.\n    methodDictionary at: selector put: (method withNewMethodClass: self).",
              "literals": [],
              "methodName": "copy:from:",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            },
            "instanceVariableString": {
              "src": "instanceVariableString\n    \"Answer a string containing the name of the receiver's instance variables.\"\n    | stream |\n    instanceVariables isNil ifTrue: [ ^'' ].\n    stream := WriteStream on: (String new: 0).\n    instanceVariables do: [ :instVarName |\n\tstream nextPutAll: instVarName; nextPut: ($ ) ].\n    ^stream contents",
              "literals": [],
              "methodName": "instanceVariableString",
              "className": "ClassDescription",
              "category": "conversion",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": [
            {
              "className": "Class",
              "instance_methods": {
                "nonVersionedInstSize": {
                  "src": "nonVersionedInstSize\n    \"Answer the number of instance variables that the class used to have\n     when objects were stored without using a VersionableObjectProxy.\n     The default implementation answers the current instSize.\"\n    ^self instSize",
                  "literals": [],
                  "methodName": "nonVersionedInstSize",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "setEnvironment:": {
                  "src": "setEnvironment: aNamespace\n    environment := aNamespace.",
                  "literals": [],
                  "methodName": "setEnvironment:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "subclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:": {
                  "src": "subclass: classNameString classInstanceVariableNames: stringClassInstVarNames instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tsubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
                  "literals": [],
                  "methodName": "subclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:": {
                  "src": "variableSubclass: classNameString instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tvariableSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
                  "literals": [],
                  "methodName": "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
                  "src": "variableWordSubclass: classNameString\n  instanceVariableNames: stringInstVarNames\n  classVariableNames: stringOfClassVarNames\n  poolDictionaries: stringOfPoolNames\n  category: categoryNameString\n    \"Define a word variable subclass of the receiver with the given\n     name, instance variables (must be ''), class variables, pool\n     dictionaries and category. If the class is already defined, if\n     necessary, recompile everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t    environment: Namespace current\n\t    subclassOf: self\n\t    instanceVariableNames: stringInstVarNames\n\t    variable: true\n\t    words: true\n\t    pointers: false\n\t    classVariableNames: stringOfClassVarNames\n\t    poolDictionaries: stringOfPoolNames\n\t    category: categoryNameString",
                  "literals": [],
                  "methodName": "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "classVarNames": {
                  "src": "classVarNames\n    \"Answer the names of the variables in the class pool dictionary\"\n    ^classVariables notNil\n\tifTrue: [ classVariables keys ]\n\tifFalse: [ Set new ].",
                  "literals": [],
                  "methodName": "classVarNames",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "removeSharedPool:": {
                  "src": "removeSharedPool: aDictionary\n    \"Remove the given dictionary to the list of the class' pool dictionaries\"\n    sharedPools := sharedPools copyWithout: aDictionary",
                  "literals": [],
                  "methodName": "removeSharedPool:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableByteSubclass:classVariableNames:poolDictionaries:": {
                  "src": "variableByteSubclass: classNameString classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tvariableByteSubclass: classNameString\n\tinstanceVariableNames: ''\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
                  "literals": [],
                  "methodName": "variableByteSubclass:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "sharedPoolDictionaries": {
                  "src": "sharedPoolDictionaries\n    \"Return the shared pools (not the names!) defined by the class\"\n    ^sharedPools",
                  "literals": [],
                  "methodName": "sharedPoolDictionaries",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableLongSubclass:classVariableNames:poolDictionaries:": {
                  "src": "variableLongSubclass: classNameString classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tvariableWordSubclass: classNameString\n\tinstanceVariableNames: ''\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
                  "literals": [],
                  "methodName": "variableLongSubclass:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "convertFromVersion:withFixedVariables:indexedVariables:for:": {
                  "src": "convertFromVersion: version withFixedVariables: fixed\n\t\t\t    indexedVariables: indexed\n\t\t\t    for: anObjectDumper\n\n    \"This method is called if a VersionableObjectProxy is attached to\n     a class.  It receives the version number that was stored for the\n     object (or nil if the object did not use a VersionableObjectProxy),\n     the fixed instance variables, the indexed instance variables,\n     and the ObjectDumper that has read the object.\n     The default implementation ignores the version and simply fills\n     in an instance of the receiver with the given fixed and indexed\n     instance variables (nil if the class instances are of fixed size).\n     If instance variables were removed from the class, extras are\n     ignored; if the class is now fixed and used to be indexed,\n     indexed is not used.\"\n\n    | object |\n    object := self isFixed\n\tifTrue: [ self basicNew ]\n\tifFalse: [ self basicNew: indexed size ].\n\n    fixed\n\tfrom: 1\n\tto: (fixed size min: self instSize)\n\tkeysAndValuesDo: [ :i :obj | object instVarAt: i put: obj ].\n\n    (self isFixed or: [ indexed isNil ]) ifTrue: [ ^object ].\n\n    indexed keysAndValuesDo: [ :i :obj | object basicAt: i put: obj ].\n    ^object",
                  "literals": [],
                  "methodName": "convertFromVersion:withFixedVariables:indexedVariables:for:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "category:": {
                  "src": "category: aString\n    \"Change the class category to aString\"\n    category := aString",
                  "literals": [],
                  "methodName": "category:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
                  "src": "variableByteSubclass: classNameString\n  instanceVariableNames: stringInstVarNames\n  classVariableNames: stringOfClassVarNames\n  poolDictionaries: stringOfPoolNames\n  category: categoryNameString\n    \"Define a byte variable subclass of the receiver with the given\n     name, instance variables (must be ''), class variables, pool\n     dictionaries and category. If the class is already defined, if\n     necessary, recompile everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t    environment: Namespace current\n\t    subclassOf: self\n\t    instanceVariableNames: stringInstVarNames\n\t    variable: true\n\t    words: false\n\t    pointers: false\n\t    classVariableNames: stringOfClassVarNames\n\t    poolDictionaries: stringOfPoolNames\n\t    category: categoryNameString",
                  "literals": [],
                  "methodName": "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "sharedPools": {
                  "src": "sharedPools\n    \"Return the names of the shared pools defined by the class\"\n    | s |\n    s := Set new.\n    sharedPools notNil ifTrue: [\n\tself environment associationsDo: [ :each |\n\t    (sharedPools includes: each value)\n\t\tifTrue: [ s add: each key ]\n\t]\n    ].\n    ^s",
                  "literals": [],
                  "methodName": "sharedPools",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "setName:": {
                  "src": "setName: aString\n    name := aString.",
                  "literals": [],
                  "methodName": "setName:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "comment:": {
                  "src": "comment: aString\n    \"Change the class name\"\n    comment := aString",
                  "literals": [],
                  "methodName": "comment:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "subclass:instanceVariableNames:classVariableNames:poolDictionaries:": {
                  "src": "subclass: classNameString instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tsubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
                  "literals": [],
                  "methodName": "subclass:instanceVariableNames:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "article": {
                  "src": "article\n    \"Answer an article (`a' or `an') which is ok for the receiver's name\"\n    | name |\n    name := self name.\n    ^(name at: 1) isVowel ifTrue: [ 'an' ] ifFalse: [ 'a' ].",
                  "literals": [],
                  "methodName": "article",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "extend": {
                  "src": "extend\n    \"Redefine a version of the receiver in the current namespace.  Note:\n    this method can bite you in various ways when sent to system classes;\n    read the section on namespaces in the manual for some examples of the\n    problems you can encounter.\"\n\n    | method |\n    method := self kindOfSubclass,\n\t'instanceVariableNames:classVariableNames:poolDictionaries:category:'.\n\n    ^self\n        perform: method asSymbol\n        withArguments: {self name asSymbol. ''. ''. ''. 'Extensions'}",
                  "literals": [],
                  "methodName": "extend",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "allClassVarNames": {
                  "src": "allClassVarNames\n    \"Answer the names of the variables in the receiver's class pool dictionary\n     and in each of the superclasses' class pool dictionaries\"\n    | superVarNames |\n    superVarNames :=  self classVarNames.\n    self allSuperclasses do: [ :each |\n\tsuperVarNames addAll: each classVarNames].\n    ^superVarNames.",
                  "literals": [],
                  "methodName": "allClassVarNames",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    aStream nextPutAll: self name",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableByteSubclass:classInstanceVariableNames:classVariableNames:poolDictionaries:": {
                  "src": "variableByteSubclass: classNameString classInstanceVariableNames: stringClassInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tvariableByteSubclass: classNameString\n\tinstanceVariableNames: ''\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
                  "literals": [],
                  "methodName": "variableByteSubclass:classInstanceVariableNames:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableLongSubclass:classInstanceVariableNames:classVariableNames:poolDictionaries:": {
                  "src": "variableLongSubclass: classNameString classInstanceVariableNames: stringClassInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tvariableWordSubclass: classNameString\n\tinstanceVariableNames: ''\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
                  "literals": [],
                  "methodName": "variableLongSubclass:classInstanceVariableNames:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "fileOutOn:": {
                  "src": "fileOutOn: aFileStream\n    \"File out complete class description:  class definition, class and\n     instance methods\"\n\n    self fileOutHeaderOn: aFileStream. \n    self fileOutDeclarationOn: aFileStream.\n\n    self class collectCategories do:\n\t[ :category | self class fileOutCategory: category toStream: aFileStream ].\n\n    self collectCategories do:\n\t[ :category | self fileOutCategory: category toStream: aFileStream ].\n\n    (self class includesSelector: #initialize) ifTrue: [\n\taFileStream nl; print: self; nextPutAll: ' initialize!'.\n    ].\n    aFileStream nl",
                  "literals": [],
                  "methodName": "fileOutOn:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "name": {
                  "src": "name\n    \"Answer the class name\"\n    ^name",
                  "literals": [],
                  "methodName": "name",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "addSharedPool:": {
                  "src": "addSharedPool: aDictionary\n    \"Add the given shared pool to the list of the class' pool dictionaries\"\n    (sharedPools includes: aDictionary)\n    \tifFalse: [ sharedPools := sharedPools copyWith: aDictionary ]",
                  "literals": [],
                  "methodName": "addSharedPool:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "removeClassVarName:": {
                  "src": "removeClassVarName: aString\n    \"Removes the class variable from the class, error if not present, or\n     still in use.\"\n    | sym |\n    sym := aString asSymbol.\t\"### maybe this should remain a string? \"\n    \" ### test for use in sub method \"\n    (classVariables notNil and: [classVariables includesKey: sym])\n    \tifTrue: [ ^classVariables removeKey: sym ].\n\n    SystemExceptions NotFound signalOn: aString what: 'class variable'",
                  "literals": [],
                  "methodName": "removeClassVarName:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "asClass": {
                  "src": "asClass\n    ^self",
                  "literals": [],
                  "methodName": "asClass",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "=": {
                  "src": "= aClass\n    \"Returns true if the two class objects are to be considered equal.\"\n    \"^(aClass isKindOf: Class) and: [name = aClass name]\"\n    ^self == aClass",
                  "literals": [],
                  "methodName": "=",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "addClassVarName:": {
                  "src": "addClassVarName: aString\n    \"Add a class variable with the given name to the class pool dictionary\"\n    | sym |\n    sym := aString asSymbol.\t\"### maybe this should remain a string? \"\n\n    classVariables isNil\n\tifTrue: [ classVariables := Dictionary new ]\n\tifFalse: [\n\t     (classVariables includesKey: sym)\n    \t         ifTrue: [ SystemExceptions AlreadyDefined signalOn: aString ]\n\t].\n\n    classVariables at: sym put: nil",
                  "literals": [],
                  "methodName": "addClassVarName:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "environment:": {
                  "src": "environment: aNamespace\n    \"Set the receiver's environment to aNamespace and recompile everything\"\n    environment := aNamespace.\n    self asClass compileAll; compileAllSubclasses.\n    self asMetaclass compileAll; compileAllSubclasses.",
                  "literals": [],
                  "methodName": "environment:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "storeOn:": {
                  "src": "storeOn: aStream\n    \"Store Smalltalk code compiling to the receiver on aStream\"\n    aStream nextPutAll: self name",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "setClassVariables:": {
                  "src": "setClassVariables: aDictionary\n    classVariables := aDictionary.",
                  "literals": [],
                  "methodName": "setClassVariables:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "fileOutDeclarationOn:": {
                  "src": "fileOutDeclarationOn: aFileStream\n    \"File out class definition to aFileStream\"\n    | aSet printFormattedSet superclassName |\n    self isMetaclass ifTrue: [ ^self].\n\n    printFormattedSet := [ \n\taFileStream nextPutAll: ''''. \n\t(aSet isEmpty) not ifTrue: [\n\t    aSet do: [ :element |\n\t\taFileStream nextPutAll: element; space ]. \n\t    aFileStream nextPutAll: ''''.\n\t].\n    ].\n\n    superclassName := self superclass isNil\n\tifTrue: [ 'nil' ]\n\tifFalse: [ self superclass nameIn: self environment ].\n\n    aFileStream\n\tnextPutAll: superclassName; space;\n\tnextPutAll: self kindOfSubclass; space;\n\tstore: name asSymbol.\n\n    aFileStream nl; tab; nextPutAll: 'instanceVariableNames: '.\n\t((aSet := self instVarNames ) isEmpty)\n\t    ifTrue:[aFileStream nextPutAll: '''''']\n\t    ifFalse: printFormattedSet.\n\n    aFileStream nl; tab; nextPutAll: 'classVariableNames: '.\n\t(aSet := self classVarNames) isEmpty\n\t    ifTrue:[aFileStream nextPutAll: '''''']\n\t    ifFalse: printFormattedSet.\n\n    aFileStream nl; tab; nextPutAll: 'poolDictionaries: '.\n\t(aSet := self sharedPools) isEmpty\n\t    ifTrue:[aFileStream nextPutAll: '''''']\n\t    ifFalse: printFormattedSet.\n\n    aFileStream nl; tab; nextPutAll: 'category: ';\n\tstore: category;\n\tnextPut: $!;\n\tnl; nl;\n\tprint: self;\n\tnextPutAll: ' comment: ';\n\tnl;\n\tstore: self comment;\n\tnextPut: $!;\n\tnl; nl.\n\n    ((aSet := self class instVarNames) isEmpty)\n\tifTrue:[ ^self ].\n\n    aFileStream print: self class; nextPutAll: ' instanceVariableNames: '.\n    printFormattedSet value.\n    aFileStream nextPut: $!; nl; nl.",
                  "literals": [],
                  "methodName": "fileOutDeclarationOn:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "binaryRepresentationVersion": {
                  "src": "binaryRepresentationVersion\n    \"Answer a number >= 0 which represents the current version of the\n     object's representation.  The default implementation answers\n     zero.\"\n    ^0",
                  "literals": [],
                  "methodName": "binaryRepresentationVersion",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "setSharedPools:": {
                  "src": "setSharedPools: anArray\n    \"Private - Set the receiver's shared pools to be those in anArray\"\n    sharedPools := anArray",
                  "literals": [],
                  "methodName": "setSharedPools:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "categoriesFor:are:": {
                  "src": "categoriesFor: method are: categories\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    (self >> method) methodCategory: (categories at: 1)",
                  "literals": [],
                  "methodName": "categoriesFor:are:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:": {
                  "src": "variableSubclass: classNameString classInstanceVariableNames: stringClassInstVarNames instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tvariableSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
                  "literals": [],
                  "methodName": "variableSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "classPool": {
                  "src": "classPool\n    \"Answer the class pool dictionary\"\n    classVariables isNil ifTrue: [ classVariables := Dictionary new ].\n    ^classVariables",
                  "literals": [],
                  "methodName": "classPool",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "isClass": {
                  "src": "isClass\n    ^true",
                  "literals": [],
                  "methodName": "isClass",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "fileOutHeaderOn:": {
                  "src": "fileOutHeaderOn: aFileStream\n    \"Write date and time stamp to aFileStream\"\n    | now |\n    aFileStream nextPutAll: '\"Filed out from ';\n\tnextPutAll: Smalltalk version;\n\tnextPutAll: ' on '.\n    now := Date dateAndTimeNow.\n    aFileStream print: now asDate;\n\tnextPutAll:  '  ';\n\tprint: now asTime;\n\tnextPutAll: '\"!\n\n'",
                  "literals": [],
                  "methodName": "fileOutHeaderOn:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "environment": {
                  "src": "environment\n    ^environment",
                  "literals": [],
                  "methodName": "environment",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
                  "src": "subclass: classNameString\n    instanceVariableNames: stringInstVarNames\n    classVariableNames: stringOfClassVarNames\n    poolDictionaries: stringOfPoolNames\n    category: categoryNameString\n    \"Define a fixed subclass of the receiver with the given name, instance\n     variables, class variables, pool dictionaries and category. If the\n     class is already defined, if necessary, recompile everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t  environment: Namespace current\n\t  subclassOf: self\n\t  instanceVariableNames: stringInstVarNames\n\t  variable: false\n\t  words: false\n\t  pointers: true\n\t  classVariableNames: stringOfClassVarNames\n\t  poolDictionaries: stringOfPoolNames\n\t  category: categoryNameString",
                  "literals": [],
                  "methodName": "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "comment": {
                  "src": "comment\n    \"Answer the class comment\"\n    ^comment",
                  "literals": [],
                  "methodName": "comment",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "initialize": {
                  "src": "initialize\t\t\t\"redefined in children (?)\"\n    ^self",
                  "literals": [],
                  "methodName": "initialize",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "classInstanceVariableNames:": {
                  "src": "classInstanceVariableNames: stringClassInstVarNames\n    self class instanceVariableNames: stringClassInstVarNames",
                  "literals": [],
                  "methodName": "classInstanceVariableNames:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "category": {
                  "src": "category\n    \"Answer the class category\"\n    ^category",
                  "literals": [],
                  "methodName": "category",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
                  "src": "variableSubclass: classNameString\n    instanceVariableNames: stringInstVarNames\n    classVariableNames: stringOfClassVarNames\n    poolDictionaries: stringOfPoolNames\n    category: categoryNameString\n    \"Define a variable pointer subclass of the receiver with the given\n     name, instance variables, class variables, pool dictionaries and\n     category. If the class is already defined, if necessary, recompile\n     everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t  environment: Namespace current\n\t  subclassOf: self\n\t  instanceVariableNames: stringInstVarNames\n\t  variable: true\n\t  words: false\n\t  pointers: true\n\t  classVariableNames: stringOfClassVarNames\n\t  poolDictionaries: stringOfPoolNames\n\t  category: categoryNameString",
                  "literals": [],
                  "methodName": "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                },
                "metaclassFor:": {
                  "src": "metaclassFor: classNameString\n    \"Create a Metaclass object for the given class name. The metaclass\n     is a subclass of the receiver's metaclass\"\n    | className class |\n    className := classNameString asSymbol.\n    class := Smalltalk\n\tclassAt: className \n\tifAbsent: [ ^Metaclass subclassOf: self class ].\n\n    ^class class",
                  "literals": [],
                  "methodName": "metaclassFor:",
                  "className": "Class",
                  "category": "saving and loading",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            },
            {
              "className": "Metaclass",
              "instance_methods": {
                "storeOn:": {
                  "src": "storeOn: aStream\n    \"Store Smalltalk code compiling to the receiver on aStream\"\n    self printOn: aStream",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "validateIdentifier:": {
                  "src": "validateIdentifier: token\n    \"Token is a string or string-oid\"\n    | firstTime |\n    firstTime := true.\n    token do: [ :ch |\n\t(ch isLetter | (firstTime not and: [ ch = $_ | ch isDigit ]))\n\t    ifFalse: [ SystemExceptions InvalidValue signalOn: token reason: 'invalid Smalltalk identifier' ].\n\n\tfirstTime := false\n    ].\n    ^true",
                  "literals": [],
                  "methodName": "validateIdentifier:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "growClassInstance": {
                  "src": "growClassInstance\n    | newClass numInstVars |\n    newClass := self new.\n    numInstVars := self instSize.\n    numInstVars printNl.\n    1 to: numInstVars - 1 do:\n\t[ :i | newClass instVarAt: i put: \n\t\t   (instanceClass instVarAt: i) ].\n\n    instanceClass become: newClass.",
                  "literals": [],
                  "methodName": "growClassInstance",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "instanceVariableNames:": {
                  "src": "instanceVariableNames: classInstVarNames\n\n    \"Set the class-instance variables for the receiver to be those\n     in classInstVarNames\"\n\n    | variableArray variableString |\n    variableString := self superclass instanceVariableString,\n\tclassInstVarNames.\n    variableArray := self parseVariableString: variableString.\n\n    1 to: variableArray size do:\n\t[ :i | variableArray at: i put: (variableArray at: i) asSymbol ].\n\n    \"If instance variables change, update  instance variables and\n     instance spec of the class and all its subclasses \"\n\n    variableArray = self allInstVarNames ifTrue: [ ^self ].\n\n    self\n\tupdateInstanceVars: variableArray \n\tvariable: false\n\twords: false\n\tpointers: true.\n\n    \"If no variable has been removed, no need to recompile\"\n    (self allInstVarNames allSatisfy: [ :each | variableArray includes: each ])\n\tifTrue: [ ^self ].\n\t\n    Transcript nextPutAll: 'Recompiling classes...'; nl.\n    self compileAll.\n    self compileAllSubclasses",
                  "literals": [],
                  "methodName": "instanceVariableNames:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "nameIn:": {
                  "src": "nameIn: aNamespace\n    \"Answer the class name when the class is referenced from aNamespace\n     - a dummy one, since Behavior does not support names.\"\n    ^self environment == aNamespace\n\tifTrue: [ self printString ]\n\tifFalse: [ self environment storeString, ' ', self printString ]",
                  "literals": [],
                  "methodName": "nameIn:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "parsePools:in:": {
                  "src": "parsePools: aString in: aNamespace\n    | stream tokens |\n    stream := TokenStream on: aString.\n    tokens := stream contents.\n    ^tokens collect: [ :poolName |\n\t(poolName substrings: $.) inject: aNamespace into: [ :namespace :key |\n\t    self validateIdentifier: key.\n\t    namespace\n\t        at: key asSymbol\n\t        ifAbsent: [ SystemExceptions NotFound signalOn: poolName what: 'pool' ]\n\t]\n    ].",
                  "literals": [],
                  "methodName": "parsePools:in:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "allSharedPools": {
                  "src": "allSharedPools\n    \"Return the names of the shared pools defined by the class and any of\n     its superclasses\"\n\n    ^self instanceClass allSharedPools",
                  "literals": [],
                  "methodName": "allSharedPools",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "name:environment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:": {
                  "src": "name: newName\n    environment: aNamespace\n    subclassOf: superclass\n    instanceVariableNames: stringOfInstVarNames\n    variable: variableBoolean\n    words: wordBoolean\n    pointers: pointerBoolean\n    classVariableNames: stringOfClassVarNames\n    poolDictionaries: stringOfPoolNames\n    category: categoryName\n\n    \"Private - create a full featured class and install it, or change an\n     existing one\"\n\n    | aClass variableString variableArray sharedPoolNames poolName poolDict \n      className classVarDict  needToRecompileMetaclasses needToRecompileClasses |\n\n    \"Initialize a metaclass\"\n\n    className := newName asSymbol.\n    aClass := aNamespace hereAt: className ifAbsent: [ nil ].\n    aClass isNil ifTrue: [\n\t^self newMeta: className\n\t    environment: aNamespace\n\t    subclassOf: superclass\n\t    instanceVariableNames: stringOfInstVarNames\n\t    variable: variableBoolean\n\t    words: wordBoolean\n\t    pointers: pointerBoolean\n\t    classVariableNames: stringOfClassVarNames\n\t    poolDictionaries: stringOfPoolNames\n\t    category: categoryName\n    ].\n\n    needToRecompileMetaclasses := false.\n\n    (aClass isVariable & aClass isBits) ifTrue: [\n\t(variableBoolean not | pointerBoolean) ifTrue: [\n\t    SystemExceptions MutationError signal: 'Cannot change non-pointer subclass to pointer subclass'\n\t].\n\taClass isWords ~~ wordBoolean ifTrue: [\n\t    SystemExceptions MutationError signal: 'Cannot change representation of non-pointer subclass'\n\t]\n    ].\n\n    \"Inherit instance variables from parent\"\n    variableString := superclass notNil \n\tifTrue: [ superclass instanceVariableString, stringOfInstVarNames ]\n\tifFalse: [ stringOfInstVarNames ].\n\n    variableArray := self parseVariableString: variableString.\n    1 to: variableArray size do:\n\t[ :i | variableArray at: i put: (variableArray at: i) asSymbol ].\n\n    \"If instance or indexed variables change, update \n     instance variables and instance spec of the class and all its subclasses \"\n\n    (needToRecompileClasses := variableArray ~= aClass allInstVarNames\n\t| (aClass environment ~~ aNamespace)) \n\n\t| (aClass isVariable ~~ variableBoolean)\n\t| (aClass isWords ~~ wordBoolean )\n\t| (aClass isPointers ~~ pointerBoolean)\n\t    ifTrue: [\n\t        aClass instanceCount > 0 ifTrue: [ Smalltalk compact ].\n\t\taClass\n\t\t    updateInstanceVars: variableArray \n\t\t    variable: variableBoolean\n\t\t    words: wordBoolean\n\t\t    pointers: pointerBoolean\n\t    ].\n\n   needToRecompileMetaclasses := aClass environment ~~ aNamespace.\n\t\t\n   classVarDict := (self parseToDict: stringOfClassVarNames).\n\n   aClass classPool isNil \n       ifTrue: [ aClass setClassVariables: classVarDict ]\n       ifFalse: [\n\t    classVarDict keysDo: [ :key |\n\t\t (aClass classPool includesKey: key)\n\t\t     ifFalse: [ aClass addClassVarName: key ]\n\t    ]. \n\n\t    aClass classPool keys do: [ :aKey |\n\t\t (classVarDict includesKey: aKey)\n\t\t     ifFalse: [\n\t\t\t aClass removeClassVarName: aKey.\n\t\t\t needToRecompileMetaclasses := true\n\t\t     ]\n\t    ]\n\t].\n\n    sharedPoolNames := self parsePools: stringOfPoolNames in: aNamespace.\n    aClass sharedPoolDictionaries isNil \n\tifTrue: [ aClass setSharedPools: sharedPoolNames ]\n\tifFalse: [\n\t    sharedPoolNames do: [ :dict |\n\t\t(aClass sharedPoolDictionaries includes: dict)\n\t\t    ifFalse: [ aClass addSharedPool: dict ]\n\t    ].\n\n\t    aClass sharedPoolDictionaries copy do: [ :dict |\n\t\t(sharedPoolNames includes: dict)\n\t\t    ifFalse: [\n\t\t\taClass removeSharedPool: dict.\n\t\t\tneedToRecompileMetaclasses := true\n\t\t    ]\n\t    ]\n\t].\n\n    (aClass superclass ~~ superclass) ifTrue: [\n\t \"Fix references between classes...\"\n\t aClass superclass removeSubclass: aClass.\n\t superclass addSubclass: aClass.\n\t aClass superclass: superclass.\n\t needToRecompileClasses := true.\n\n\t \"...and between metaclasses...\"\n\t self superclass removeSubclass: self.\n\t superclass class addSubclass: self.\n\t self superclass: superclass class.\n\t needToRecompileMetaclasses := true.\n    ].\n\n    aClass category: categoryName.\n\n    \"Please note that I need to recompile the classes in this sequence;\n    otherwise, the same error is propagated to each selector which is compiled\n    after an error is detected even though there are no further compilation \n    errors. Apparently, there is a bug in the primitive compileString.  This\n    can be cleaned up later\"\n\t \n    (needToRecompileClasses | needToRecompileMetaclasses)\n\tifTrue: [\n\t    Transcript nextPutAll: 'Recompiling classes...'; nl.\n\t    aClass compileAll.\n\t    needToRecompileMetaclasses\n\t\tifTrue: [ aClass class compileAll ].\n\n\t    aClass compileAllSubclasses.\n\t    needToRecompileMetaclasses\n\t\tifTrue: [ aClass class compileAllSubclasses ]\n       ].\n\n    Behavior flushCache.\n    ^aClass",
                  "literals": [],
                  "methodName": "name:environment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "parseVariableString:": {
                  "src": "parseVariableString: aString\n    | stream tokens |\n    stream := TokenStream on: aString.\n    tokens := stream contents.\n    \"Smalltalk verboseExecTracing: true.\"\n    tokens do: [ :token | self validateIdentifier: token ].\n    \"Smalltalk verboseExecTracing: false.\"\n    ^tokens",
                  "literals": [],
                  "methodName": "parseVariableString:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "classVarNames": {
                  "src": "classVarNames\n    \"Answer the names of the variables in the class pool dictionary\"\n\n    ^self instanceClass classVarNames",
                  "literals": [],
                  "methodName": "classVarNames",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "initMetaclass:": {
                  "src": "initMetaclass: superclass\n    instanceVariables := superclass allInstVarNames.\n    instanceSpec := superclass instanceSpec",
                  "literals": [],
                  "methodName": "initMetaclass:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "parseToDict:": {
                  "src": "parseToDict: aString\n    | tokenArray dict |\n    tokenArray := self parseVariableString: aString.\n    dict := Dictionary new.\n    tokenArray do:\n    \t[ :element | dict at: element asSymbol put: nil ].\n    ^dict",
                  "literals": [],
                  "methodName": "parseToDict:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "removeSharedPool:": {
                  "src": "removeSharedPool: aDictionary\n    \"Remove the given dictionary to the list of the class' pool dictionaries\"\n\n    ^self instanceClass removeSharedPool: aDictionary",
                  "literals": [],
                  "methodName": "removeSharedPool:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "classPool": {
                  "src": "classPool\n    \"Answer the class pool dictionary\"\n\n    ^self instanceClass classPool",
                  "literals": [],
                  "methodName": "classPool",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "sharedPools": {
                  "src": "sharedPools\n    \"Return the names of the shared pools defined by the class\"\n\n    ^self instanceClass sharedPools",
                  "literals": [],
                  "methodName": "sharedPools",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "soleInstance": {
                  "src": "soleInstance\n    \"Answer the only instance of the metaclass - present for compatibility\"\n    ^instanceClass",
                  "literals": [],
                  "methodName": "soleInstance",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "instanceClass": {
                  "src": "instanceClass\n    \"Answer the only instance of the metaclass\"\n    ^instanceClass",
                  "literals": [],
                  "methodName": "instanceClass",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "subclassOf:": {
                  "src": "subclassOf: superMeta\n    \"Answer a new metaclass representing a subclass of superMeta\"\n\n    | newMeta |\n    newMeta := self new.\n    newMeta superclass: superMeta.\n    superMeta addSubclass: newMeta.\n    newMeta initMetaclass: superMeta.\n    ^newMeta",
                  "literals": [],
                  "methodName": "subclassOf:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "allClassVarNames": {
                  "src": "allClassVarNames\n    \"Answer the names of the variables in the receiver's class pool dictionary\n     and in each of the superclasses' class pool dictionaries\"\n\n    ^self instanceClass allClassVarNames",
                  "literals": [],
                  "methodName": "allClassVarNames",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "environment": {
                  "src": "environment\n    \"Answer the namespace in which the receiver is implemented\"\n    ^self asClass environment",
                  "literals": [],
                  "methodName": "environment",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream\n    \"Print a represention of the receiver on aStream\"\n    instanceClass printOn: aStream.\n    aStream nextPutAll: ' class'",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "newMeta:environment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:": {
                  "src": "newMeta: className\n    environment: aNamespace\n    subclassOf: superclass\n    instanceVariableNames: stringOfInstVarNames\n    variable: variableBoolean\n    words: wordBoolean\n    pointers: pointerBoolean\n    classVariableNames: stringOfClassVarNames\n    poolDictionaries: stringOfPoolNames\n    category: categoryName\n\n    \"Private - create a full featured class and install it\"\n\n    | aClass variableString variableArray sharedPoolNames poolName poolDict |\n\n    sharedPoolNames := self parsePools: stringOfPoolNames in: aNamespace.\n    aClass := self new.\n    instanceClass := aClass.\n    aNamespace at: className put: aClass.\n    aClass superclass: superclass.\n    aClass setName: className.\n    superclass notNil\n\tifTrue: [\n\t    \"Inherit instance variables from parent\"\n\t    variableString := superclass instanceVariableString.\n\t    superclass addSubclass: aClass\n\t]\n\tifFalse: [ variableString := '' ].\n\n    variableString := variableString , stringOfInstVarNames.\n    variableArray := self parseVariableString: variableString.\n    1 to: variableArray size do:\n\t[ :i | variableArray at: i put: (variableArray at: i) asSymbol ].\n\n    Behavior flushCache.\n    ^aClass\n\tsetEnvironment: aNamespace;\n\tsetInstanceVariables: variableArray;\n\tsetInstanceSpec: variableBoolean\n\t    words: wordBoolean\n\t    pointers: pointerBoolean\n\t    instVars: variableArray size;\n\tsetClassVariables: (self parseToDict: stringOfClassVarNames);\n\tsetSharedPools: sharedPoolNames;\n\tcategory: categoryName;\n\tyourself",
                  "literals": [],
                  "methodName": "newMeta:environment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "fileOutOn:": {
                  "src": "fileOutOn: aFileStream\n    \"File out complete class description:  class definition, class and\n     instance methods\"\n\n    instanceClass fileOutOn: aFileStream",
                  "literals": [],
                  "methodName": "fileOutOn:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "name": {
                  "src": "name\n    \"Answer the class name - it has none, actually\"\n    ^nil",
                  "literals": [],
                  "methodName": "name",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "addSharedPool:": {
                  "src": "addSharedPool: aDictionary\n    \"Add the given shared pool to the list of the class' pool dictionaries\"\n\n    ^self instanceClass addSharedPool: aDictionary",
                  "literals": [],
                  "methodName": "addSharedPool:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "removeClassVarName:": {
                  "src": "removeClassVarName: aString\n    \"Removes the class variable from the class, error if not present, or\n     still in use.\"\n\n    ^self instanceClass removeClassVarName: aString",
                  "literals": [],
                  "methodName": "removeClassVarName:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "comment": {
                  "src": "comment\n    \"Answer the class comment\"\n    ^self asClass comment",
                  "literals": [],
                  "methodName": "comment",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "asClass": {
                  "src": "asClass\n    ^instanceClass",
                  "literals": [],
                  "methodName": "asClass",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "category": {
                  "src": "category\n    \"Answer the class category\"\n    ^self asClass category",
                  "literals": [],
                  "methodName": "category",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "isMetaclass": {
                  "src": "isMetaclass\n    ^true",
                  "literals": [],
                  "methodName": "isMetaclass",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "addClassVarName:": {
                  "src": "addClassVarName: aString\n    \"Add a class variable with the given name to the class pool dictionary\"\n    \n    ^self instanceClass addClassVarName: aString",
                  "literals": [],
                  "methodName": "addClassVarName:",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                },
                "primaryInstance": {
                  "src": "primaryInstance\n    \"Answer the only instance of the metaclass - present for compatibility\"\n    ^instanceClass",
                  "literals": [],
                  "methodName": "primaryInstance",
                  "className": "Metaclass",
                  "category": "filing",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            }
          ]
        }
      ]
    },
    {
      "className": "BlockClosure",
      "instance_methods": {
        "argumentCount": {
          "src": "argumentCount\n    \"Answer the number of arguments passed to the receiver\"\n    ^block numArgs",
          "literals": [],
          "methodName": "argumentCount",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "numArgs:numTemps:bytecodes:depth:literals:": {
          "src": "numArgs: args numTemps: temps bytecodes: bytecodes depth: depth literals: literalArray\n    \"Answer a BlockClosure for a new CompiledBlock that is created using\n     the passed parameters.  To make it work, you must put the BlockClosure\n     into a CompiledMethod's literals.\"\n    ^self block: (CompiledBlock\n\tnumArgs: args numTemps: temps bytecodes: bytecodes depth: depth literals: literalArray)",
          "literals": [],
          "methodName": "numArgs:numTemps:bytecodes:depth:literals:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "initialIP": {
          "src": "initialIP\n    \"Answer the initial instruction pointer into the receiver.\"\n    ^1",
          "literals": [],
          "methodName": "initialIP",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "stackDepth": {
          "src": "stackDepth\n    \"Answer the number of stack slots needed for the receiver\"\n    ^block stackDepth",
          "literals": [],
          "methodName": "stackDepth",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "whileFalse:": {
          "src": "whileFalse: aBlock\n    \"Evaluate the receiver. If it returns false, evaluate aBlock and re-\n     start\"\n\n    \"When the receiver is a block expression, whileFalse: is optimized\n     by the compiler\"\n    [ self value ] whileFalse: [ aBlock value ].\n    ^nil",
          "literals": [],
          "methodName": "whileFalse:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "newProcess": {
          "src": "newProcess\n    \"Create a new process executing the receiver in suspended state.\n     The priority is the same as for the calling process. The receiver\n     must not contain returns\"\n    | closure |\n    closure := [ self value.  Processor terminateActive ].\n    ^Process\n\ton: (closure asContext: nil)\n\tat: Processor activePriority",
          "literals": [],
          "methodName": "newProcess",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "newProcessWith:": {
          "src": "newProcessWith: anArray\n    \"Create a new process executing the receiver with the passed\n     arguments, and leave it in suspended state. The priority is\n     the same as for the calling process. The receiver must not\n     contain returns\"\n    | closure |\n    closure := [ self valueWithArguments: anArray.\n    \t      Processor terminateActive ].\n    ^Process\n\ton: (closure asContext: nil)\n\tat: Processor activePriority",
          "literals": [],
          "methodName": "newProcessWith:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "repeat": {
          "src": "repeat\n    \"Evaluate the receiver 'forever' (actually until a return is executed\n    or the process is terminated).\"\n\n    \"When the receiver is a block expression, repeat is optimized\n     by the compiler\"\n    [ self value ] repeat",
          "literals": [],
          "methodName": "repeat",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "forkAt:": {
          "src": "forkAt: priority\n    \"Create a new process executing the receiver with given priority\n     and start it\"\n    ^(self newProcess priority: priority) resume; yourself",
          "literals": [],
          "methodName": "forkAt:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "outerContext:": {
          "src": "outerContext: containingContext\n    \"Set the method/block context which is the immediate outer of\n     the receiver\"\n    outerContext := containingContext",
          "literals": [],
          "methodName": "outerContext:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "block": {
          "src": "block\n    \"Answer the CompiledBlock which contains the receiver's bytecodes\"\n    ^block",
          "literals": [],
          "methodName": "block",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "receiver:": {
          "src": "receiver: anObject\n    \"Set the object that is used as `self' when executing the receiver\"\n    receiver := anObject",
          "literals": [],
          "methodName": "receiver:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "shallowCopy": {
          "src": "shallowCopy\n    ^self\t\t\t\"We only have one instance\"",
          "literals": [],
          "methodName": "shallowCopy",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "valueWithUnwind": {
          "src": "valueWithUnwind\n    \"Evaluate the receiver. Any errors caused by the block will cause a\n     backtrace, but execution will continue in the method that sent\n     #valueWithUnwind, after that call. Example:\n\t [ 1 / 0 ] valueWithUnwind.\n\t 'unwind works!' printNl.\n\n     Important: this method is public, but it is intended to be used in\n     very special cases (as a rule of thumb, use it only when the\n     corresponding C code uses the _gst_prepare_execution_environment and\n     _gst_finish_execution_environment functions). You should usually\n     rely on #ensure: and #on:do:.\"\n\n    thisContext mark.\n    ^[ self value ] ensure: [ ContextPart removeLastUnwindPoint ]",
          "literals": [],
          "methodName": "valueWithUnwind",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "whileTrue:": {
          "src": "whileTrue: aBlock\n    \"Evaluate the receiver. If it returns true, evaluate aBlock and re-\n     start\"\n\n    \"When the receiver is a block expression, whileTrue: is optimized\n     by the compiler\"\n    [ self value ] whileTrue: [ aBlock value ].\n    ^nil",
          "literals": [],
          "methodName": "whileTrue:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "hasMethodReturn": {
          "src": "hasMethodReturn\n    \"Answer whether the block contains a method return\"\n    ^self method\n\thasBytecode: 124\n\tbetween: self initialIP\n\tand: self finalIP",
          "literals": [],
          "methodName": "hasMethodReturn",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "method": {
          "src": "method\n    \"Answer the CompiledMethod in which the receiver lies\"\n    ^block method",
          "literals": [],
          "methodName": "method",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "receiver": {
          "src": "receiver\n    \"Answer the object that is used as `self' when executing the receiver\n     (if nil, it might mean that the receiver is not valid though...)\"\n    ^receiver",
          "literals": [],
          "methodName": "receiver",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "whileTrue": {
          "src": "whileTrue\n    \"Evaluate the receiver until it returns false\"\n\n    \"When the receiver is a block expression, whileTrue is optimized\n     by the compiler\"\n    ^[ self value ] whileTrue",
          "literals": [],
          "methodName": "whileTrue",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "isImmediate": {
          "src": "isImmediate\n    \"Answer whether, if x is an instance of the receiver, x copy == x\"\n    ^true",
          "literals": [],
          "methodName": "isImmediate",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "asContext:": {
          "src": "asContext: parent\n    \"Answer a context which will evaluate the receiver without effects on\n     the given context's stack (the return value won't be pushed), as\n     soon as it becomes the VM's thisContext.\n     parent can be nil - in which case reaching the end of the block will\n     probably crash Smalltalk.\n     Note that the block has no home, so it cannot contain returns.\"\n    | top block |\n    block := BlockContext fromClosure: self parent: parent.\n    parent isNil ifFalse: [\n\ttop := (parent sp == 0)\n\t    ifTrue: [ parent receiver ]\n\t    ifFalse: [ parent at: parent sp ].\n\n\tparent sp: parent sp - 1.\n    ].\n    ^block",
          "literals": [],
          "methodName": "asContext:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "ensure:": {
          "src": "ensure: aBlock\n    \"Evaluate the receiver; when any exception is signaled exit returning the\n     result of evaluating aBlock; if no exception is raised, return the result\n     of evaluating aBlock when the receiver has ended\"\n\n    | result |\n    result := self valueAndResumeOnUnwind.\n    aBlock value.\n    ^result",
          "literals": [],
          "methodName": "ensure:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "valueWithoutPreemption": {
          "src": "valueWithoutPreemption\n    \"Evaluate the receiver without ever having it pre-empted by\n     another process.  This selector name is deprecated; use\n     #forkWithoutPreemption instead.\"\n    ^self forkWithoutPreemption",
          "literals": [],
          "methodName": "valueWithoutPreemption",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "block:": {
          "src": "block: aCompiledBlock\n    \"Set the CompiledBlock which contains the receiver's bytecodes\"\n    block := aCompiledBlock",
          "literals": [],
          "methodName": "block:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "deepCopy": {
          "src": "deepCopy\n    ^self\t\t\t\"it's about as deep as we need to get\"",
          "literals": [],
          "methodName": "deepCopy",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "numArgs": {
          "src": "numArgs\n    \"Answer the number of arguments passed to the receiver\"\n    ^block numArgs",
          "literals": [],
          "methodName": "numArgs",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "numTemps": {
          "src": "numTemps\n    \"Answer the number of temporary variables used by the receiver\"\n    ^block numTemps",
          "literals": [],
          "methodName": "numTemps",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "fork": {
          "src": "fork\n    \"Create a new process executing the receiver and start it\"\n    ^self newProcess resume; yourself",
          "literals": [],
          "methodName": "fork",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "forkWithoutPreemption": {
          "src": "forkWithoutPreemption\n    \"Evaluate the receiver in a process that cannot be preempted.\n     If the receiver expect a parameter, pass the current process\n     (can be useful for queuing interrupts from within the\n     uninterruptible process).\"\n\n    | closure args process result |\n    closure := [ self valueWithArguments: args.\n    \t      Processor terminateActive ].\n\n    args := self numArgs = 0 ifTrue: [ #() ]\n\tifFalse: [ { Processor activeProcess } ].\n\n    process := Process\n\ton: (closure asContext: nil)\n\tat: Processor unpreemptedPriority.\n\n    ^process resume; yourself",
          "literals": [],
          "methodName": "forkWithoutPreemption",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "finalIP": {
          "src": "finalIP\n    \"Answer the last instruction that can be executed by the receiver\"\n    ^self block size",
          "literals": [],
          "methodName": "finalIP",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "ifCurtailed:": {
          "src": "ifCurtailed: aBlock\n    \"Evaluate the receiver; if its execution triggers an unwind which truncates\n     the execution of the block (`curtails' the block), evaluate aBlock.  The\n     three cases which can curtail the execution of the receiver are: a non-local\n     return in the receiver, a non-local return in a block evaluated by the\n     receiver which returns past the receiver itself, and an exception raised\n     and not resumed during the execution of the receiver.\"\n\n    | curtailed |\n    ^[ | result |\n\tcurtailed := true.\n\tresult := self value.\n\tcurtailed := false.\n\tresult\n    ] ensure: [\n        curtailed ifTrue: [ aBlock value ].\n    ]",
          "literals": [],
          "methodName": "ifCurtailed:",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "whileFalse": {
          "src": "whileFalse\n    \"Evaluate the receiver until it returns true\"\n\n    \"When the receiver is a block expression, whileFalse is optimized\n     by the compiler\"\n    ^[ self value ] whileFalse",
          "literals": [],
          "methodName": "whileFalse",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        },
        "outerContext": {
          "src": "outerContext\n    \"Answer the method/block context which is the immediate outer of\n     the receiver\"\n    ^outerContext",
          "literals": [],
          "methodName": "outerContext",
          "className": "BlockClosure",
          "category": "accessing",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "Boolean",
      "instance_methods": {
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Store on aStream some Smalltalk code which compiles to the receiver\"\n\n    self printOn: aStream\t\t\"representation is the same\"",
          "literals": [],
          "methodName": "storeOn:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "isImmediate": {
          "src": "isImmediate\n    \"Answer whether, if x is an instance of the receiver, x copy == x\"\n    ^true",
          "literals": [],
          "methodName": "isImmediate",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "&": {
          "src": "& aBoolean\n    self subclassResponsibility",
          "literals": [],
          "methodName": "&",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "ifFalse:": {
          "src": "ifFalse: falseBlock\n    self subclassResponsibility",
          "literals": [],
          "methodName": "ifFalse:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "xor:": {
          "src": "xor: aBoolean\n    self subclassResponsibility",
          "literals": [],
          "methodName": "xor:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "isIdentity": {
          "src": "isIdentity\n    \"Answer whether x = y implies x == y for instances of the receiver\"\n    ^true",
          "literals": [],
          "methodName": "isIdentity",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "ifTrue:ifFalse:": {
          "src": "ifTrue: trueBlock ifFalse: falseBlock\n    self subclassResponsibility",
          "literals": [],
          "methodName": "ifTrue:ifFalse:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "and:": {
          "src": "and: aBlock\n    self subclassResponsibility",
          "literals": [],
          "methodName": "and:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "deepCopy": {
          "src": "deepCopy\n    ^self\t\t\t\"it's about as deep as we need to get\"",
          "literals": [],
          "methodName": "deepCopy",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "not": {
          "src": "not\n    self subclassResponsibility",
          "literals": [],
          "methodName": "not",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "asCBooleanValue": {
          "src": "asCBooleanValue\n    self subclassResponsibility",
          "literals": [],
          "methodName": "asCBooleanValue",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "ifFalse:ifTrue:": {
          "src": "ifFalse: falseBlock ifTrue: trueBlock\n    self subclassResponsibility",
          "literals": [],
          "methodName": "ifFalse:ifTrue:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "or:": {
          "src": "or: aBlock\n    self subclassResponsibility",
          "literals": [],
          "methodName": "or:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "|": {
          "src": "| aBoolean\n    self subclassResponsibility",
          "literals": [],
          "methodName": "|",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "shallowCopy": {
          "src": "shallowCopy\n    ^self\t\t\t\"We only have one instance\"",
          "literals": [],
          "methodName": "shallowCopy",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "ifTrue:": {
          "src": "ifTrue: trueBlock\n    self subclassResponsibility",
          "literals": [],
          "methodName": "ifTrue:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        },
        "eqv:": {
          "src": "eqv: aBoolean\n    self subclassResponsibility",
          "literals": [],
          "methodName": "eqv:",
          "className": "Boolean",
          "category": "basic",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "False",
          "instance_methods": {
            "&": {
              "src": "& aBoolean\n    \"We are false -- anded with anything, we always answer false\"\n    ^false",
              "literals": [],
              "methodName": "&",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "ifFalse:": {
              "src": "ifFalse: falseBlock\n    \"We are false -- evaluate the falseBlock\"\n    ^falseBlock value",
              "literals": [],
              "methodName": "ifFalse:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "xor:": {
              "src": "xor: aBoolean\n    \"Answer whether the receiver and aBoolean represent different\n    boolean values\"\n    ^aBoolean",
              "literals": [],
              "methodName": "xor:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "ifTrue:ifFalse:": {
              "src": "ifTrue: trueBlock ifFalse: falseBlock\n    \"We are false -- evaluate the falseBlock\"\n    ^falseBlock value",
              "literals": [],
              "methodName": "ifTrue:ifFalse:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "and:": {
              "src": "and: aBlock\n    \"We are false -- anded with anything, we always answer false\"\n    ^false",
              "literals": [],
              "methodName": "and:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "not": {
              "src": "not\n    \"We are false -- answer true\"\n    ^true",
              "literals": [],
              "methodName": "not",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "asCBooleanValue": {
              "src": "asCBooleanValue\n    ^0",
              "literals": [],
              "methodName": "asCBooleanValue",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "ifFalse:ifTrue:": {
              "src": "ifFalse: falseBlock ifTrue: trueBlock\n    \"We are false -- evaluate the falseBlock\"\n    ^falseBlock value",
              "literals": [],
              "methodName": "ifFalse:ifTrue:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    aStream nextPutAll: 'false'",
              "literals": [],
              "methodName": "printOn:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "or:": {
              "src": "or: aBlock\n    \"We are false -- ored with anything, we always answer the other operand,\n    so evaluate aBlock\"\n    ^aBlock value",
              "literals": [],
              "methodName": "or:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "|": {
              "src": "| aBoolean\n    \"We are false -- ored with anything, we always answer the other operand\"\n    ^aBoolean",
              "literals": [],
              "methodName": "|",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "ifTrue:": {
              "src": "ifTrue: trueBlock\n    \"We are false -- answer nil\"\n    ^nil",
              "literals": [],
              "methodName": "ifTrue:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            },
            "eqv:": {
              "src": "eqv: aBoolean\n    \"Answer whether the receiver and aBoolean represent the\n    same boolean value\"\n    ^aBoolean not",
              "literals": [],
              "methodName": "eqv:",
              "className": "False",
              "category": "printing",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "True",
          "instance_methods": {
            "&": {
              "src": "& aBoolean\n    \"We are true -- anded with anything, we always answer the other operand\"\n    ^aBoolean",
              "literals": [],
              "methodName": "&",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "ifFalse:": {
              "src": "ifFalse: falseBlock\n    \"We are true -- answer nil\"\n    ^nil",
              "literals": [],
              "methodName": "ifFalse:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "xor:": {
              "src": "xor: aBoolean\n    \"Answer whether the receiver and aBoolean represent different\n    boolean values\"\n    ^aBoolean not",
              "literals": [],
              "methodName": "xor:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "ifTrue:ifFalse:": {
              "src": "ifTrue: trueBlock ifFalse: falseBlock\n    \"We are true -- evaluate trueBlock\"\n    ^trueBlock value",
              "literals": [],
              "methodName": "ifTrue:ifFalse:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "and:": {
              "src": "and: aBlock\n    \"We are true -- anded with anything, we always answer the other operand,\n    so evaluate aBlock\"\n    ^aBlock value",
              "literals": [],
              "methodName": "and:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "not": {
              "src": "not\n    \"We are true -- answer false\"\n    ^false",
              "literals": [],
              "methodName": "not",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "asCBooleanValue": {
              "src": "asCBooleanValue\n    ^1",
              "literals": [],
              "methodName": "asCBooleanValue",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "ifFalse:ifTrue:": {
              "src": "ifFalse: falseBlock ifTrue: trueBlock\n    \"We are true -- evaluate trueBlock\"\n    ^trueBlock value",
              "literals": [],
              "methodName": "ifFalse:ifTrue:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    aStream nextPutAll: 'true'",
              "literals": [],
              "methodName": "printOn:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "or:": {
              "src": "or: aBlock\n    \"We are true -- ored with anything, we always answer true\"\n    ^true",
              "literals": [],
              "methodName": "or:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "|": {
              "src": "| aBoolean\n    \"We are true -- ored with anything, we always answer true\"\n    ^true",
              "literals": [],
              "methodName": "|",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "ifTrue:": {
              "src": "ifTrue: trueBlock\n    \"We are true -- evaluate trueBlock\"\n    ^trueBlock value",
              "literals": [],
              "methodName": "ifTrue:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            },
            "eqv:": {
              "src": "eqv: aBoolean\n    \"Answer whether the receiver and aBoolean represent the\n    same boolean value\"\n    ^aBoolean",
              "literals": [],
              "methodName": "eqv:",
              "className": "True",
              "category": "printing",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        }
      ]
    },
    {
      "className": "Browser",
      "instance_methods": {
        "printSubclasses:using:": {
          "src": "printSubclasses: level using: aBlock\n    \"I print my name, and then all my subclasses, each indented according\n     to its position in the hierarchy. I pass aBlock a class name and a level\"\n    | mySubclasses |\n    aBlock value: self name value: level.\n\n    mySubclasses := self subclasses asSortedCollection: [ :a :b |\n\t(a isMetaclass | b isMetaclass) or: [ a name <= b name ]\n    ].\n    mySubclasses do: [ :subclass |\n\tsubclass isMetaclass\n\t    ifFalse: [ subclass printSubclasses: level + 1\n\t    \t    \t\tusing: aBlock ]\n    ]",
          "literals": [],
          "methodName": "printSubclasses:using:",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "printHierarchy": {
          "src": "printHierarchy\n    \"Print my entire subclass hierarchy on the terminal.\"\n    self printSubclasses: 0 using: [ :name :level |\n\tstdout\n\t    next: level * self hierarchyIndent put: Character space;\n\t    nextPutAll: name;\n\t    nl\n    ]",
          "literals": [],
          "methodName": "printHierarchy",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "oldShowMethods:for:": {
          "src": "oldShowMethods: class for: methodType\n    \"Send to Emacs code that browses methods of the given type for class\n    (methodType is either `class' or `instance')\"\n    | methods |\n    methods := class getMethods.    \n    self withGcOff:\n\t[ self startEmacsMessage.\n\t  stdout nextPutAll: '(smalltalk-browse \"';\n\t      nextPutAll: methodType;\n\t      nextPutAll: ' methods\"'; nl;\n\t      nextPutAll: '''test-func'; nl;\n\t      nextPutAll: 't'; nl;\n\t      nextPutAll: '''('; nl.\n\t  methods associationsDo:\n\t      [ :sel | sel value methodSourceFile notNil ifTrue:\n\t\t\t   [ stdout nextPutAll: '(\"'; \n\t\t\t\t print: sel key;\n    \t    \t    \t    \t nextPutAll: '\" . (\"'; \n\t\t\t\t nextPutAll: sel value methodSourceFile;\n\t\t\t\t nextPutAll: '\" . ';\n\t\t\t\t nextPutAll: sel value methodSourcePos printString;\n\t\t\t\t nextPutAll: ')'.\n\t\t\t     stdout nextPutAll: ')'; nl ] ].\n    \t  stdout nextPutAll: '))'; nl.    \n    \t  self finishEmacsMessage ]",
          "literals": [],
          "methodName": "oldShowMethods:for:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "withGcOff:": {
          "src": "withGcOff: aBlock\n    \"Evaluate aBlock while the `GC flipping...' message is off\"\n    | oldFlag |\n    oldFlag := ObjectMemory gcMessage: false.\n    aBlock value.\n    ObjectMemory gcMessage: oldFlag",
          "literals": [],
          "methodName": "withGcOff:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "selectorsForEmacs": {
          "src": "selectorsForEmacs\n    \"Tell Emacs the names of ALL the defined selectors\"\n    | md |\n    self emacsListFunction: 'smalltalk-set-all-methods' on:\n\t[ Smalltalk associationsDo:\n\t      [ :assoc | (assoc value isKindOf: Behavior)\n\t\t\t     ifTrue: \n\t\t\t\t [ (md := assoc value methodDictionary)\n\t\t\t\t       isNil ifFalse:\n\t\t\t\t\t   [ md keysDo:\n\t\t\t\t\t\t \" also spit out class methods\"\n\t\t\t\t\t\t [ :key | stdout nextPut: $\";\n\t\t\t\t\t\t\t      print: key;\n\t\t\t\t\t\t\t      nextPut: $\"; nl \n\t\t\t\t\t\t\t      ]\n\t\t\t\t\t\t ]\n\t\t\t\t       ]\n\t\t\t     ]\n\t      ]",
          "literals": [],
          "methodName": "selectorsForEmacs",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "hierarchyIndent": {
          "src": "hierarchyIndent\n    \"Answer the indent to be used by #printHierarchy - 4 by default\"\n    ^4",
          "literals": [],
          "methodName": "hierarchyIndent",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "getAllMethods": {
          "src": "getAllMethods\n    \"Answer the receiver's complete method dictionary - including\n     inherited and not overridden methods. Each value in the dictionary\n     is an Association, whose key is the class which defines the\n     method, and whose value is the actual CompiledMethod\"\n\n    ^self getIndirectMethods\n\taddAll: self getDirectMethods;\n\tyourself",
          "literals": [],
          "methodName": "getAllMethods",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "showIndirectMethods:inBuffer:": {
          "src": "showIndirectMethods: class inBuffer: bufferName\n    \"Send to Emacs code that browses the methods inherited (and not\n    overridden) by the given class, in a buffer with the given name\"\n    | methods |\n    \"Experimental version\"\n    methods := class getIndirectMethods.\n    self browseMethods: methods forClass: class inBuffer: bufferName.",
          "literals": [],
          "methodName": "showIndirectMethods:inBuffer:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "showMethods:for:": {
          "src": "showMethods: class for: methodType \n    \"Send to Emacs code that browses methods of the given type for class\n    (methodType is either `class' or `instance')\"\n    | methods |\n    \"Experimental version\"\n    methods := class newGetMethods.    \n    self emacsFunction: 'smalltalk-browse' on: \n\t[ stdout nextPut: $\";\n\t      nextPutAll: methodType;\n\t      nextPutAll: ' methods\"'; nl;\n\t      nextPutAll: '''test-func'; nl;\n\t      nextPutAll: 't'; nl;\n\t      nextPutAll: '''('; nl.\n\t  methods associationsDo:\n\t      [ :sel | sel value value methodSourceFile notNil \n\t\t\t   ifTrue: \n\t\t\t       [ stdout nextPutAll: '(\"'; \n\t\t\t\t     print: sel key; tab; tab;\n\t\t\t\t     print: sel value key;\n\t\t\t\t     nextPutAll: '\" . (\"'; \n\t\t\t\t     nextPutAll: sel value value methodSourceFile;\nnextPutAll: '\" . ';\n\t\t\t\t     nextPutAll: sel value value methodSourcePos printString;\n\t\t\t\t     nextPut: $).\n\t\t\t\t stdout nextPut: $); nl ] \n\t\t\t   ifFalse:\n\t\t\t       [ stdout nextPutAll: '(\"'; \n\t\t\t\t     print: sel key; tab; tab;\n\t\t\t\t     print: sel value key;\n\t\t\t\t     nextPutAll: '\" . (\"'; \n\t\t\t\t     nextPutAll: sel value value methodSourceString;\n\t\t\t\t     nextPut: $).\n\t\t\t\t stdout nextPut: $); nl ]\n\t\t\t   ].\n    \t  stdout nextPut: $) ]",
          "literals": [],
          "methodName": "showMethods:for:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "showDirectMethods:inBuffer:": {
          "src": "showDirectMethods: class inBuffer: bufferName\n    \"Send to Emacs code that browses methods defined in the given class,\n    in a buffer with the given name\"\n\n    | methods |\n    \"Experimental version\"\n    methods := class getDirectMethods.\n    self browseMethods: methods forClass: class inBuffer: bufferName .",
          "literals": [],
          "methodName": "showDirectMethods:inBuffer:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "testMethods:for:": {
          "src": "testMethods: aClass for: methodType\n    \"Send to Emacs code that browses methods of the given type for class\n    (methodType is either `class' or `instance')\"\n    | classes methods md |\n    classes := (aClass allSuperclasses). \n    classes addFirst: aClass.\n    self withGcOff:\n\t[ self startEmacsMessage.\n\t  stdout nextPutAll: '(smalltalk-fast-browse \"';\n\t      nextPutAll: methodType;\n\t      nextPutAll: ' methods\"'; nl;\n\t      nextPutAll: '''test-func'; nl;\n\t      nextPutAll: '''('; nl.\n\t  classes do:\n\t      [ :cl | md := cl methodDictionary.\n\t\t      md notNil ifTrue:\n\t\t\t  [ md associationsDo: \n\t\t\t\t[ :meth | stdout nextPutAll: '(\"';\n\t\t\t\t\t      nextPutAll: meth key;\n\t\t\t\t\t      nextPutAll: '\" . (\"'; \n\t\t\t\t\t      nextPutAll: meth value methodSourceFile;\n\t\t\t\t\t      nextPutAll: '\" . ';\n\t\t\t\t\t      nextPutAll: meth value methodSourcePos printString;\n\t\t\t\t\t      nextPutAll: '))';\n\t\t\t\t\t      nl ]\n\t\t\t\t]\n\t\t\t  ].\n\t  stdout nextPutAll: '))'.\n\t  self finishEmacsMessage ].",
          "literals": [],
          "methodName": "testMethods:for:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "showAllMethods:inBuffer:": {
          "src": "showAllMethods: class inBuffer: bufferName\n    \"Send to Emacs code that browses ALL the methods understood by\n    instances of the given class, in a buffer with the given name\"\n\n    | methods |\n    \"Experimental version\"\n    methods := class getAllMethods.\n    self browseMethods: methods forClass: class inBuffer: bufferName .",
          "literals": [],
          "methodName": "showAllMethods:inBuffer:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "emacsListFunction:on:": {
          "src": "emacsListFunction: funcName on: aBlock\n    \"Send to Emacs something like (funcName '(<aBlock is evaluated here>))\"\n    self emacsFunction: funcName on:\n\t[ stdout nextPutAll: '''('; nl.\n\t  aBlock value.\n\t  stdout nextPut: $) ]",
          "literals": [],
          "methodName": "emacsListFunction:on:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "startEmacsMessage": {
          "src": "startEmacsMessage\n    \"Start a message to be processed by emacs as Lisp\"\n    stdout nextPut: (Character value: 2)",
          "literals": [],
          "methodName": "startEmacsMessage",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "oldloadClassNames": {
          "src": "oldloadClassNames\n    \"Tell Emacs the class names\"\n    self withGcOff:\n\t[ self startEmacsMessage. \n    \t  stdout nextPutAll: '(smalltalk-set-class-names ''('; nl. \n\t  Object withAllSubclasses do: \n\t      [ :class | class name == nil\n\t\t\t     ifFalse: [ stdout nextPutAll: class name; nl. ]\n\t\t\t     ].\n\t  stdout nextPutAll: '))'.\n    \t  self finishEmacsMessage ]",
          "literals": [],
          "methodName": "oldloadClassNames",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "loadClassNames": {
          "src": "loadClassNames\n    \"Tell Emacs the class names (new version)\"\n    BrowserClassesValid \n\tifTrue: [ self emacsListFunction: 'identity' on: \n\t\t      [ stdout nextPutAll: 'nil'; nl ]\n\t\t]\n\tifFalse: \n\t    [ self emacsListFunction: 'smalltalk-set-class-names' on:\n\t\t  [ Smalltalk associationsDo:\n\t\t\t[ :assoc | (assoc value isKindOf: Behavior)\n\t\t\t\t       ifTrue: [ stdout nextPutAll: assoc key;\n\t\t\t\t\t\t     nl ]\n\t\t\t] \n\t\t  ].\n\t      BrowserClassesValid := true.\n\t    ]",
          "literals": [],
          "methodName": "loadClassNames",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "browseHierarchy": {
          "src": "browseHierarchy\n    \"Tell Emacs tp browse the Smalltalk class hierarchy\"\n    self emacsListFunction: 'smalltalk-hier-browser' on: \n\t[ Object printHierarchyEmacs ]",
          "literals": [],
          "methodName": "browseHierarchy",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "methodDictionary": {
          "src": "methodDictionary\n    \"Answer the receiver's method dictionary\"\n    ^methodDictionary",
          "literals": [],
          "methodName": "methodDictionary",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "emacsFunction:on:": {
          "src": "emacsFunction: funcName on: aBlock\n    \"Send to Emacs something like (funcName <aBlock is evaluated here>)\"\n    self withGcOff:\n\t[ self startEmacsMessage.\n\t  stdout nextPut: $(;\n\t      nextPutAll: funcName; nl.\n\t  aBlock value.\n\t  stdout nextPut: $); nl.    \n    \t  self finishEmacsMessage ]",
          "literals": [],
          "methodName": "emacsFunction:on:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "getAllSelectors:inBuffer:": {
          "src": "getAllSelectors: selector inBuffer: bufferName\n    \"Send to Emacs code that browses the implementors of the given\n    selectors in a buffer with the given name\"\n    | methods |\n    methods := self getMethodsFor: selector.\n    self browseMethods: methods forClass: Object inBuffer: bufferName.",
          "literals": [],
          "methodName": "getAllSelectors:inBuffer:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "getMethodsFor:": {
          "src": "getMethodsFor: aSelector\n    \"Get a dictionary with all the definitions of the given selector\n     along the hierarchy. Each key in the dictionary is a class which\n     defines the method, and each value in the dictionary is an\n     Association, whose key is the class again, and whose value is\n     the actual CompiledMethod\"\n    | methods dict subclass |\n    methods := Dictionary new.\n\n    Class allSubclassesDo: [ :meta |\n\tsubclass := meta instanceClass.\n\tdict := subclass methodDictionary.\n\tdict notNil ifTrue: [\n\t    dict at: aSelector ifPresent: [ :method |\n\t\tmethods at: subclass put: (subclass -> method)\n\t    ]\n\t]\n    ].\n    ^methods",
          "literals": [],
          "methodName": "getMethodsFor:",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "printHierarchyEmacs": {
          "src": "printHierarchyEmacs\n    \"Print my entire subclass hierarchy on the terminal, in a\n     format suitable for Emacs parsing.\"\n    self printSubclasses: 0 using: [ :name :level |\n\tstdout\n\t    nextPutAll: '(\"';\n\t    nextPutAll: name;\n\t    nextPutAll: '\" . ';\n\t    print: level;\n\t    nextPutAll: ')'; nl.\n    ]",
          "literals": [],
          "methodName": "printHierarchyEmacs",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "browseMethods:forClass:inBuffer:": {
          "src": "browseMethods: methods forClass: class inBuffer: bufferName\n    \"Send to Emacs code that browses the methods in the `methods'\n    Dictionary, showing them as part of the `class' class in a\n    buffer with the given name\"\n    self emacsFunction: 'smalltalk-method-browse' on:\n\t[ stdout nextPut: $\";\n\t      nextPutAll: bufferName;\n\t      nextPutAll: '\" ''('; nl.\n\t  methods associationsDo:\n\t      [ :sel | sel value value methodSourceFile notNil \n\t\t\t   ifTrue:\n\t\t\t       [ stdout nextPutAll: '(\"'; \n\t\t\t\t     print: sel key; \n\t\t\t\t     nextPutAll: '\" . (\"'; \n\t\t\t\t     nextPutAll: sel value value methodSourceFile;\n\t\t\t\t     nextPutAll: '\" . ';\n\t\t\t\t     nextPutAll: sel value value methodSourcePos printString;\n\t\t\t\t     nextPutAll: '))'; nl ] \n\t\t\t   ifFalse:\n\t\t\t       [ stdout nextPutAll: '(\"'; \n\t\t\t\t     print: sel key; \n\t\t\t\t     nextPutAll: '\" . (\"'; \n\t\t\t\t     print: class;\n\t\t\t\t     nextPutAll: '\" \"';\n\t\t\t\t     nextPutAll: sel value value methodCategory;\n\t\t\t\t     nextPut: $\"; nl;\n\t\t\t\t     nextPut: $\";\n\t\t\t\t     nextPutAll: sel value value methodSourceString;\n\t\t\t\t     nextPutAll: '\")'.\n\t\t\t\t stdout nextPut: $); nl ]\n\t\t\t   ].\n\t  stdout nextPutAll: ')'; nl ]",
          "literals": [],
          "methodName": "browseMethods:forClass:inBuffer:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "newGetMethods": {
          "src": "newGetMethods\n    \"Answer the receiver's complete method dictionary - including\n     inherited and not overridden methods. Each value in the dictionary\n     is an Association, whose key is the class which defines the\n     method, and whose value is the actual CompiledMethod\"\n    | classes methods md b |\n    methods := Dictionary new.\n    b := [ :md :class | md associationsDo:\n\t\t  [ :assoc | methods \n\t\t\t\t add: (Association key: assoc key \n\t\t\t\t\t\t   value: (Association \n\t\t\t\t\t\t\t       key: class \n\t\t\t\t\t\t\t       value: assoc value)) ] ].\n    self allSuperclasses reverseDo:\n\t[ :superclass | md := superclass methodDictionary.\n\t\t\tmd notNil ifTrue: \n\t\t\t    [ b value: md value: superclass ] ].\n    methodDictionary notNil ifTrue: \n\t[ b value: methodDictionary value: self ].\n    ^methods",
          "literals": [],
          "methodName": "newGetMethods",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "finishEmacsMessage": {
          "src": "finishEmacsMessage\n    \"Finish a message to be processed by emacs - does nothing for now\"",
          "literals": [],
          "methodName": "finishEmacsMessage",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "initialize": {
          "src": "initialize\n    \"Initialize the Emacs browsing system\"\n    BrowserClassesValid := false",
          "literals": [],
          "methodName": "initialize",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        },
        "getIndirectMethods": {
          "src": "getIndirectMethods\n    \"Answer a dictionary of the receiver's inherited and not\n     overridden methods. Each value in the dictionary\n     is an Association, whose key is the class which defines the\n     method, and whose value is the actual CompiledMethod\"\n\n    | methods md |\n    methods := Dictionary new.\n    self allSuperclasses reverseDo: [ :superclass |\n\tmd := superclass methodDictionary.\n\tmd notNil ifTrue: [\n\t    methodDictionary associationsDo: [ :assoc |\n\t\tmethods at: assoc key put: (superclass -> assoc value)\n\t    ]\n\t]\n    ].\n    ^methods",
          "literals": [],
          "methodName": "getIndirectMethods",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "getDirectMethods": {
          "src": "getDirectMethods\n    \"Answer the receiver's method dictionary; each value in the\n     dictionary is not a CompiledMethod, but an Association, whose\n     key is the class which defines the method (always the receiver),\n     and whose value is the actual CompiledMethod\"\n    | methods |\n    methods := Dictionary new.\n    methodDictionary isNil ifTrue: [ ^methods ].\n    methodDictionary associationsDo: [ :assoc |\n\tmethods at: assoc key put: (self -> assoc value)\n    ].\n    ^methods",
          "literals": [],
          "methodName": "getDirectMethods",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "getMethods": {
          "src": "getMethods\n    \"Answer the receiver's complete method dictionary - including\n     inherited and not overridden methods\"\n    | classes methods md |\n    methods := Dictionary new.\n    self allSuperclasses reverseDo:\n\t[ :superclass | md := superclass methodDictionary.\n\t\t\tmd notNil ifTrue: \n\t\t\t    [ md associationsDo:\n\t\t\t\t  [ :assoc | methods add: assoc ] ] ].\n    methodDictionary notNil ifTrue: \n\t[ methodDictionary associationsDo:\n\t      [ :assoc | methods add: assoc ] ].\n    ^methods",
          "literals": [],
          "methodName": "getMethods",
          "className": "Behavior",
          "category": "<unknown>",
          "byteCodes": []
        },
        "oldShowInstanceMethods:": {
          "src": "oldShowInstanceMethods: class\n    \"Send to Emacs code that browses instance methods for class\"\n    | methods |\n    methods := self getMethods: class.\n    self withGcOff:\n\t[ self startEmacsMessage.\n\t  stdout nextPutAll: '(smalltalk-browse \"instance methods\"'; nl;\n\t      nextPutAll: '''test-func'; nl;\n\t      nextPutAll: 't'; nl;\n\t      nextPutAll: '''('; nl.\n\t  class allSelectors do:\n\t      [ :sel | stdout nextPutAll: '(\"';\n    \t    \t\t   print: sel;\n    \t    \t\t   nextPutAll: '\" . \"';\n\t\t\t   print: sel;\n\t\t       \t   nextPutAll: '\")'; nl ].\n    \t  stdout nextPutAll: ')'; nl.    \n    \t  self finishEmacsMessage ]",
          "literals": [],
          "methodName": "oldShowInstanceMethods:",
          "className": "Browser",
          "category": "<unknown>",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "CType",
      "instance_methods": {
        "new": {
          "src": "new\n    \"Allocate a new CObject with the type (class) identified by the receiver.\n    It is the caller's responsibility to free the memory allocated for it.\"\n    ^CObject alloc: self sizeof type: self",
          "literals": [],
          "methodName": "new",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "alignof": {
          "src": "alignof\n    \"Answer the alignment of the receiver's instances\"\n    ^elementType alignof",
          "literals": [],
          "methodName": "alignof",
          "className": "CArrayCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Store Smalltalk code that compiles to the receiver\"\n    aStream\n\tprint: cObjectType;\n\tnextPutAll: 'Type'",
          "literals": [],
          "methodName": "storeOn:",
          "className": "CScalarCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "arrayType:": {
          "src": "arrayType: size\n    \"Answer a CArrayCType which represents an array with the given size\n     of CObjects whose type is in turn represented by the receiver\"\n    ^CArrayCType elementType: self numberOfElements: size",
          "literals": [],
          "methodName": "arrayType:",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "cObjectType": {
          "src": "cObjectType\n    \"Answer the CObject subclass whose instance is created when new is sent\n     to the receiver\"\n    ^cObjectType",
          "literals": [],
          "methodName": "cObjectType",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "sizeof": {
          "src": "sizeof\n    \"Answer the size of the receiver's instances\"\n    ^elementType sizeof * numElements",
          "literals": [],
          "methodName": "sizeof",
          "className": "CArrayCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "new:": {
          "src": "new: size\n    \"Allocate space for `size' objects like those that the receiver points\n    to, and with the type (class) identified by the receiver.\n    It is the caller's responsibility to free the memory allocated for it.\"\n    ^CObject alloc: elementType sizeof * size type: self",
          "literals": [],
          "methodName": "new:",
          "className": "CPtrCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "elementType:numberOfElements:": {
          "src": "elementType: aCType numberOfElements: anInteger\n    \"Answer a new instance of CPtrCType that maps an array whose elements\n    are of the given CType, and whose size is exactly anInteger elements\n    (of course, anInteger only matters for allocation, not for access, since\n    no out-of-bounds protection is provided for C objects).\"\n    ^self new\n        init: CArray;\n        elementType: aCType;\n        numberOfElements: anInteger",
          "literals": [],
          "methodName": "elementType:numberOfElements:",
          "className": "CArrayCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "numberOfElements:": {
          "src": "numberOfElements: anInteger\n    \"Initialize the receiver's instance variables\"\n    numElements := anInteger.",
          "literals": [],
          "methodName": "numberOfElements:",
          "className": "CArrayCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "init:": {
          "src": "init: aCObjectClass\n    \"Initialize the receiver's instance variablers\"\n    cObjectType := aCObjectClass",
          "literals": [],
          "methodName": "init:",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "ptrType": {
          "src": "ptrType\n    \"Answer a CPtrCType which represents a pointer to CObjects whose\n     type is in turn represented by the receiver\"\n    ^CPtrCType elementType: self",
          "literals": [],
          "methodName": "ptrType",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "numberOfElements": {
          "src": "numberOfElements\n    \"Answer the number of elements in the receiver's instances\"\n    ^numElements",
          "literals": [],
          "methodName": "numberOfElements",
          "className": "CArrayCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "valueType": {
          "src": "valueType\n    \"valueType is used as a means to communicate to the interpreter the \n    underlying type of the data.  For scalars, it is supplied by the\n    CObject subclass.\"\n    ^cObjectType scalarIndex",
          "literals": [],
          "methodName": "valueType",
          "className": "CScalarCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "elementType:": {
          "src": "elementType: aCType\n    self shouldNotImplement",
          "literals": [],
          "methodName": "elementType:",
          "className": "CArrayCType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "cObjectType:": {
          "src": "cObjectType: aCObjectSubclass\n    \"Create a new CType for the given subclass of CObject\"\n    ^self basicNew init: aCObjectSubclass",
          "literals": [],
          "methodName": "cObjectType:",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "address:": {
          "src": "address: cObjOrInt\n    \"Create a new CObject with the type (class) identified by the receiver,\n    pointing to the given address (identified by an Integer or CObject).\"\n    ^(cObjectType basicNew: 1)\n\ttype: self;\n\taddress: (cObjOrInt isInteger\n\t    ifTrue: [ cObjOrInt ]\n\t    ifFalse: [ cObjOrInt address ]);\n\tyourself",
          "literals": [],
          "methodName": "address:",
          "className": "CType",
          "category": "<unknown>",
          "byteCodes": []
        },
        "elementType": {
          "src": "elementType\n    \"Answer the type of the elements in the receiver's instances\"\n    ^elementType",
          "literals": [],
          "methodName": "elementType",
          "className": "CPtrCType",
          "category": "<unknown>",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "Collection",
      "instance_methods": {
        "collect:": {
          "src": "collect: aBlock\n    \"Answer a new instance of a Collection containing all the results\n     of evaluating aBlock passing each of the receiver's elements\"\n\n    | newCollection |\n    newCollection := self copyEmptyForCollect.\n    self do: [ :element | newCollection add: (aBlock value: element) ].\n    ^newCollection",
          "literals": [],
          "methodName": "collect:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asArray": {
          "src": "asArray\n    \"Answer an Array containing all the elements in the receiver\"\n\n    ^(Array new: self size)\n\treplaceFrom: 1 to: self size with: self;\n\tyourself",
          "literals": [],
          "methodName": "asArray",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "includes:": {
          "src": "includes: anObject\n    \"Answer whether we include anObject\"\n    self do: [ :element | anObject = element ifTrue: [ ^true ] ].\n    ^false",
          "literals": [],
          "methodName": "includes:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "rehash": {
          "src": "rehash\n    \"Private - Do nothing, present for consistency in protocol\"",
          "literals": [],
          "methodName": "rehash",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "with:": {
          "src": "with: anObject\n    \"Answer a collection whose only element is anObject\"\n    ^self new add: anObject; yourself",
          "literals": [],
          "methodName": "with:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "do:": {
          "src": "do: aBlock\n    \"Enumerate each object of the receiver, passing them to aBlock\"\n    self subclassResponsibility",
          "literals": [],
          "methodName": "do:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "with:with:with:with:": {
          "src": "with: firstObject with: secondObject with: thirdObject with: fourthObject\n    \"Answer a collection whose only elements are the parameters in the order\n     they were passed\"\n    ^self new add: firstObject; add: secondObject; add: thirdObject;\n    \tadd: fourthObject; yourself",
          "literals": [],
          "methodName": "with:with:with:with:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "add:": {
          "src": "add: newObject\n    \"Add newObject to the receiver, answer it\"\n    self subclassResponsibility",
          "literals": [],
          "methodName": "add:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "occurrencesOf:": {
          "src": "occurrencesOf: anObject\n    \"Answer how many occurrences of anObject we include\"\n    | count |\n    count := 0.\n    self do: [ :element | anObject == element ifTrue: [ count := count + 1 ] ].\n    ^count",
          "literals": [],
          "methodName": "occurrencesOf:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asSortedCollection": {
          "src": "asSortedCollection\n    \"Answer a SortedCollection containing all the elements in the receiver\n     with the default sort block - [ :a :b | a <= b ]\"\n\n    ^(SortedCollection new: self size + 10)\n\taddAll: self;\n\tyourself",
          "literals": [],
          "methodName": "asSortedCollection",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "copyEmpty": {
          "src": "copyEmpty\n    \"Private - Answer an empty copy of the receiver\"\n    ^self copyEmpty: self basicSize",
          "literals": [],
          "methodName": "copyEmpty",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "anyOne": {
          "src": "anyOne\n    \"Answer an unspecified element of the collection. Example usage:\n\t^coll inject: coll anyOne into: [ :max :each |\n\t    max max: each ]\n\n     to be used when you don't have a valid lowest-possible-value\n     (which happens in common cases too, such as with arbitrary numbers\"\n\n    self do: [ :each | ^each ]",
          "literals": [],
          "methodName": "anyOne",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "reject:": {
          "src": "reject: aBlock\n    \"Answer a new instance of a Collection containing all the elements\n     in the receiver which, when passed to aBlock, don't answer true\"\n\n    | newCollection |\n    newCollection := self copyEmpty.\n    self do: [ :element | (aBlock value: element)\n    \t    \t    \t    ifFalse: [ newCollection add: element ]\n\t     ].\n    ^newCollection",
          "literals": [],
          "methodName": "reject:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "remove:": {
          "src": "remove: oldObject\n    \"Remove oldObject from the receiver. If absent, fail, else\n     answer oldObject.\"\n\n    ^self remove: oldObject\n\t ifAbsent: [ SystemExceptions NotFound signalOn: oldObject what: 'object' ].",
          "literals": [],
          "methodName": "remove:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "copyEmptyForCollect": {
          "src": "copyEmptyForCollect\n    \"Answer an empty copy of the receiver, with the class answered by the\n     collect: method.\"\n    ^self copyEmpty",
          "literals": [],
          "methodName": "copyEmptyForCollect",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asOrderedCollection": {
          "src": "asOrderedCollection\n    \"Answer an OrderedCollection containing all the elements in the receiver\"\n\n    ^(OrderedCollection new: self size * 2)\n\taddAll: self;\n\tyourself",
          "literals": [],
          "methodName": "asOrderedCollection",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "do:separatedBy:": {
          "src": "do: aBlock separatedBy: separatorBlock\n    \"Enumerate each object of the receiver, passing them to aBlock.\n     Between every two invocations of aBlock, invoke separatorBlock\"\n    | first |\n    first := true.\n    self do: [ :each |\n\taBlock value: each.\n\tfirst\n\t    ifTrue: [ first := false ]\n\t    ifFalse: [ separatorBlock value ]\n    ]",
          "literals": [],
          "methodName": "do:separatedBy:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "with:with:with:with:with:": {
          "src": "with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject\n    \"Answer a collection whose only elements are the parameters in the order\n     they were passed\"\n    ^self new add: firstObject; add: secondObject; add: thirdObject;\n    \tadd: fourthObject; add: fifthObject; yourself",
          "literals": [],
          "methodName": "with:with:with:with:with:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "detect:": {
          "src": "detect: aBlock\n    \"Search the receiver for an element for which aBlock returns true.\n     If some does, answer it. If none does, fail\"\n    ^self detect: aBlock\n\t ifNone: [ SystemExceptions NotFound signal: 'object not found' ].",
          "literals": [],
          "methodName": "detect:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "copyWithout:": {
          "src": "copyWithout: oldElement\n    \"Answer a copy of the receiver to which all occurrences of oldElement are\n     removed\"\n\n    ^self reject: [ :element | element = oldElement ].",
          "literals": [],
          "methodName": "copyWithout:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "removeAll:": {
          "src": "removeAll: aCollection\n    \"Remove each object in aCollection, answer aCollection, fail if some\n     of them is absent. Warning: this could leave the collection in a\n     semi-updated state.\"\n\n    aCollection do: [ :element | self remove: element ].\n    ^aCollection",
          "literals": [],
          "methodName": "removeAll:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asByteArray": {
          "src": "asByteArray\n    \"Answer a ByteArray containing all the elements in the receiver\"\n\n    ^(ByteArray new: self size)\n\treplaceFrom: 1 to: self size with: self;\n\tyourself",
          "literals": [],
          "methodName": "asByteArray",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "beConsistent": {
          "src": "beConsistent\n    \"This method is private, but it is quite interesting so it is\n     documented. It ensures that a collection is in a consistent\n     state before attempting to iterate on it; its presence reduces\n     the number of overrides needed by collections who try to\n     amortize their execution times.  The default implementation\n     does nothing, so it is optimized out by the virtual machine\n     and so it loses very little on the performance side.  Note\n     that descendants of Collection have to call it explicitly\n     since #do: is abstract in Collection.\"",
          "literals": [],
          "methodName": "beConsistent",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "size": {
          "src": "size\n    \"Answer how many objects we include\"\n    | count |\n    count := 0.\n    self do: [ :element | count := count + 1].\n    ^count",
          "literals": [],
          "methodName": "size",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    aStream nextPutAll: self classNameString.\n    aStream nextPutAll: ' ('.\n    self do:\n    \t[ :element | element printOn: aStream.\n\t\t     aStream space ].\n    aStream nextPut: $)",
          "literals": [],
          "methodName": "printOn:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "inspect": {
          "src": "inspect\n    \"Print all the instance variables and objects in the receiver on the\n     Transcript\"\n\n    | class instVars i |\n    self beConsistent.\n    class := self class.\n    instVars := class allInstVarNames.\n    Transcript nextPutAll: 'An instance of '.\n    class printNl.\n    1 to: instVars size do:\n\t[ :i | Transcript nextPutAll: '  ';\n\t    nextPutAll: (instVars at: i);\n\t    nextPutAll: ': '.\n\t    (self instVarAt: i)  printNl ].\n\n    Transcript nextPutAll: '  contents: ['; nl.\n\n    self do: [ :obj |\n\tTranscript \n\t    nextPutAll: '    ';\n\t    print: obj;\n\t    nl\n    ].\n    Transcript nextPutAll: '  ]'; nl",
          "literals": [],
          "methodName": "inspect",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "copyEmpty:": {
          "src": "copyEmpty: newSize\n    \"Private - Answer an empty copy of the receiver\"\n    ^self species new: newSize",
          "literals": [],
          "methodName": "copyEmpty:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "notEmpty": {
          "src": "notEmpty\n    \"Answer whether we include at least one object\"\n    ^self size > 0",
          "literals": [],
          "methodName": "notEmpty",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Store Smalltalk code compiling to the receiver on aStream\"\n    | noElements |\n    aStream nextPut: $(.\n    aStream nextPutAll: self classNameString.\n    aStream nextPutAll: ' new'.\n    noElements := true.\n    self do:\n    \t[ :element | aStream nextPutAll: ' add: '.\n    \t    \t     element storeOn: aStream.\n\t\t     aStream nextPut: $;.\n\t\t     noElements := false ].\n    noElements ifFalse: [ aStream nextPutAll: ' yourself' ].\n    aStream nextPut: $)",
          "literals": [],
          "methodName": "storeOn:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "copyReplacing:withObject:": {
          "src": "copyReplacing: targetObject withObject: newObject\n    \"Copy replacing each object which is = to targetObject\n     with newObject\"\n\n    ^self collect: [:each |\n\teach = targetObject ifFalse: [each] ifTrue: [newObject]\n    ]",
          "literals": [],
          "methodName": "copyReplacing:withObject:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "remove:ifAbsent:": {
          "src": "remove: oldObject ifAbsent: anExceptionBlock\n    \"Remove oldObject from the receiver. If absent, evaluate anExceptionBlock\n     and answer the result, else answer oldObject.\"\n\n    self subclassResponsibility",
          "literals": [],
          "methodName": "remove:ifAbsent:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "capacity": {
          "src": "capacity\n    \"Answer how many elements the receiver can hold before having to grow.\"\n    ^self basicSize",
          "literals": [],
          "methodName": "capacity",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asSortedCollection:": {
          "src": "asSortedCollection: aBlock\n    \"Answer a SortedCollection whose elements are the elements of the receiver,\n     sorted according to the sort block aBlock\"\n\n    ^self asSortedCollection sortBlock: aBlock; yourself",
          "literals": [],
          "methodName": "asSortedCollection:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "inject:into:": {
          "src": "inject: thisValue into: binaryBlock\n    \"Pass to binaryBlock receiver thisValue and the first element of the\n     receiver; for each subsequent element, pass the result of the previous\n     evaluation and an element. Answer the result of the last invocation.\"\n\n    | result |\n    result := thisValue.\n    self do: [ :element |\n\tresult := binaryBlock value: result value: element\n    ].\n    ^result",
          "literals": [],
          "methodName": "inject:into:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "allSatisfy:": {
          "src": "allSatisfy: aBlock\n    \"Search the receiver for an element for which aBlock returns false.\n     Answer true if none does, false otherwise.\"\n    self do: [ :element | (aBlock value: element) ifFalse: [ ^false ] ].\n    ^true",
          "literals": [],
          "methodName": "allSatisfy:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "select:": {
          "src": "select: aBlock\n    \"Answer a new instance of a Collection containing all the elements\n     in the receiver which, when passed to aBlock, answer true\"\n\n    | newCollection |\n    newCollection := self copyEmpty.\n    self do: [ :element | (aBlock value: element)\n    \t    \t    \t    ifTrue: [ newCollection add: element ]\n\t     ].\n    ^newCollection",
          "literals": [],
          "methodName": "select:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "conform:": {
          "src": "conform: aBlock\n    \"Search the receiver for an element for which aBlock returns false.\n     Answer true if none does, false otherwise.\"\n    self do: [ :element | (aBlock value: element) ifFalse: [ ^false ] ].\n    ^true",
          "literals": [],
          "methodName": "conform:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asSet": {
          "src": "asSet\n    \"Answer a Set containing all the elements in the receiver with no\n     duplicates\"\n\n    ^(Set new: self size * 2)\n\taddAll: self;\n\tyourself",
          "literals": [],
          "methodName": "asSet",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "identityIncludes:": {
          "src": "identityIncludes: anObject\n    \"Answer whether we include the anObject object\"\n    self do: [ :element | anObject == element ifTrue: [ ^true ] ].\n    ^false",
          "literals": [],
          "methodName": "identityIncludes:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "isEmpty": {
          "src": "isEmpty\n    \"Answer whether we are (still) empty\"\n    ^self size == 0",
          "literals": [],
          "methodName": "isEmpty",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "removeAll:ifAbsent:": {
          "src": "removeAll: aCollection ifAbsent: aBlock\n    \"Remove each object in aCollection, answer aCollection; if some\n     element is absent, pass it to aBlock.\"\n\n    aCollection do: [ :element |\n\tself remove: element ifAbsent: [ aBlock value: element ]\n    ].\n    ^aCollection",
          "literals": [],
          "methodName": "removeAll:ifAbsent:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "copyWith:": {
          "src": "copyWith: newElement\n    \"Answer a copy of the receiver to which newElement is added\"\n\n    ^(self copyEmpty: self basicSize + 1)\n       addAll: self;\n       add: newElement;\n       yourself",
          "literals": [],
          "methodName": "copyWith:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "detect:ifNone:": {
          "src": "detect: aBlock ifNone: exceptionBlock\n    \"Search the receiver for an element for which aBlock returns true.\n     If some does, answer it. If none does, answer the result of evaluating\n     aBlock\"\n\n    self do: [ :element | (aBlock value: element) ifTrue: [ ^element ] ].\n    ^exceptionBlock value",
          "literals": [],
          "methodName": "detect:ifNone:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "with:with:with:": {
          "src": "with: firstObject with: secondObject with: thirdObject\n    \"Answer a collection whose only elements are the parameters in the order\n     they were passed\"\n    ^self new add: firstObject; add: secondObject; add: thirdObject; yourself",
          "literals": [],
          "methodName": "with:with:with:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "withAll:": {
          "src": "withAll: aCollection\n    \"Answer a collection whose elements are all those in aCollection\"\n    ^self new addAll: aCollection; yourself",
          "literals": [],
          "methodName": "withAll:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "contains:": {
          "src": "contains: aBlock\n    \"Search the receiver for an element for which aBlock returns true.\n     Answer true if some does, false otherwise.\"\n    self do: [ :element | (aBlock value: element) ifTrue: [ ^true ] ].\n    ^false",
          "literals": [],
          "methodName": "contains:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "asBag": {
          "src": "asBag\n    \"Answer a Bag containing all the elements in the receiver\"\n\n    ^(Bag new: self size)\n\taddAll: self;\n\tyourself",
          "literals": [],
          "methodName": "asBag",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "addAll:": {
          "src": "addAll: aCollection\n    \"Adds all the elements of 'aCollection' to the receiver, answer\n     aCollection\"\n    aCollection do: [ :element | self add: element ].\n    ^aCollection",
          "literals": [],
          "methodName": "addAll:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "with:with:": {
          "src": "with: firstObject with: secondObject\n    \"Answer a collection whose only elements are the parameters in the order\n     they were passed\"\n    ^self new add: firstObject; add: secondObject; yourself",
          "literals": [],
          "methodName": "with:with:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        },
        "anySatisfy:": {
          "src": "anySatisfy: aBlock\n    \"Search the receiver for an element for which aBlock returns true.\n     Answer true if some does, false otherwise.\"\n    self do: [ :element | (aBlock value: element) ifTrue: [ ^true ] ].\n    ^false",
          "literals": [],
          "methodName": "anySatisfy:",
          "className": "Collection",
          "category": "storing",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "Bag",
          "instance_methods": {
            "new": {
              "src": "new\n    \"Answer a new instance of the receiver\"\n    ^self basicNew initContents: 31",
              "literals": [],
              "methodName": "new",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "storeOn:": {
              "src": "storeOn: aStream\n    \"Put on aStream some Smalltalk code compiling to the receiver\"\n    | noElements |\n    aStream nextPut: $(;\n\tnextPutAll: self classNameString;\n\tnextPutAll: ' new'.\n    noElements := true.\n    contents keysAndValuesDo:\n      [ :key :count | aStream nextPutAll: ' add: ';\n\t\t     store: key;\n\t\t     nextPutAll: ' withOccurrences: ';\n\t\t     store: count;\n\t\t     nextPut: $;.\n\t\t noElements := false ].\n    noElements ifFalse: [ aStream nextPutAll: '; yourself' ].\n    aStream nextPut: $)",
              "literals": [],
              "methodName": "storeOn:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "add:withOccurrences:": {
              "src": "add: newObject withOccurrences: anInteger\n    \"If anInteger > 0, add anInteger occurrences of newObject to the\n     receiver. If anInteger < 0, remove them. Answer newObject.  Fail\n    if newObject is nil.\"\n\n    | newOccurrences |\n    newObject isNil ifTrue: [\n        SystemExceptions InvalidArgument signalOn: newObject reason:\n\t    'bag elements cannot be nil' ].\n\n    newOccurrences := contents at: newObject\n\t     put: (self occurrencesOf: newObject) + anInteger.\n\n    newOccurrences < 0 ifTrue: [ contents removeKey: newObject ].\n    ^newObject",
              "literals": [],
              "methodName": "add:withOccurrences:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "initContents:": {
              "src": "initContents: size\n    contents := self dictionaryClass new: size",
              "literals": [],
              "methodName": "initContents:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "new:": {
              "src": "new: size\n    \"Answer a new instance of the receiver, with space for size distinct\n     objects\"\n    ^self basicNew initContents: (7 max: size)",
              "literals": [],
              "methodName": "new:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "includes:": {
              "src": "includes: anObject\n    \"Answer whether we include anObject\"\n    ^contents includesKey: anObject",
              "literals": [],
              "methodName": "includes:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "sortedByCount": {
              "src": "sortedByCount\n    \"Answer a collection of counts with elements, sorted by decreasing count.\"\n\n    | counts |\n    counts := SortedCollection sortBlock: [:x :y | x >= y].\n    contents keysAndValuesDo: [ :key :count |\n        counts add: count -> key].\n    \n    ^counts asArray",
              "literals": [],
              "methodName": "sortedByCount",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "remove:ifAbsent:": {
              "src": "remove: oldObject ifAbsent: anExceptionBlock\n    \"Remove oldObject from the collection and return it. If can't be\n     found, answer instead the result of evaluationg anExceptionBlock\"\n\n    | count |\n    \"Since we're using a dictionary, we need decrement the value until\n     it's zero, in which case we can then remove the object from the\n     dictionary\"\n    count := self occurrencesOf: oldObject.\n    count = 0 ifTrue: [ ^anExceptionBlock value ].\n    count = 1 ifTrue: [ contents removeKey: oldObject ]\n    \t      ifFalse: [ contents at: oldObject\n\t      \t    \t    \t  put: count - 1 ].\n    ^oldObject",
              "literals": [],
              "methodName": "remove:ifAbsent:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "do:": {
              "src": "do: aBlock\n    \"Evaluate the block for all members in the collection.\"\n    \n    \"For Bags, we need to go through the contents dictionary, and\n     perform the block for as many occurrences of the objects as there\n     are.\"\n    contents keysAndValuesDo:\n\t[ :key :count | count timesRepeat: [ aBlock value: key ] ]",
              "literals": [],
              "methodName": "do:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "add:": {
              "src": "add: newObject\n    \"Add an occurrence of newObject to the receiver. Answer newObject.\n     Fail if newObject is nil.\"\n    self add: newObject withOccurrences: 1.\n    ^newObject",
              "literals": [],
              "methodName": "add:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "occurrencesOf:": {
              "src": "occurrencesOf: anObject\n    \"Answer the number of occurrences of anObject found in the receiver\"\n    ^contents at: anObject ifAbsent: [ 0 ]",
              "literals": [],
              "methodName": "occurrencesOf:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "size": {
              "src": "size\n    \"Answer the total number of objects found in the receiver\"\n    | count |\n    count := 0.\n    contents do: [ :element | count := count + element ].\n    ^count",
              "literals": [],
              "methodName": "size",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Put on aStream a representation of the receiver\"\n\n    aStream\n\tnextPutAll: self classNameString;\n\tnextPut: $(.\n\n    contents keysAndValuesDo: [ :key :count |\n\taStream \n\t     print: key;\n\t     nextPut: $:;\n\t     print: count;\n\t     space\n    ].\n    aStream nextPut: $)",
              "literals": [],
              "methodName": "printOn:",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "contents": {
              "src": "contents\n    ^contents",
              "literals": [],
              "methodName": "contents",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "dictionaryClass": {
              "src": "dictionaryClass\n    ^LookupTable",
              "literals": [],
              "methodName": "dictionaryClass",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "asSet": {
              "src": "asSet\n    \"Answer a set with the elements of the receiver\"\n\n    ^contents keys",
              "literals": [],
              "methodName": "asSet",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "=": {
              "src": "= aBag\n    \"Answer whether the receiver and aBag contain the same objects\"\n    self class == aBag class\n\tifFalse: [ ^false ].\n    ^contents = aBag contents",
              "literals": [],
              "methodName": "=",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            },
            "hash": {
              "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^contents hash",
              "literals": [],
              "methodName": "hash",
              "className": "Bag",
              "category": "private",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "MappedCollection",
          "instance_methods": {
            "new": {
              "src": "new\n    \"This method should not be used; instead, use #collection:map: to\n     create MappedCollection.\"\n    SystemExceptions WrongMessageSent signalOn: #new useInstead: #collection:map:",
              "literals": [],
              "methodName": "new",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "collect:": {
              "src": "collect: aBlock\n    \"Answer a MappedCollection with a copy of the receiver's map\n     and a domain obtained by passing each object through aBlock\"\n    | newDomain |\n    newDomain := domain collect: aBlock.\n    ^self species collection: newDomain map: map copy.",
              "literals": [],
              "methodName": "collect:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "at:": {
              "src": "at: key\n    \"Answer the object at the given key\"\n    ^domain at: (map at: key)",
              "literals": [],
              "methodName": "at:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "at:put:": {
              "src": "at: key put: value\n    \"Store value at the given key\"\n    ^domain at: (map at: key) put: value",
              "literals": [],
              "methodName": "at:put:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "do:": {
              "src": "do: aBlock\n    \"Evaluate aBlock for each object\"\n    map do: [ :value | aBlock value: (domain at: value) ]",
              "literals": [],
              "methodName": "do:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "collection:map:": {
              "src": "collection: aCollection map: aMap\n    \"Answer a new MappedCollection using the given domain (aCollection)\n     and map\"\n    ^self basicNew setCollection: aCollection andMap: aMap",
              "literals": [],
              "methodName": "collection:map:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "size": {
              "src": "size\n    \"Answer the receiver's size\"\n    ^domain size",
              "literals": [],
              "methodName": "size",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "add:": {
              "src": "add: anObject\n    self shouldNotImplement",
              "literals": [],
              "methodName": "add:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "contents": {
              "src": "contents\n    \"Answer a bag with the receiver's values\"\n    | aBag |\n    aBag := Bag new.\n    map do: [ :value | aBag add: (domain at: value) ].\n    ^aBag",
              "literals": [],
              "methodName": "contents",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "species": {
              "src": "species\n    ^self class",
              "literals": [],
              "methodName": "species",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "domain": {
              "src": "domain\n    \"Answer the domain\"\n    ^domain",
              "literals": [],
              "methodName": "domain",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "select:": {
              "src": "select: aBlock\n    \"Answer the objects in the domain for which aBlock returns true\"\n\n    | aStream |\n    aStream := WriteStream on: (domain species new: self size).\n    self do: [ :value | (aBlock value: value) ifFalse:\n    \t    \t[ aStream nextPut: value ] ].\n\n    ^aStream contents",
              "literals": [],
              "methodName": "select:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "setCollection:andMap:": {
              "src": "setCollection: aCollection andMap: aMap\n    domain := aCollection.\n    map := aMap",
              "literals": [],
              "methodName": "setCollection:andMap:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "map": {
              "src": "map\n    \"Answer the map\"\n    ^map",
              "literals": [],
              "methodName": "map",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            },
            "reject:": {
              "src": "reject: aBlock\n    \"Answer the objects in the domain for which aBlock returns false\"\n\n    | aStream map |\n    aStream := WriteStream on: (domain species new: self size).\n    self do: [ :value | (aBlock value: value) ifFalse:\n    \t    \t[ aStream nextPut: value ] ].\n\n    ^aStream contents",
              "literals": [],
              "methodName": "reject:",
              "className": "MappedCollection",
              "category": "private",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "SequenceableCollection",
          "instance_methods": {
            "replaceAll:with:": {
              "src": "replaceAll: anObject with: anotherObject\n    \"In the receiver, replace every occurrence of anObject with anotherObject.\"\n    1 to: self size do: [ :index |\n\t(self at: index) = anObject ifTrue: [\n\t    self at: index put: anotherObject.\n\t]\n    ].",
              "literals": [],
              "methodName": "replaceAll:with:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "copyReplaceFrom:to:with:": {
              "src": "copyReplaceFrom: start to: stop with: replacementCollection\n    \"Answer a new collection of the same class as the receiver that contains the\n    same elements as the receiver, in the same order, except for elements from\n    index `start' to index `stop'.\n    \n    If start < stop, these are replaced by the contents of the\n    replacementCollection.  Instead, If start = (stop + 1), like in\n    `copyReplaceFrom: 4 to: 3 with: anArray', then every element of the receiver\n    will be present in the answered copy; the operation will be an append if\n    stop is equal to the size of the receiver or, if it is not, an insert before\n    index `start'.\"\n\n    | newSize repSize result |\n    (stop - start < -1)\n\tifTrue: [ ^SystemExceptions ArgumentOutOfRange signalOn: stop mustBeBetween: start - 1 and: self size ].\n\n    repSize := replacementCollection size.\n    newSize := self size + repSize - (stop - start + 1).\n\n    result := self copyEmpty: newSize.\n    start > 1 ifTrue: [\n\tself from: 1 to: start - 1 do: [ :each | result add: each ]\n    ].\n    result addAll: replacementCollection.\n    stop < self size ifTrue: [\n\tself from: stop + 1 to: self size do: [ :each | result add: each ]\n    ].\n\n    ^result",
              "literals": [],
              "methodName": "copyReplaceFrom:to:with:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "copyFrom:": {
              "src": "copyFrom: start\n    \"Answer a new collection containing all the items in the receiver from the\n     start-th.\"\n    | sz |\n    start > (sz := self size) ifTrue: [^self species new].\n    ^self copyFrom: (start max: 1) to: sz",
              "literals": [],
              "methodName": "copyFrom:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "after:": {
              "src": "after: oldObject\n    \"Return the element after oldObject.  Error if oldObject not found or\n    if no following object is available\"\n\n    | i |\n    i := self indexOf: oldObject.\n    i = 0 ifTrue: [\n\t^SystemExceptions NotFound signalOn: oldObject what: 'object' ].\n    ^self at: i + 1",
              "literals": [],
              "methodName": "after:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "includes:": {
              "src": "includes: anObject\n    \"Answer whether we include anObject\"\n\n    \"Reimplemented to avoid an expensive full-block\"\n    1 to: self size do: [ :index |\n        anObject = (self at: index) ifTrue: [ ^true ]\n    ].\n    ^false",
              "literals": [],
              "methodName": "includes:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "growSize": {
              "src": "growSize\n    ^(self size bitShift: -1) bitOr: 1\t\t\"a randomly chosen factor\"",
              "literals": [],
              "methodName": "growSize",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOfSubCollection:": {
              "src": "indexOfSubCollection: aSubCollection\n    \"Answer the first index > anIndex at which starts a sequence of\n     items matching aSubCollection. Answer 0 if no such sequence is found.\"\n\n    ^self indexOfSubCollection: aSubCollection startingAt: 1\n    \tifAbsent: [ ^0 ]",
              "literals": [],
              "methodName": "indexOfSubCollection:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "doWithIndex:": {
              "src": "doWithIndex: aBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection,\n     passing the index of each element as the second parameter.  This method\n     is mantained for backwards compatibility and is not mandated by the\n     ANSI standard; use #keysAndValuesDo:\"\n\n    1 to: self size do: [ :i | aBlock value: (self at: i) value: i ].",
              "literals": [],
              "methodName": "doWithIndex:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "do:": {
              "src": "do: aBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection\"\n    \n    1 to: self size do: [ :i | aBlock value: (self at: i) ].",
              "literals": [],
              "methodName": "do:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "copyFrom:to:": {
              "src": "copyFrom: start to: stop\n    \"Answer a new collection containing all the items in the receiver from the\n     start-th and to the stop-th\"\n\n    | len coll |\n    stop < start ifTrue: [^self species new].\n    len := stop - start + 1.\n    coll := self species new: len + 10.\n    self from: start to: stop do: [ :each | coll add: each ].\n    ^coll",
              "literals": [],
              "methodName": "copyFrom:to:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "writeStream": {
              "src": "writeStream\n    \"Answer a WriteStream streaming on the receiver\"\n    ^WriteStream on: self",
              "literals": [],
              "methodName": "writeStream",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "with:collect:": {
              "src": "with: aSequenceableCollection collect: aBlock\n    \"Evaluate aBlock for each pair of elements took respectively from the re-\n     ceiver and from aSequenceableCollection; answer a collection of the same\n     kind of the receiver, made with the block's return values. Fail if the\n     receiver has not the same size as aSequenceableCollection.\"\n\n    | newCollection |\n    self size = aSequenceableCollection size\n    \tifFalse: [\n\t    ^SystemExceptions InvalidSize signalOn: aSequenceableCollection ].\n\n    newCollection := self copyEmptyForCollect.\n    1 to: self size do: [ :i |\n    \tnewCollection add:\n    \t    (aBlock value: (self at: i) value: (aSequenceableCollection at: i)).\n    ].\n    ^newCollection",
              "literals": [],
              "methodName": "with:collect:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "anyOne": {
              "src": "anyOne\n    \"Answer an unspecified element of the collection. Example usage:\n\t^coll inject: coll anyOne into: [ :max :each |\n\t    max max: each ]\n\n     to be used when you don't have a valid lowest-possible-value\n     (which happens in common cases too, such as with arbitrary numbers\"\n\n    ^self at: 1",
              "literals": [],
              "methodName": "anyOne",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "readStream": {
              "src": "readStream\n    \"Answer a ReadStream streaming on the receiver\"\n    ^ReadStream on: self",
              "literals": [],
              "methodName": "readStream",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "readWriteStream": {
              "src": "readWriteStream\n    \"Answer a ReadWriteStream which streams on the receiver\"\n    ^ReadWriteStream on: self",
              "literals": [],
              "methodName": "readWriteStream",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "last": {
              "src": "last\n    \"Answer the last item in the receiver\"\n    ^self at: self size",
              "literals": [],
              "methodName": "last",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOf:": {
              "src": "indexOf: anElement\n    \"Answer the index of the first occurrence of anElement in the receiver.\n     Answer 0 if no item is found\"\n    ^self indexOf: anElement startingAt: 1 ifAbsent: [ ^0 ]",
              "literals": [],
              "methodName": "indexOf:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "findLast:": {
              "src": "findLast: aBlock\n    \"Returns the index of the last element of the sequenceable collection\n    for which aBlock returns true, or 0 if none does\"\n\n    | i |\n    i := self size.\n    self reverseDo: [ :each |\n    \t(aBlock value: each) ifTrue: [ ^i ].\n    \ti := i - 1\n    ].\n    ^0",
              "literals": [],
              "methodName": "findLast:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "replaceFrom:to:with:": {
              "src": "replaceFrom: start to: stop with: replacementCollection\n    \"Replace the items from start to stop with replacementCollection's items\n     from 1 to stop-start+1 (in unexpected order if the collection is not\n     sequenceable).\"\n\n    | i delta |\n    i := start - 1.\n    delta := replacementCollection size - (stop - start + 1).\n    delta = 0 ifFalse: [ ^SystemExceptions InvalidSize signalOn: replacementCollection ].\n\n    replacementCollection\n\tdo: [ :each | self at: (i := i + 1) put: each ]",
              "literals": [],
              "methodName": "replaceFrom:to:with:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "do:separatedBy:": {
              "src": "do: aBlock separatedBy: sepBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection.\n    Between each element, evaluate sepBlock without parameters.\"\n    \n    self isEmpty ifTrue: [ ^self ].\n    aBlock value: (self at: 1).\n    2 to: self size do: [ :i | \n\tsepBlock value.\n\taBlock value: (self at: i)\n    ].",
              "literals": [],
              "methodName": "do:separatedBy:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "identityIndexOf:ifAbsent:": {
              "src": "identityIndexOf: anElement ifAbsent: exceptionBlock\n    \"Answer the index of the first occurrence of an object identical to\n     anElement in the receiver. Invoke exceptionBlock and answer its\n     result if no item is found\"\n    ^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock",
              "literals": [],
              "methodName": "identityIndexOf:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "at:ifAbsent:": {
              "src": "at: anIndex ifAbsent: aBlock\n    \"Answer the anIndex-th item of the collection, or evaluate aBlock\n     and answer the result if the index is out of range\"\n    (anIndex between: 1 and: self size) ifFalse: [ ^aBlock value ].\n    ^self at: anIndex",
              "literals": [],
              "methodName": "at:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            ",": {
              "src": ", aSequenceableCollection\n    \"Append aSequenceableCollection at the end of the receiver (using #add:),\n     and answer a new collection\"\n\n    ^(self copyEmpty: self size + aSequenceableCollection size)\n\taddAll: self;\n\taddAll: aSequenceableCollection;\n\tyourself",
              "literals": [],
              "methodName": ",",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "reverseDo:": {
              "src": "reverseDo: aBlock\n    \"Evaluate aBlock for all elements in the sequenceable collection, from the\n     last to the first.\"\n\n    self size to: 1 by: -1 do: [ :i | aBlock value: (self at: i) ].",
              "literals": [],
              "methodName": "reverseDo:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "keysAndValuesDo:": {
              "src": "keysAndValuesDo: aBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection,\n     passing the index of each element as the first parameter and the\n     element as the second.\"\n\n    1 to: self size do: [ :i | aBlock value: i value: (self at: i) ].",
              "literals": [],
              "methodName": "keysAndValuesDo:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "inspect": {
              "src": "inspect\n    \"Print all the instance variables and context of the receiver on the\n     Transcript\"\n\n    | class instVars i |\n    self beConsistent.\n    class := self class.\n    instVars := class allInstVarNames.\n    Transcript nextPutAll: 'An instance of '.\n    class printNl.\n    1 to: instVars size do:\n\t[ :i | Transcript nextPutAll: '  ';\n\t    nextPutAll: (instVars at: i);\n\t    nextPutAll: ': '.\n\t    (self instVarAt: i)  printNl ].\n\n    Transcript nextPutAll: '  contents: ['; nl.\n\n    self keysAndValuesDo: [ :i :obj |\n\tTranscript \n\t    nextPutAll: '    [';\n\t    print: i;\n\t    nextPutAll: ']: ';\n\t    print: obj;\n\t    nl\n    ].\n    Transcript nextPutAll: '  ]'; nl",
              "literals": [],
              "methodName": "inspect",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "countSubCollectionOccurrencesOf:": {
              "src": "countSubCollectionOccurrencesOf: aSubCollection\n    | colIndex subColIndex count |\n    colIndex := 1.\n    count := 0.\n    [ subColIndex := self indexOfSubCollection: aSubCollection\n    \t    \t    \t startingAt: colIndex.\n      subColIndex > 0 ] whileTrue:\n      \t[ count := count + 1.\n\t  colIndex := subColIndex + aSubCollection size ].\n    ^count",
              "literals": [],
              "methodName": "countSubCollectionOccurrencesOf:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "with:do:": {
              "src": "with: aSequenceableCollection do: aBlock\n    \"Evaluate aBlock for each pair of elements took respectively from the re-\n     ceiver and from aSequenceableCollection. Fail if the receiver has not\n     the same size as aSequenceableCollection.\"\n\n    self size = aSequenceableCollection size\n    \tifFalse: [\n\t    ^SystemExceptions InvalidSize signalOn: aSequenceableCollection ].\n\n    1 to: self size do: [ :i |\n    \taBlock value: (self at: i) value: (aSequenceableCollection at: i).\n    ]",
              "literals": [],
              "methodName": "with:do:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "matchSubCollection:startingAt:": {
              "src": "matchSubCollection: aSubCollection startingAt: anIndex\n    \"Private - Answer whether the items from index anIndex match those in\n     aSubCollection. The first item is ignored\"\n    | ourIndex |\n    ourIndex := anIndex.\n    2 to: aSubCollection size do: [ :index |\n\tourIndex := ourIndex + 1.\n\t(self at: ourIndex) = (aSubCollection at: index)\n\t    ifFalse: [ ^false ].\n    ].\n    ^true",
              "literals": [],
              "methodName": "matchSubCollection:startingAt:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "=": {
              "src": "= aCollection\n    \"Answer whether the receiver's items match those in aCollection\"\n\n    self class == aCollection class ifFalse: [^false].\n    self size = aCollection size ifFalse: [^false].\n\n    1 to: self size do: [ :i |\n\t(self at: i) = (aCollection at: i) ifFalse: [^false]\n    ].\n    ^true",
              "literals": [],
              "methodName": "=",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "hash": {
              "src": "hash\n    \"Answer an hash value for the receiver\"\n\n    \"Don't like this hash function; it can be made much better\"\n    | hash carry |\n    hash := self size.\n    self do: [ :element |\n\tcarry := (hash bitAnd: 16r20000000) > 0.\n\thash := hash bitAnd: 16r1FFFFFFF.\n\thash := hash bitShift: 1.\n\tcarry ifTrue: [ hash := hash bitOr: 1 ].\n\n\thash := hash bitXor: element hash\n    ].\n    ^hash",
              "literals": [],
              "methodName": "hash",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "identityIndexOf:": {
              "src": "identityIndexOf: anElement\n    \"Answer the index of the first occurrence of an object identical to\n     anElement in the receiver. Answer 0 if no item is found\"\n    ^self indexOf: anElement startingAt: 1 ifAbsent: [ ^0 ]",
              "literals": [],
              "methodName": "identityIndexOf:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "replaceFrom:to:with:startingAt:": {
              "src": "replaceFrom: start to: stop with: replacementCollection startingAt: repStart\n    \"Replace the items from start to stop with replacementCollection's items\n     from repStart to repStart+stop-start\"\n\n    \"speed this up by making it zero based, otherwise we have to subtract 1\n     from each use of index.  Note that stop - start is not computed on\n     every iteration.\"\n\n    replacementCollection isEmpty ifTrue: [ ^self ].\n\n    (stop < start) ifTrue: [\n\t^SystemExceptions ArgumentOutOfRange\n\t    signalOn: stop\n\t    mustBeBetween: start and: self size ].\n\n    0 to: stop - start do: [ :i |\n\tself at: (start + i)\n    \t     put: (replacementCollection at: (repStart + i))\n    ]",
              "literals": [],
              "methodName": "replaceFrom:to:with:startingAt:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "copyReplaceAll:with:": {
              "src": "copyReplaceAll: oldSubCollection with: newSubCollection\n    \"Answer a new collection in which all the sequences matching\n     oldSubCollection are replaced with newSubCollection\"\n\n    | numOld newCollection sizeDifference newSubSize oldSubSize\n      oldStart copySize index |\n    numOld := self countSubCollectionOccurrencesOf: oldSubCollection.\n    newSubSize := newSubCollection size.\n    oldSubSize := oldSubCollection size.\n    sizeDifference := newSubSize - oldSubSize.\n    newCollection := self copyEmpty: self size + (sizeDifference * numOld).\n    oldStart := 1.\n\n    [\n\tindex := self indexOfSubCollection: oldSubCollection startingAt: oldStart\n\t    ifAbsent: [\n\t\t\"Copy the remaining part of self onto the tail of the new collection.\"\n\t\tself from: oldStart to: self size do: [ :each |\n\t\t    newCollection add: each ].\n\t\t^newCollection\n\t    ].\n\n\tcopySize := index - oldStart.\n\tself from: oldStart to: oldStart + copySize - 1 do: [ :each |\n\t\t    newCollection add: each ].\n\n\tnewCollection addAll: newSubCollection.\n    \toldStart := oldStart + copySize + oldSubSize\n    ] repeat",
              "literals": [],
              "methodName": "copyReplaceAll:with:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "atAll:put:": {
              "src": "atAll: aCollection put: anObject\n    \"Put anObject at every index contained in aCollection\"\n    aCollection do: [ :index | self at: index put: anObject ]",
              "literals": [],
              "methodName": "atAll:put:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "from:to:keysAndValuesDo:": {
              "src": "from: startIndex to: stopIndex keysAndValuesDo: aBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection whose\n     indices are in the range index to stopIndex, passing the index of each\n     element as the first parameter and the element as the second.\"\n\n    startIndex to: stopIndex do: [ :i | aBlock value: i value: (self at: i) ].",
              "literals": [],
              "methodName": "from:to:keysAndValuesDo:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOfSubCollection:ifAbsent:": {
              "src": "indexOfSubCollection: aSubCollection ifAbsent: exceptionBlock\n    \"Answer the first index > anIndex at which starts a sequence of\n     items matching aSubCollection. Answer 0 if no such sequence is found.\"\n\n    ^self indexOfSubCollection: aSubCollection startingAt: 1\n    \tifAbsent: exceptionBlock",
              "literals": [],
              "methodName": "indexOfSubCollection:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "from:to:do:": {
              "src": "from: startIndex to: stopIndex do: aBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection whose\n     indices are in the range index to stopIndex\"\n\n    startIndex to: stopIndex do: [ :i | aBlock value: (self at: i) ].",
              "literals": [],
              "methodName": "from:to:do:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "before:": {
              "src": "before: oldObject\n    \"Return the element before oldObject.  Error if oldObject not found or\n    if no preceding object is available\"\n\n    | i |\n    i := self indexOf: oldObject.\n    i = 0 ifTrue: [\n\t^SystemExceptions NotFound signalOn: oldObject what: 'object' ].\n    ^self at: i - 1",
              "literals": [],
              "methodName": "before:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "findFirst:": {
              "src": "findFirst: aBlock\n    \"Returns the index of the first element of the sequenceable collection\n    for which aBlock returns true, or 0 if none\"\n\n    self doWithIndex: [ :each :i |\n    \t(aBlock value: each) ifTrue: [ ^i ].\n    ].\n    ^0",
              "literals": [],
              "methodName": "findFirst:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "atAllPut:": {
              "src": "atAllPut: anObject\n    \"Put anObject at every index in the receiver\"\n    1 to: self size do: [ :i | self at: i put: anObject ]",
              "literals": [],
              "methodName": "atAllPut:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOfSubCollection:startingAt:ifAbsent:": {
              "src": "indexOfSubCollection: aSubCollection startingAt: anIndex ifAbsent: exceptionBlock\n    \"Answer the first index > anIndex at which starts a sequence of\n     items matching aSubCollection.\n     Invoke exceptionBlock and answer its result if no such sequence is found\"\n\n    | selfSize subSize |\n    subSize  := aSubCollection size.\n    selfSize := self size.\n    anIndex + subSize - 1 <= selfSize ifTrue: [\n\tanIndex to: selfSize - subSize + 1 do: [ :index |\n\t    (self at: index) = (aSubCollection at: 1) ifTrue: [\n\t\t(self matchSubCollection: aSubCollection startingAt: index)\n\t\t    ifTrue: [^index]\n\t    ]\n\t]\n    ].\n    ^exceptionBlock value",
              "literals": [],
              "methodName": "indexOfSubCollection:startingAt:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "identityIndexOf:startingAt:ifAbsent:": {
              "src": "identityIndexOf: anObject startingAt: anIndex ifAbsent: exceptionBlock\n    \"Answer the first index > anIndex which contains an object exactly\n     identical to anObject.\n     Invoke exceptionBlock and answer its result if no item is found\"\n\n    (anIndex < 1) | (anIndex > self size) ifTrue: [\n\t\"If anIndex is just past the end of the collection, don't raise\n\t an error (this is the most generic solution that avoids that\n\t #indexOf: fails when the collection is empty.\"\n\tanIndex = (self size + 1)\n\t    ifTrue: [ ^exceptionBlock value ]\n\t    ifFalse: [ ^self checkIndexableBounds: anIndex ]\n    ].\n\n    anIndex to: self size do: [ :index |\n\t(self at: index) == anObject ifTrue: [ ^index ].\n    ].\n    ^exceptionBlock value",
              "literals": [],
              "methodName": "identityIndexOf:startingAt:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "streamContents:": {
              "src": "streamContents: aBlock\n    \"Create a ReadWriteStream on an empty instance of the receiver;\n     pass the stream to aBlock, then retrieve its contents and\n     answer them.\"\n    | stream |\n    stream := ReadWriteStream on: (self new: 10).\n    stream truncate.\n    aBlock value: stream.\n    ^stream contents",
              "literals": [],
              "methodName": "streamContents:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "replaceFrom:to:withObject:": {
              "src": "replaceFrom: anIndex to: stopIndex withObject: replacementObject\n    \"Replace every item from start to stop with replacementObject.\"\n\n    (stopIndex < anIndex) ifTrue: [\n\t^SystemExceptions ArgumentOutOfRange\n\t    signalOn: stopIndex\n\t    mustBeBetween: anIndex and: self size ].\n\n    anIndex to: stopIndex do: [ :index |\n\tself at: index put: replacementObject.\n    ]",
              "literals": [],
              "methodName": "replaceFrom:to:withObject:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOf:ifAbsent:": {
              "src": "indexOf: anElement ifAbsent: exceptionBlock\n    \"Answer the index of the first occurrence of anElement in the receiver.\n     Invoke exceptionBlock and answer its result if no item is found\"\n    ^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock",
              "literals": [],
              "methodName": "indexOf:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "identityIncludes:": {
              "src": "identityIncludes: anObject\n    \"Answer whether we include the anObject object\"\n\n    \"Reimplemented to avoid an expensive full-block\"\n    1 to: self size do: [ :index |\n        anObject == (self at: index) ifTrue: [ ^true ]\n    ].\n    ^false",
              "literals": [],
              "methodName": "identityIncludes:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOf:startingAt:ifAbsent:": {
              "src": "indexOf: anElement startingAt: anIndex ifAbsent: exceptionBlock\n    \"Answer the first index > anIndex which contains anElement.\n     Invoke exceptionBlock and answer its result if no item is found\"\n\n    (anIndex < 1) | (anIndex > self size) ifTrue: [\n\t\"If anIndex is just past the end of the collection, don't raise\n\t an error (this is the most generic solution that avoids that\n\t #indexOf: fails when the collection is empty.\"\n\tanIndex = (self size + 1)\n\t    ifTrue: [ ^exceptionBlock value ]\n\t    ifFalse: [ ^self checkIndexableBounds: anIndex ]\n    ].\n\n    anIndex to: self size do: [ :index |\n\t(self at: index) = anElement ifTrue: [ ^index ].\n    ].\n    ^exceptionBlock value",
              "literals": [],
              "methodName": "indexOf:startingAt:ifAbsent:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "identityIndexOf:startingAt:": {
              "src": "identityIndexOf: anElement startingAt: anIndex\n    \"Answer the first index > anIndex which contains an object identical\n     to anElement. Answer 0 if no item is found\"\n    ^self indexOf: anElement startingAt: anIndex ifAbsent: [ ^0 ]",
              "literals": [],
              "methodName": "identityIndexOf:startingAt:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "copyReplaceFrom:to:withObject:": {
              "src": "copyReplaceFrom: start to: stop withObject: anObject\n    \"Answer a new collection of the same class as the receiver that contains the\n    same elements as the receiver, in the same order, except for elements from\n    index `start' to index `stop'.\n    \n    If start < stop, these are replaced by stop-start+1 copies of anObject.\n    Instead, If start = (stop + 1), then every element of the receiver\n    will be present in the answered copy; the operation will be an append if\n    stop is equal to the size of the receiver or, if it is not, an insert before\n    index `start'.\"\n\n    | newSize repSize result |\n    (stop - start < -1)\n\tifTrue: [ ^SystemExceptions ArgumentOutOfRange signalOn: stop mustBeBetween: start - 1 and: self size ].\n\n    (stop >= start) ifTrue: [ ^self copy atAll: (start to: stop) put: anObject; yourself ].\n\n    newSize := self size - (stop - start).\n\n    result := self copyEmpty: newSize.\n    start > 1 ifTrue: [\n\tself from: 1 to: start - 1 do: [ :each | result add: each ]\n    ].\n    result add: anObject.\n    stop < self size ifTrue: [\n\tself from: stop + 1 to: self size do: [ :each | result add: each ]\n    ].\n    ^result",
              "literals": [],
              "methodName": "copyReplaceFrom:to:withObject:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "reverse": {
              "src": "reverse\n    \"Answer the receivers' contents in reverse order\"\n    | result |\n    result := self copyEmptyForCollect.\n    self reverseDo: [ :each | result add: each ].\n    ^result",
              "literals": [],
              "methodName": "reverse",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOfSubCollection:startingAt:": {
              "src": "indexOfSubCollection: aSubCollection startingAt: anIndex\n    \"Answer the first index > anIndex at which starts a sequence of\n     items matching aSubCollection. Answer 0 if no such sequence is found.\"\n\n    ^self indexOfSubCollection: aSubCollection startingAt: anIndex\n    \tifAbsent: [ ^0 ]",
              "literals": [],
              "methodName": "indexOfSubCollection:startingAt:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "indexOf:startingAt:": {
              "src": "indexOf: anElement startingAt: anIndex\n    \"Answer the first index > anIndex which contains anElement.\n     Answer 0 if no item is found\"\n    ^self indexOf: anElement startingAt: anIndex ifAbsent: [ ^0 ]",
              "literals": [],
              "methodName": "indexOf:startingAt:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "first": {
              "src": "first\n    \"Answer the first item in the receiver\"\n    ^self at: 1",
              "literals": [],
              "methodName": "first",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            },
            "from:to:doWithIndex:": {
              "src": "from: startIndex to: stopIndex doWithIndex: aBlock\n    \"Evaluate aBlock for all the elements in the sequenceable collection whose\n     indices are in the range index to stopIndex, passing the index of each\n     element as the second parameter.  This method is mantained for backwards\n     compatibility and is not mandated by the ANSI standard; use\n     #from:to:keysAndValuesDo:\"\n\n    startIndex to: stopIndex do: [ :i | aBlock value: (self at: i) value: i ].",
              "literals": [],
              "methodName": "from:to:doWithIndex:",
              "className": "SequenceableCollection",
              "category": "private methods",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": [
            {
              "className": "LinkedList",
              "instance_methods": {
                "addLast:": {
                  "src": "addLast: aLink\n    \"Add aLink at then end of the list; return aLink.\"\n    firstLink isNil ifTrue: [ firstLink := aLink ].\n    lastLink notNil ifTrue: [ lastLink nextLink: aLink ].\n    ^lastLink := aLink",
                  "literals": [],
                  "methodName": "addLast:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "add:": {
                  "src": "add: aLink\n    \"Add aLink at the end of the list; return aLink.\"\n    self addLast: aLink.\n    ^aLink",
                  "literals": [],
                  "methodName": "add:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "size": {
                  "src": "size\n    \"Answer the number of elements in the list. Warning: this is O(n)\"\n    ^self isEmpty ifTrue: [ 0 ] ifFalse: [ firstLink size ]",
                  "literals": [],
                  "methodName": "size",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "at:": {
                  "src": "at: index\n    \"Return the element that is index into the linked list.\"\n    ^firstLink at: index",
                  "literals": [],
                  "methodName": "at:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "at:put:": {
                  "src": "at: index put: object\n    self shouldNotImplement",
                  "literals": [],
                  "methodName": "at:put:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "removeFirst": {
                  "src": "removeFirst\n    \"Remove the first element from the list and return it, or error if the\n    list is empty.\"\n\n    ^self remove: firstLink\n    \t  ifAbsent: [ SystemExceptions EmptyCollection signalOn: self ]",
                  "literals": [],
                  "methodName": "removeFirst",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "addFirst:": {
                  "src": "addFirst: aLink\n    \"Add aLink at the head of the list; return aLink.\"\n    lastLink isNil ifTrue: [ lastLink := aLink ].\n    aLink nextLink: firstLink.\n    ^firstLink := aLink",
                  "literals": [],
                  "methodName": "addFirst:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "isEmpty": {
                  "src": "isEmpty\n    \"Returns true if the list contains no members\"\n    ^firstLink isNil",
                  "literals": [],
                  "methodName": "isEmpty",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "remove:ifAbsent:": {
                  "src": "remove: aLink ifAbsent: aBlock\n    \"Remove aLink from the list and return it, or invoke aBlock if it's not\n    found in the list.\"\n    | prev |\n    aLink == firstLink ifTrue: [\n    \tfirstLink isNil ifTrue: [ ^aBlock value ].\n    \tfirstLink := firstLink nextLink.\n\tfirstLink isNil ifTrue: [ lastLink := nil ].\n\taLink nextLink: nil.\n\t^aLink\n    ].\n    prev := firstLink.\n    [\n\tprev isNil ifTrue: [ ^aBlock value ].\n\tprev nextLink == aLink\n    ]   whileFalse: [\n\tprev := prev nextLink\n    ].\n    prev nextLink: aLink nextLink.\n    aLink == lastLink ifTrue: [ lastLink := prev ].\n    aLink nextLink: nil.\n    ^aLink",
                  "literals": [],
                  "methodName": "remove:ifAbsent:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "notEmpty": {
                  "src": "notEmpty\n    \"Returns true if the list contains at least a member\"\n    ^firstLink notNil",
                  "literals": [],
                  "methodName": "notEmpty",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "removeLast": {
                  "src": "removeLast\n    \"Remove the final element from the list and return it, or error if the\n    list is empty.\"\n\n    ^self remove: lastLink\n    \t  ifAbsent: [ SystemExceptions EmptyCollection signalOn: self ]",
                  "literals": [],
                  "methodName": "removeLast",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                },
                "do:": {
                  "src": "do: aBlock\n    \"Enumerate each object in the list, passing it to aBlock (actual\n     behavior might depend on the subclass of Link that is being used).\"\n\n    self isEmpty ifFalse: [ firstLink do: aBlock ]",
                  "literals": [],
                  "methodName": "do:",
                  "className": "LinkedList",
                  "category": "testing",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": [
                {
                  "className": "Semaphore",
                  "instance_methods": {
                    "new": {
                      "src": "new\n    \"Answer a new semaphore\"\n    ^self basicNew initSemaphore",
                      "literals": [],
                      "methodName": "new",
                      "className": "Semaphore",
                      "category": "private",
                      "byteCodes": []
                    },
                    "initSemaphore": {
                      "src": "initSemaphore\n    signals := 0",
                      "literals": [],
                      "methodName": "initSemaphore",
                      "className": "Semaphore",
                      "category": "private",
                      "byteCodes": []
                    },
                    "signals": {
                      "src": "signals\n    \"Answer the number of processes that can be accomodated or (if negative\n     the number of waiting processes.\"\n\n    \"signals never goes below 0, even if there are waiting process. So\n     - if 0 and 0 processes are waiting, the signal count is 0\n     - if 0 and k processes are waiting, the signal count is -k\n     - if >0, no processes must be waiting and the signal count is signals\"\n    ^signals - self size",
                      "literals": [],
                      "methodName": "signals",
                      "className": "Semaphore",
                      "category": "private",
                      "byteCodes": []
                    },
                    "forMutualExclusion": {
                      "src": "forMutualExclusion\n    \"Answer a new semaphore with a signal on it. These semaphores are a useful\n     shortcut when you use semaphores as critical sections.\"\n    ^self new\n\tsignal;\n\tyourself",
                      "literals": [],
                      "methodName": "forMutualExclusion",
                      "className": "Semaphore",
                      "category": "private",
                      "byteCodes": []
                    },
                    "critical:": {
                      "src": "critical: aBlock\n    \"Wait for the receiver to be free, execute aBlock and signal the receiver\n     again. Return the result of evaluating aBlock.\n     aBlock MUST NOT CONTAIN A RETURN!!!\"\n    self wait.\n    ^aBlock ensure: [ self signal ]",
                      "literals": [],
                      "methodName": "critical:",
                      "className": "Semaphore",
                      "category": "private",
                      "byteCodes": []
                    }
                  },
                  "class_methods": {},
                  "subclasses": []
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "className": "DLD",
      "instance_methods": {},
      "class_methods": {
        "primDefineExternFunc:": {
          "src": "primDefineExternFunc: aFuncName\n    \"This method tries to link to a function with the given name, and answers\n     whether the linkage was successful. It should not be overridden.\"\n    | funcAddr |\n    \n    self libraryList do: [ :lib |\n\tlib value notNil ifTrue: [\n\t    funcAddr := self library: lib value getFunc: aFuncName.\n\t    funcAddr notNil ifTrue: [ \n\t\tself defineCFunc: aFuncName as: funcAddr.\n\t\t^true\n\t    ]\n\t]\n    ].\n    self libraryList\n\tdetect: [ :lib |\n\t    lib value isNil and: [\n\t\tlib value: (self linkFile: lib key).\n\t\tfuncAddr := self library: lib value getFunc: aFuncName.\n\t\tfuncAddr notNil\n\t    ]\n\t]\n\tifNone: [ ^false ].\n\n    self defineCFunc: aFuncName as: funcAddr.\n    ^true",
          "literals": [],
          "methodName": "primDefineExternFunc:",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "isFunction:": {
          "src": "isFunction: function\n    \"Answer whether a function is registered (on the C side) with the\n     given name or is dynamically loadable.\"\n\n    | descriptor |\n    descriptor := self\n\tfor: function\n    \treturning: #void\t\t\"dummy\"\n\twithArgs: #().\t\t\t\"dummy\"\n\n    ^descriptor isValid or: [ DLD defineExternFunc: function ]",
          "literals": [],
          "methodName": "isFunction:",
          "className": "CFunctionDescriptor",
          "category": "<unknown>",
          "byteCodes": []
        },
        "moduleList": {
          "src": "moduleList\n    \"Answer a copy of the modules reloaded when the image is started\"\n    ^ModuleList copy",
          "literals": [],
          "methodName": "moduleList",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "update:": {
          "src": "update: aspect\n    \"Called on startup - Make DLD re-link and reset the addresses of\n     all the externally defined functions\"\n    | notLinked linked |\n    aspect == #returnFromSnapshot ifFalse: [ ^self ].\n    LibraryList do: [ :each | each value: nil ].\n\n    notLinked := WriteStream on: Array new.\n\n    ModuleList do: [ :each |\n\t(self linkFile: each) isNil ifTrue: [ notLinked nextPut: each ]\n    ].\n\n    CFunctionDescs do: [ :func |\n\tfunc isInteger not\n\t    ifTrue: [\n\t\tlinked := (CFunctionDescriptor isFunction: func name) or: [\n\t\t    self defineExternFunc: func name ].\n\n\t\tlinked\n\t\t    ifFalse: [\n\t\t\tnotLinked nextPut: func name\n\t\t    ]\n\t\t    ifTrue: [\n\t\t\tfunc address: (CFunctionDescriptor addressOf: func name)\n\t\t    ]\n\t    ]\n    ].\n    \n    notLinked := notLinked contents.\n    notLinked isEmpty ifFalse: [\n\tSystemExceptions CInterfaceError signal: 'functions ',\n\t\t    notLinked printString, ' could not be re-linked.'\n    ]",
          "literals": [],
          "methodName": "update:",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "addLibrary:": {
          "src": "addLibrary: library\n    \"Add library to the search path of libraries to be used by DLD.\"\n    ( LibraryList contains: [ :anAssociation | anAssociation key = library ] )\n       ifFalse: [ LibraryList add: library -> nil ]",
          "literals": [],
          "methodName": "addLibrary:",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "initialize": {
          "src": "initialize\n    \"Private - Initialize the receiver's class variables\"\n    LibraryList := OrderedCollection new.\n    ModuleList := OrderedCollection new.\n    ObjectMemory addDependent: DLD",
          "literals": [],
          "methodName": "initialize",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "addModule:": {
          "src": "addModule: library\n    \"Add library to the list of modules to be loaded when the image is\n     started.  The gst_initModule function in the library is called,\n     but the library will not be put in the search path used whenever\n     a C function is requested but not registered.\"\n\n    ( ModuleList includes: library ) ifFalse: [\n        (self linkFile: library) isNil\n           ifTrue: [\n\t\tSystemExceptions CInterfaceError\n\t\t    signal: 'requested module ', library, ' was not found' ]\n           ifFalse: [ ModuleList add: library ]\n    ]",
          "literals": [],
          "methodName": "addModule:",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "libraryList": {
          "src": "libraryList\n    \"Answer a copy of the search path of libraries to be used by DLD\"\n    ^LibraryList copy",
          "literals": [],
          "methodName": "libraryList",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        },
        "defineExternFunc:": {
          "src": "defineExternFunc: aFuncName\n    \"This method calls #primDefineExternFunc: to try to link to a function with\n     the given name, and answers whether the linkage was successful. You can\n     redefine this method to restrict the ability to do dynamic linking.\"\n    ^self primDefineExternFunc: aFuncName",
          "literals": [],
          "methodName": "defineExternFunc:",
          "className": "DLD",
          "category": "<unknown>",
          "byteCodes": []
        }
      },
      "subclasses": []
    },
    {
      "className": "Delay",
      "instance_methods": {
        "init:isRelative:": {
          "src": "init: milliseconds isRelative: aBoolean\n    isRelative := aBoolean.\n    resumptionTime := milliseconds",
          "literals": [],
          "methodName": "init:isRelative:",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "startDelayLoop": {
          "src": "startDelayLoop\n    \"Private - Start the processes for Delays\"\n\n    DelayProcess := [\n\t[ \n\t    TimeoutSem wait.\n\t    MutexSem critical: [\n\t        Queue next value signal.\n\t\tQueue isEmpty ifFalse: [ self timeout: Queue peek key ]\n\t    ]\n\t] repeat\n    ]   forkAt: Processor timingPriority.\n\n    DelayProcess name: 'timeout'.",
          "literals": [],
          "methodName": "startDelayLoop",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "wait": {
          "src": "wait\n    \"Wait until the amount of time represented by the instance of Delay\n     elapses\"\n    | elt sem |\n    sem := Semaphore new.\n    elt := Association key: self resumptionTime value: sem.\n\n    MutexSem critical: [\n\tQueue nextPut: elt.\n\t\"If we've become the head of the list, we need to\n\t alter the interrupt time\"\n\tQueue peek == elt ifTrue: [ Delay timeout: elt key ]\n    ].\n    sem wait",
          "literals": [],
          "methodName": "wait",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "forSeconds:": {
          "src": "forSeconds: secondCount\n    \"Answer a Delay waiting for secondCount seconds\"\n    ^self forMilliseconds: secondCount * 1000",
          "literals": [],
          "methodName": "forSeconds:",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "timeout:": {
          "src": "timeout: milliseconds\n    \"Private - Signal the TimeoutSem after the given number of milliseconds.\n    Delays across midnight are gracefully handled.\"\n    | resumeMillis |\n    resumeMillis := milliseconds - Delay millisecondClockValue.\n    resumeMillis <= 0 ifTrue: [ TimeoutSem signal. ^self ].\n\n    resumeMillis := (resumeMillis \\\\ Time millisecondsPerDay) asInteger.\n    Processor\n\tsignal: TimeoutSem\n\tatMilliseconds: resumeMillis",
          "literals": [],
          "methodName": "timeout:",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "resumptionTime": {
          "src": "resumptionTime\n    \"Answer the time when a process waiting on a Delay will resume\"\n    isRelative\n\tifTrue: [ ^Delay millisecondClockValue + resumptionTime ] \n\tifFalse: [ ^resumptionTime ]",
          "literals": [],
          "methodName": "resumptionTime",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "forMilliseconds:": {
          "src": "forMilliseconds: millisecondCount\n    \"Answer a Delay waiting for millisecondCount milliseconds\"\n    ^self new init: millisecondCount isRelative: true",
          "literals": [],
          "methodName": "forMilliseconds:",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "millisecondClockValue": {
          "src": "millisecondClockValue\n    \"Private - Answer the number of milliseconds since midnight\"\n    ^Time primMillisecondClock",
          "literals": [],
          "methodName": "millisecondClockValue",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "untilMilliseconds:": {
          "src": "untilMilliseconds: millisecondCount\n    \"Answer a Delay waiting for millisecondCount milliseconds after midnight\"\n    ^self new init: millisecondCount isRelative: false",
          "literals": [],
          "methodName": "untilMilliseconds:",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "initialize": {
          "src": "initialize\n    \"Private - Initialize the receiver and the associated process\"\n    \"'initalizing Delays' printNl.\"\n    | queue |\n    Queue := SharedQueue sortBlock: [ :a :b | (a key) <= (b key) ].\n    MutexSem := Semaphore forMutualExclusion.\n    TimeoutSem := Semaphore new.\n\n    IdleProcess := [\n\t[ Processor idle; yield ] repeat\n    ] newProcess.\n\n    IdleProcess\n\tname: 'idle';\n\tpriority: Processor systemBackgroundPriority;\n\tresume.\n\n    Delay startDelayLoop",
          "literals": [],
          "methodName": "initialize",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "=": {
          "src": "= aDelay\n    \"Answer whether the receiver and aDelay denote the same delay\"\n    self class == aDelay class ifFalse: [ ^false ].\n\n    ^(isRelative = aDelay isRelative)\n\tand: [ resumptionTime = aDelay basicResumptionTime ]",
          "literals": [],
          "methodName": "=",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "isRelative": {
          "src": "isRelative\n    ^isRelative",
          "literals": [],
          "methodName": "isRelative",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "hash": {
          "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^resumptionTime",
          "literals": [],
          "methodName": "hash",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        },
        "basicResumptionTime": {
          "src": "basicResumptionTime\n    ^resumptionTime",
          "literals": [],
          "methodName": "basicResumptionTime",
          "className": "Delay",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "File",
      "instance_methods": {
        "stripExtensionFrom:": {
          "src": "stripExtensionFrom: aString\n    \"Remove the extension from the name of a file called `aString', and\n     answer the result\"\n    | index |\n    aString isEmpty ifTrue: [ ^'' ].\n    index := aString findLast: [ :each |\n\teach = Directory pathSeparator ifTrue: [ ^aString ]\n\teach = $.\n    ].\n\n    \"Special case .foo and /bar/.foo\"\n    index = 1 ifTrue: [ ^aString ].\n    (aString at: index - 1) = Directory pathSeparator ifTrue: [ ^aString ].\n    ^aString copyFrom: 1 to: index - 1",
          "literals": [],
          "methodName": "stripExtensionFrom:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "extension": {
          "src": "extension\n    \"Answer the extension of the receiver\"\n    ^File extensionFor: self name",
          "literals": [],
          "methodName": "extension",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "creationTime": {
          "src": "creationTime\n    \"Answer the creation time of the file identified by the receiver.\n    On some operating systems, this could actually be the last change time\n    (the `last change time' has to do with permissions, ownership and the\n    like).\"\n    ^vfsHandler creationTime",
          "literals": [],
          "methodName": "creationTime",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "exists:": {
          "src": "exists: fileName\n    \"Answer whether a file with the given name exists\"\n    ^(File name: fileName) exists",
          "literals": [],
          "methodName": "exists:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isExecutable:": {
          "src": "isExecutable: fileName\n    \"Answer whether a file with the given name exists and can be executed\"\n    ^(File name: fileName) isExecutable",
          "literals": [],
          "methodName": "isExecutable:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "checkError:": {
          "src": "checkError: errno\n    \"The error with the C code `errno' has been reported.\n     If errno >= 1, raise an exception\"\n\n    | errors |\n    errno < 1 ifTrue: [ ^false ].\n    SystemExceptions FileError signal: (self stringError: errno).\n    ^true",
          "literals": [],
          "methodName": "checkError:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isAccessible:": {
          "src": "isAccessible: fileName\n    \"Answer whether a directory with the given name exists and can be accessed\"\n    ^(File name: fileName) isAccessible",
          "literals": [],
          "methodName": "isAccessible:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "checkError": {
          "src": "checkError\n    \"Return whether an error had been reported or not.\n     If there had been one, raise an exception too\"\n\n    ^self checkError: self errno",
          "literals": [],
          "methodName": "checkError",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "remove": {
          "src": "remove\n    \"Remove the file identified by the receiver\"\n    ^vfsHandler remove",
          "literals": [],
          "methodName": "remove",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "openDescriptor:": {
          "src": "openDescriptor: mode\n    \"Open the receiver in the given mode (as answered by FileStream's\n    class constant methods). Upon failure, evaluate aBlock.\"\n    ^vfsHandler openDescriptor: mode ifFail: [\n \t    SystemExceptions FileError signal: 'could not open ', self name ]",
          "literals": [],
          "methodName": "openDescriptor:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "path": {
          "src": "path\n    \"Answer the path (if any) of the receiver\"\n    ^File pathFor: self name",
          "literals": [],
          "methodName": "path",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "init:": {
          "src": "init: aVFSHandler\n    \"Private - Initialize the receiver's instance variables\"\n    vfsHandler := aVFSHandler",
          "literals": [],
          "methodName": "init:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "writeStream": {
          "src": "writeStream\n    \"Open a write-only FileStream on the receiver\"\n    ^self open: FileStream write",
          "literals": [],
          "methodName": "writeStream",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "stripPath": {
          "src": "stripPath\n    \"Answer the file name and extension (if any) of the receiver\"\n    ^File stripPathFrom: self name",
          "literals": [],
          "methodName": "stripPath",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "extensionFor:": {
          "src": "extensionFor: aString\n    \"Answer the extension of a file named `aString'\"\n    | index |\n    aString isEmpty ifTrue: [ ^'' ].\n    index := aString findLast: [ :each |\n\teach = Directory pathSeparator ifTrue: [ ^'' ]\n\teach = $.\n    ].\n\n    \"Special case .foo and /bar/.foo\"\n    index = 1 ifTrue: [ ^'' ].\n    (aString at: index - 1) = Directory pathSeparator ifTrue: [ ^'' ].\n    ^aString copyFrom: index + 1 to: aString size.",
          "literals": [],
          "methodName": "extensionFor:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "readStream": {
          "src": "readStream\n    \"Open a read-only FileStream on the receiver\"\n    ^self open: FileStream read",
          "literals": [],
          "methodName": "readStream",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "fullNameFor:": {
          "src": "fullNameFor: aString\n    \"Answer the full path to a file called `aString', resolving the `.' and\n     `..' directory entries, and answer the result.  `/..' is the same as '/'.\"\n\n    | path substrings |\n    path := OrderedCollection new.\n    (aString at: 1) = Directory pathSeparator ifFalse: [\n\tpath addAll: (Directory working substrings: Directory pathSeparator).\n    ].\n    substrings := aString substrings: Directory pathSeparator.\n    substrings := ReadStream on: substrings.\n\n    substrings do: [ :each |\n\teach = '.' ifFalse: [\n\t    each = '..'\n\t\tifTrue: [ path isEmpty ifFalse: [ path removeLast ] ]\n\t        ifFalse: [ path add: each ].\n\t]\n    ].\n\n    ^path inject: '/' into: [ :old :each |\n\tDirectory append: each to: old\n    ]",
          "literals": [],
          "methodName": "fullNameFor:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "pathFor:": {
          "src": "pathFor: aString\n    \"Determine the path of the name of a file called `aString', and\n     answer the result.  With the exception of the root directory, the\n     final slash is stripped.\"\n    | index |\n    aString isEmpty ifTrue: [ ^'' ].\n    index := aString findLast: [ :each | each = Directory pathSeparator ].\n    index = 0 ifTrue: [ ^'' ].\n    index = 1 ifTrue: [ ^Directory pathSeparatorString ].\n    ^aString copyFrom: 1 to: index - 1.",
          "literals": [],
          "methodName": "pathFor:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isExecutable": {
          "src": "isExecutable\n    \"Answer whether a file with the name contained in the receiver does exist\n     and is executable\"\n    ^self isFile and: [ vfsHandler isExecutable ]",
          "literals": [],
          "methodName": "isExecutable",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "stripFileNameFor:": {
          "src": "stripFileNameFor: aString\n    \"Determine the path of the name of a file called `aString', and\n     answer the result as a directory name including the final slash.\"\n    | index |\n    aString isEmpty ifTrue: [ ^'./' ].\n    index := aString findLast: [ :each | each = Directory pathSeparator ].\n    index = 0 ifTrue: [ ^'./' ].\n    index = 1 ifTrue: [ ^Directory pathSeparatorString ].\n    ^aString copyFrom: 1 to: index.",
          "literals": [],
          "methodName": "stripFileNameFor:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "stripFileName": {
          "src": "stripFileName\n    \"Answer the path of the receiver, always including a directory\n     name (possibly `.') and the final directory separator\"\n    ^File stripFileNameFor: self name",
          "literals": [],
          "methodName": "stripFileName",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isWriteable": {
          "src": "isWriteable\n    \"Answer whether a file with the name contained in the receiver does exist\n     and is writeable\"\n    ^self exists and: [ vfsHandler isWriteable ]",
          "literals": [],
          "methodName": "isWriteable",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "open:": {
          "src": "open: mode\n    \"Open the receiver in the given mode (as answered by FileStream's\n    class constant methods)\"\n    ^vfsHandler open: mode ifFail: [\n \t    SystemExceptions FileError signal: 'could not open ', self name ]",
          "literals": [],
          "methodName": "open:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "image": {
          "src": "image\n    \"Answer the full path to the image being used.\"\n    ^ImageFileName",
          "literals": [],
          "methodName": "image",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "remove:": {
          "src": "remove: fileName\n    \"Remove the file with the given path name\"\n    (VFS VFSHandler for: fileName) remove",
          "literals": [],
          "methodName": "remove:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isAccessible": {
          "src": "isAccessible\n    \"Answer whether a directory with the name contained in the receiver does\n     exist and can be accessed\"\n    ^self isDirectory and: [ vfsHandler isAccessible ]",
          "literals": [],
          "methodName": "isAccessible",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "lastAccessTime": {
          "src": "lastAccessTime\n    \"Answer the last access time of the file identified by the receiver\"\n    ^vfsHandler lastAccessTime",
          "literals": [],
          "methodName": "lastAccessTime",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isFile": {
          "src": "isFile\n    \"Answer whether a file with the name contained in the receiver does exist\n    and does not identify a directory.\"\n    ^vfsHandler exists and: [ vfsHandler isDirectory not ]",
          "literals": [],
          "methodName": "isFile",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "stripPathFrom:": {
          "src": "stripPathFrom: aString\n    \"Remove the path from the name of a file called `aString', and\n     answer the file name plus extension.\"\n    | index |\n    aString isEmpty ifTrue: [ ^'' ].\n    index := aString findLast: [ :each | each = Directory pathSeparator ].\n    ^aString copyFrom: index + 1 to: aString size",
          "literals": [],
          "methodName": "stripPathFrom:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "refresh": {
          "src": "refresh\n    \"Refresh the statistics for the receiver\"\n    vfsHandler refresh",
          "literals": [],
          "methodName": "refresh",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "fullName": {
          "src": "fullName\n    \"Answer the full name of the receiver, resolving the `.' and\n     `..' directory entries, and answer the result.  Answer nil if the\n     name is invalid (such as '/usr/../../badname')\"\n    ^File fullNameFor: self name",
          "literals": [],
          "methodName": "fullName",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "open:ifFail:": {
          "src": "open: mode ifFail: aBlock\n    \"Open the receiver in the given mode (as answered by FileStream's\n    class constant methods). Upon failure, evaluate aBlock.\"\n    ^vfsHandler open: mode ifFail: aBlock",
          "literals": [],
          "methodName": "open:ifFail:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isReadable:": {
          "src": "isReadable: fileName\n    \"Answer whether a file with the given name exists and is readable\"\n    ^(File name: fileName) isReadable",
          "literals": [],
          "methodName": "isReadable:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "renameTo:": {
          "src": "renameTo: newName\n    \"Remove the file identified by the receiver\"\n    vfsHandler renameTo: newName",
          "literals": [],
          "methodName": "renameTo:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "name:": {
          "src": "name: aName\n    \"Answer a new file with the given path. The path is not validated until\n    some of the fields of the newly created objects are accessed\"\n    ^self basicNew init: (VFS VFSHandler for: aName)",
          "literals": [],
          "methodName": "name:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "size": {
          "src": "size\n    \"Answer the size of the file identified by the receiver\"\n    ^vfsHandler size",
          "literals": [],
          "methodName": "size",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "contents": {
          "src": "contents\n    \"Open a read-only FileStream on the receiver, read its contents,\n    close the stream and answer the contents\"\n    | stream contents |\n    stream := self readStream.\n    contents := stream contents.\n    stream close.\n    ^contents",
          "literals": [],
          "methodName": "contents",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "lastChangeTime": {
          "src": "lastChangeTime\n    \"Answer the last change time of the file identified by the receiver\n    (the `last change time' has to do with permissions, ownership and the\n    like). On some operating systems, this could actually be the\n    file creation time.\"\n    ^vfsHandler lastChangeTime",
          "literals": [],
          "methodName": "lastChangeTime",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "lastModifyTime": {
          "src": "lastModifyTime\n    \"Answer the last modify time of the file identified by the receiver\n    (the `last modify time' has to do with the actual file contents).\"\n    ^vfsHandler lastModifyTime",
          "literals": [],
          "methodName": "lastModifyTime",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "name": {
          "src": "name\n    \"Answer the name of the file identified by the receiver\"\n    ^vfsHandler name",
          "literals": [],
          "methodName": "name",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "exists": {
          "src": "exists\n    \"Answer whether a file with the name contained in the receiver does exist.\"\n    ^vfsHandler exists",
          "literals": [],
          "methodName": "exists",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isReadable": {
          "src": "isReadable\n    \"Answer whether a file with the name contained in the receiver does exist\n     and is readable\"\n    ^vfsHandler exists and: [ vfsHandler isReadable ]",
          "literals": [],
          "methodName": "isReadable",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "stripExtension": {
          "src": "stripExtension\n    \"Answer the path (if any) and file name of the receiver\"\n    ^File stripExtensionFrom: self name",
          "literals": [],
          "methodName": "stripExtension",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "rename:to:": {
          "src": "rename: oldFileName to: newFileName\n    \"Rename the file with the given path name oldFileName to newFileName\"\n    (VFS VFSHandler for: oldFileName) renameTo: newFileName",
          "literals": [],
          "methodName": "rename:to:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isDirectory": {
          "src": "isDirectory\n    \"Answer whether a file with the name contained in the receiver does exist\n    and identifies a directory.\"\n    | dir errno |\n    ^vfsHandler exists and: [ vfsHandler isDirectory ]",
          "literals": [],
          "methodName": "isDirectory",
          "className": "File",
          "category": "private",
          "byteCodes": []
        },
        "isWriteable:": {
          "src": "isWriteable: fileName\n    \"Answer whether a file with the given name exists and is writeable\"\n    ^(File name: fileName) isWriteable",
          "literals": [],
          "methodName": "isWriteable:",
          "className": "File",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "Directory",
          "instance_methods": {
            "filesMatching:do:": {
              "src": "filesMatching: aPattern do: block\n    \"Evaluate block on the File objects that match aPattern (according to\n     String>>#match:) in the directory named by the receiver.\"\n\n    self do: [:name | (aPattern match: name)\n\t    ifTrue: [block value: (self at: name)]]",
              "literals": [],
              "methodName": "filesMatching:do:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "image": {
              "src": "image\n    \"Answer the path to GNU Smalltalk's image file\"\n    ^ImageFilePath",
              "literals": [],
              "methodName": "image",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "temporary": {
              "src": "temporary\n    \"Answer the path in which temporary files can be created.  This is\n     read from the environment, and guessed if that fails.\"\n    | d |\n    (d := Smalltalk getenv: 'TMPDIR') isNil ifFalse: [ ^d ].\n    (d := Smalltalk getenv: 'TEMP') isNil ifFalse: [ ^d ].\n    (d := self home) isNil ifFalse: [\n\td := d, '/tmp'.\n\t(Directory exists: d) ifTrue: [ ^d ]\n    ].\n    ^'/tmp'",
              "literals": [],
              "methodName": "temporary",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "fullNameAt:": {
              "src": "fullNameAt: aName\n    \"Answer a String containing the full path to a file named `aName' which\n     resides in the directory represented by the receiver.\"\n    ^Directory append: aName to: self fullName",
              "literals": [],
              "methodName": "fullNameAt:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "kernel": {
              "src": "kernel\n    \"Answer the path in which a local version of the GNU Smalltalk kernel's\n     Smalltalk source files were searched when the image was created\"\n    ^KernelFilePath",
              "literals": [],
              "methodName": "kernel",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "at:": {
              "src": "at: aName\n    \"Answer a File object for a file named `aName' residing in the directory\n     represented by the receiver.\"\n    ^File name: (self nameAt: aName)",
              "literals": [],
              "methodName": "at:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "module": {
              "src": "module\n    \"Answer the path to GNU Smalltalk's dynamically loaded modules\"\n    ^ModulePath",
              "literals": [],
              "methodName": "module",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "systemKernel": {
              "src": "systemKernel\n    \"Answer the path to the GNU Smalltalk kernel's Smalltalk source files\"\n    ^KernelFileSystemPath",
              "literals": [],
              "methodName": "systemKernel",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "includes:": {
              "src": "includes: aName\n    \"Answer whether a file named `aName' exists in the directory represented\n     by the receiver.\"\n    ^File exists: (self nameAt: aName)",
              "literals": [],
              "methodName": "includes:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "do:": {
              "src": "do: aBlock\n    \"Evaluate aBlock once for each file in the directory represented by the\n    receiver, passing its name. aBlock should not return.\"\n    vfsHandler do: aBlock",
              "literals": [],
              "methodName": "do:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "home": {
              "src": "home\n    \"Answer the path to the user's home directory\"\n    ^Smalltalk getenv: 'HOME'",
              "literals": [],
              "methodName": "home",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "directoryAt:": {
              "src": "directoryAt: aName\n    \"Answer a Directory object for a file named `aName' residing in the\n     directory represented by the receiver.\"\n    ^Directory name: (self nameAt: aName)",
              "literals": [],
              "methodName": "directoryAt:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "append:to:": {
              "src": "append: fileName to: directory\n    \"Answer the name of a file named `fileName' which resides in a directory\n     named `directory'.\"\n    directory isEmpty ifTrue: [ ^fileName ].\n    ^(directory at: directory size) = self pathSeparator\n\tifTrue: [ directory, fileName ]\n\tifFalse: [ '%1%2%3'\n\t    bindWith: directory\n\t    with: self pathSeparatorString\n\t    with: fileName ]",
              "literals": [],
              "methodName": "append:to:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "create:": {
              "src": "create: dirName\n    \"Create a directory named dirName.\"\n    ^(VFS VFSHandler for: (File pathFor: dirName))\n\tcreateDir: (File stripPathFrom: dirName)",
              "literals": [],
              "methodName": "create:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "pathSeparatorString": {
              "src": "pathSeparatorString\n    \"Answer (in a String) the character used to separate directory names\"\n    ^'/'",
              "literals": [],
              "methodName": "pathSeparatorString",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "pathSeparator": {
              "src": "pathSeparator\n    \"Answer (as a Character) the character used to separate directory names\"\n    ^$/",
              "literals": [],
              "methodName": "pathSeparator",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "working:": {
              "src": "working: dirName\n    \"Change the current working directory to dirName.\"\n    self primWorking: dirName.\n    self checkError",
              "literals": [],
              "methodName": "working:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "localKernel": {
              "src": "localKernel\n    \"Answer the path in which a local version of the GNU Smalltalk kernel's\n     Smalltalk source files were found\"\n    ^KernelFileLocalPath",
              "literals": [],
              "methodName": "localKernel",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "contents": {
              "src": "contents\n    \"Answer an Array with the names of the files in the directory\n    represented by the receiver.\"\n    | ws |\n    ws := WriteStream on: (Array new: 50).\n    self do: [ :each | ws nextPut: each ].\n    ^ws contents",
              "literals": [],
              "methodName": "contents",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "nameAt:": {
              "src": "nameAt: aName\n    \"Answer a String containing the path to a file named `aName' which\n     resides in the directory represented by the receiver.\"\n    ^Directory append: aName to: self name",
              "literals": [],
              "methodName": "nameAt:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            },
            "namesMatching:do:": {
              "src": "namesMatching: aPattern do: block\n    \"Evaluate block on the file names that match aPattern (according to\n     String>>#match:) in the directory named by the receiver.\"\n\n    self do: [:name | (aPattern match: name)\n\t    ifTrue: [block value: (self nameAt: name)]]",
              "literals": [],
              "methodName": "namesMatching:do:",
              "className": "Directory",
              "category": "enumerating",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        }
      ]
    },
    {
      "className": "FileSegment",
      "instance_methods": {
        "withFileDo:": {
          "src": "withFileDo: aBlock\n    \"Evaluate aBlock passing it the FileStream in which the segment\n     identified by the receiver is stored\"\n    | result fileStream |\n    fileStream := FileStream open: self fileName mode: FileStream read.\n    ^[ aBlock value: fileStream ] ensure: [ fileStream close ]",
          "literals": [],
          "methodName": "withFileDo:",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "filePos": {
          "src": "filePos\n    \"Answer the position in the file where the segment starts\"\n    ^startPos",
          "literals": [],
          "methodName": "filePos",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "fileName": {
          "src": "fileName\n    \"Answer the name of the file containing the segment\"\n    ^file",
          "literals": [],
          "methodName": "fileName",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "relocateFrom:to:": {
          "src": "relocateFrom: startPath to: endPath\n    \"Remove startPath from all paths that start with it, and replace it\n     with endPath.  Needed to support $(DESTDIR) when installing\"\n    | map |\n    map := IdentityDictionary new.\n    self allInstancesDo: [ :each |\n\teach relocateFrom: startPath to: endPath map: map ].",
          "literals": [],
          "methodName": "relocateFrom:to:",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "size": {
          "src": "size\n    \"Answer the length of the segment\"\n    ^size",
          "literals": [],
          "methodName": "size",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "relocateFrom:to:map:": {
          "src": "relocateFrom: startPath to: endPath map: map\n    \"If the path starts with startPath, remove that part of the path\n     and replace it with endPath.  map is a Dictionary that is used\n     so that equal filenames stay equal, without increasing the amount\n     of memory that the image uses.\"\n    file := map at: self fileName ifAbsent: [\n\t(self fileName startsWith: startPath)\n\t    ifTrue: [\n\t\tmap\n\t\t    at: self fileName\n\t\t    put: endPath,\n\t\t\t (file copyFrom: startPath size + 1 to: file size)\n\t   ]\n\t   ifFalse: [ file ]\n    ]",
          "literals": [],
          "methodName": "relocateFrom:to:map:",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "setFile:start:size:": {
          "src": "setFile: aFileName start: startingPos size: sizeInteger\n    file := aFileName.\n    startPos := startingPos.\n    size := sizeInteger.",
          "literals": [],
          "methodName": "setFile:start:size:",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "asString": {
          "src": "asString\n    \"Answer a String containing the required segment of the file\"\n    ^self withFileDo: [ :fileStream |\n\tfileStream position: startPos.\n\tfileStream next: size.\n    ]",
          "literals": [],
          "methodName": "asString",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "=": {
          "src": "= aFileSegment\n    \"Answer whether the receiver and aFileSegment are equal.\"\n\n    (aFileSegment isKindOf: FileSegment) ifFalse: [ ^false ].\n    self == aFileSegment ifTrue: [ ^true ].\n\n    ^self fileName = aFileSegment fileName and: [\n\tstartPos = aFileSegment filePos and: [\n\t    size = aFileSegment size ] ]",
          "literals": [],
          "methodName": "=",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "getFile": {
          "src": "getFile\n    ^file",
          "literals": [],
          "methodName": "getFile",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        },
        "hash": {
          "src": "hash\n    \"Answer an hash value for the receiver.\"\n\n    ^self fileName hash bitXor: (startPos + size)",
          "literals": [],
          "methodName": "hash",
          "className": "FileSegment",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "Link",
      "instance_methods": {
        "nextLink:": {
          "src": "nextLink: aLink\n    \"Set the next item in the list\"\n    nextLink := aLink",
          "literals": [],
          "methodName": "nextLink:",
          "className": "Link",
          "category": "basic",
          "byteCodes": []
        },
        "size": {
          "src": "size\n    \"Answer the number of elements in the list. Warning: this is O(n)\"\n    | item count |\n    item := self.\n    count := 1.\n    [ (item := item nextLink) isNil ] whileFalse: [ count := count + 1 ].\n    ^count",
          "literals": [],
          "methodName": "size",
          "className": "Link",
          "category": "basic",
          "byteCodes": []
        },
        "at:": {
          "src": "at: index\n    \"Retrieve a node (instance of Link) that is at a distance of `index'\n     after the receiver.\"\n    | i element |\n    i := 1.\n    element := self.\n    [\n\ti = index ifTrue: [ ^element ].\n\ti := i + 1.\n\t(element := element nextLink) isNil\n    ] whileFalse.\n    SystemExceptions IndexOutOfRange signalOn: self withIndex: index",
          "literals": [],
          "methodName": "at:",
          "className": "Link",
          "category": "basic",
          "byteCodes": []
        },
        "at:put:": {
          "src": "at: index put: object\n    self shouldNotImplement",
          "literals": [],
          "methodName": "at:put:",
          "className": "Link",
          "category": "basic",
          "byteCodes": []
        },
        "do:": {
          "src": "do: aBlock\n    \"Evaluate aBlock for each element in the list\"\n    | item |\n    item := self.\n    [ aBlock value: item. (item := item nextLink) isNil ] whileFalse",
          "literals": [],
          "methodName": "do:",
          "className": "Link",
          "category": "basic",
          "byteCodes": []
        },
        "nextLink": {
          "src": "nextLink\n    \"Answer the next item in the list\"\n    ^nextLink",
          "literals": [],
          "methodName": "nextLink",
          "className": "Link",
          "category": "basic",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "Process",
          "instance_methods": {
            "suspend": {
              "src": "suspend\n    \"Do nothing if we're already suspended. Note that the blue book made\n     suspend a primitive - but the real primitive is yielding control to\n     another process. Suspending is nothing more than taking ourselves out\n     of every scheduling list and THEN yield control to another process\"\n\n    self isSuspended ifTrue: [ ^nil ].\n    myList remove: self ifAbsent: [ ].\n    myList := nil.\n    self yield",
              "literals": [],
              "methodName": "suspend",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "isSuspended": {
              "src": "isSuspended\n    \"Answer whether the receiver is suspended through #suspend\"\n    ^myList isNil",
              "literals": [],
              "methodName": "isSuspended",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "onBlock:at:": {
              "src": "onBlock: aBlock at: aPriority\n    suspendedContext := aBlock.\n    priority := aPriority.\n    \"By default we're suspended, so don't set myList!\"",
              "literals": [],
              "methodName": "onBlock:at:",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "isTerminated": {
              "src": "isTerminated\n    \"Answer whether the receiver has already terminated\"\n    ^suspendedContext isNil",
              "literals": [],
              "methodName": "isTerminated",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "raisePriority": {
              "src": "raisePriority\n    \"Raise a bit the priority of the receiver. A #lowerPriority will\n     cancel a previous #raisePriority, and vice versa.\"\n    self priority: self priority + 1",
              "literals": [],
              "methodName": "raisePriority",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "isReady": {
              "src": "isReady\n    \"Answer whether the receiver is not suspended nor waiting on a\n     semaphore (maybe it is active, maybe it is not, though)\"\n    ^myList == (Processor processesAt: priority)",
              "literals": [],
              "methodName": "isReady",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "unwindPoints": {
              "src": "unwindPoints\n    unwindPoints isNil ifTrue: [ unwindPoints := OrderedCollection new ].\n    ^unwindPoints",
              "literals": [],
              "methodName": "unwindPoints",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "priority": {
              "src": "priority\n    \"Answer the receiver's priority\"\n    ^priority",
              "literals": [],
              "methodName": "priority",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "isActive": {
              "src": "isActive\n    \"Answer whether the receiver is running\"\n    ^self == Processor activeProcess",
              "literals": [],
              "methodName": "isActive",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "priority:": {
              "src": "priority: anInteger\n    \"Change the receiver's priority to anInteger\"\n\n    \"If we are running, change the list\"\n    (anInteger < Processor lowestPriority) |\n    (anInteger > Processor highestPriority)\n\tifTrue: [ SystemExceptions ArgumentOutOfRange signalOn: anInteger\n\t    mustBeBetween: Processor lowestPriority\n\t    and: Processor highestPriority ].\n\n    self isReady\n\tifTrue: [ myList := Processor changePriorityOf: self to: anInteger ].\n    priority := anInteger",
              "literals": [],
              "methodName": "priority:",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n\n    aStream\n\tprint: self class;\n\tnextPut: $(;\n\tprint: name;\n\tnextPutAll: ' at ';\n\tnextPutAll: (Processor priorityName: self priority);\n\tnextPut: $,.\n\n     \"The order here is important!\"\n     self isActive ifTrue: [ aStream nextPutAll: ' active)'. ^self ].\n     self isTerminated ifTrue: [ aStream nextPutAll: ' terminated)'. ^self ].\n     self isWaiting ifTrue: [ aStream nextPutAll: ' waiting on a semaphore)'. ^self ].\n     self isSuspended ifTrue: [ aStream nextPutAll: ' suspended)'. ^self ].\n     self isReady ifTrue: [ aStream nextPutAll: ' ready to run)'. ^self ].\n     aStream nextPutAll: ' undefined state)'.",
              "literals": [],
              "methodName": "printOn:",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "name:": {
              "src": "name: aString\n    \"Give the name aString to the process\"\n    name := aString",
              "literals": [],
              "methodName": "name:",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "forceResume": {
              "src": "forceResume\n    \"Private - Force a resume of the process from whatever status it was in\n     (even if it was waiting on a semaphore).  This is BAD practice, it is\n     present only for some future possibility.\"\n    self isReady ifTrue: [ ^self ].\n    self isSuspended ifFalse: [ myList remove: self ifAbsent: [ ] ].\n    myList := Processor processesAt: self priority.\n    myList addLast: self.\n    self resume",
              "literals": [],
              "methodName": "forceResume",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "lowerPriority": {
              "src": "lowerPriority\n    \"Lower a bit the priority of the receiver. A #lowerPriority will\n     cancel a previous #raisePriority, and vice versa.\"\n    self priority: self priority - 1",
              "literals": [],
              "methodName": "lowerPriority",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "name": {
              "src": "name\n    ^name",
              "literals": [],
              "methodName": "name",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "queueInterrupt:": {
              "src": "queueInterrupt: aBlock\n    \"Force the receiver to be interrupted and to evaluate aBlock as soon as it\n     becomes the active process (this could mean NOW if the receiver is active).\n     Answer the receiver\"\n\n    self isActive\n\tifTrue: [ aBlock value. ^self ].\n\n    self isTerminated\n\tifTrue: [ ^SystemExceptions ProcessTerminated signalOn: self ].\n\n    suspendedContext := aBlock asContext: suspendedContext.",
              "literals": [],
              "methodName": "queueInterrupt:",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "isWaiting": {
              "src": "isWaiting\n    \"Answer whether the receiver is wating on a semaphore\"\n    ^self isReady not & self isSuspended not",
              "literals": [],
              "methodName": "isWaiting",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "terminate": {
              "src": "terminate\n    \"Terminate the receiver - This is nothing more than prohibiting to\n     resume the process, then suspending it.\"\n    suspendedContext := nil.\n    self suspend",
              "literals": [],
              "methodName": "terminate",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            },
            "on:at:": {
              "src": "on: aBlockContext at: aPriority\n    \"Private - Create a process running aBlockContext at the given priority\"\n    ^self new onBlock: aBlockContext at: aPriority",
              "literals": [],
              "methodName": "on:at:",
              "className": "Process",
              "category": "private",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "SymLink",
          "instance_methods": {
            "symbol": {
              "src": "symbol\n    \"Answer the Symbol that the receiver refers to in the symbol table.\"\n    ^symbol",
              "literals": [],
              "methodName": "symbol",
              "className": "SymLink",
              "category": "printing",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream.\"\n    aStream nextPut: $[.\n    self do: \n\t[ :elt | elt printOn: aStream.\n\t\t aStream nextPut: Character space ].\n    aStream nextPut: $].",
              "literals": [],
              "methodName": "printOn:",
              "className": "SymLink",
              "category": "printing",
              "byteCodes": []
            },
            "symbol:": {
              "src": "symbol: aSymbol\n    \"Set the Symbol that the receiver refers to in the symbol table.\"\n    symbol := aSymbol",
              "literals": [],
              "methodName": "symbol:",
              "className": "SymLink",
              "category": "printing",
              "byteCodes": []
            },
            "symbol:nextLink:": {
              "src": "symbol: aSymbol nextLink: aSymLink\n    \"Answer a new SymLink, which refers to aSymbol and points to\n     aSymLink as the next SymLink in the chain.\"\n    ^(self nextLink: aSymLink)\n\tsymbol: aSymbol;\n\tyourself",
              "literals": [],
              "methodName": "symbol:nextLink:",
              "className": "SymLink",
              "category": "printing",
              "byteCodes": []
            },
            "do:": {
              "src": "do: aBlock\n    \"Evaluate aBlock for each symbol in the list\"\n    | item |\n    item := self.\n    [ aBlock value: item symbol. (item := item nextLink) isNil ] whileFalse",
              "literals": [],
              "methodName": "do:",
              "className": "SymLink",
              "category": "printing",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        }
      ]
    },
    {
      "className": "Magnitude",
      "instance_methods": {
        "<=": {
          "src": "<= aMagnitude\n    \"Answer whether the receiver is less than or equal to aMagnitude\"\n    ^(aMagnitude < self) not",
          "literals": [],
          "methodName": "<=",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        },
        "max:": {
          "src": "max: aMagnitude\n    \"Returns the greatest object between the receiver and aMagnitude\"\n    ^self > aMagnitude ifTrue: [ self ]\n    \t    \t      ifFalse: [ aMagnitude ]",
          "literals": [],
          "methodName": "max:",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        },
        "between:and:": {
          "src": "between: min and: max\n    \"Returns true if object is inclusively between min and max.\"\n    ^(self >= min) and: [ self <= max ]",
          "literals": [],
          "methodName": "between:and:",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        },
        "min:": {
          "src": "min: aMagnitude\n    \"Returns the least object between the receiver and aMagnitude\"\n    ^self < aMagnitude ifTrue: [ self ]\n    \t    \t      ifFalse: [ aMagnitude ]",
          "literals": [],
          "methodName": "min:",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        },
        "<": {
          "src": "< aMagnitude\n    \"Answer whether the receiver is less than aMagnitude\"\n    self subclassResponsibility",
          "literals": [],
          "methodName": "<",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        },
        ">": {
          "src": "> aMagnitude\n    \"Answer whether the receiver is greater than aMagnitude\"\n    ^aMagnitude < self",
          "literals": [],
          "methodName": ">",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        },
        ">=": {
          "src": ">= aMagnitude\n    \"Answer whether the receiver is greater than or equal to aMagnitude\"\n    ^(self < aMagnitude) not",
          "literals": [],
          "methodName": ">=",
          "className": "Magnitude",
          "category": "misc methods",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "Date",
          "instance_methods": {
            "indexOfMonth:": {
              "src": "indexOfMonth: monthName\n    \"Answer the index of the month corresponding to the given name\"\n    ^MonthNameDict\n\tat: monthName asLowercase asSymbol",
              "literals": [],
              "methodName": "indexOfMonth:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "utcToday": {
              "src": "utcToday\n    \"Answer a Date denoting the current date in Coordinated Universal\n     Time (UTC)\"\n    ^self fromSeconds: Time utcSecondClock",
              "literals": [],
              "methodName": "utcToday",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysFromBaseDay": {
              "src": "daysFromBaseDay\n    \"Answer the days passed since 1/1/1901\"\n    ^days",
              "literals": [],
              "methodName": "daysFromBaseDay",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayName": {
              "src": "dayName\n    \"Answer the day of week of the receiver as a Symbol\"\n    ^Date nameOfDay: ((self days + 1) \\\\ 7 + 1)",
              "literals": [],
              "methodName": "dayName",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysUntilMonth:year:": {
              "src": "daysUntilMonth: monthIndex year: yearInteger\n    \"Private - Answer the number of days between Jan 1, 1901, and the\n     hypotetical 0th day in the given month, for the given year\"\n    | i j |\n    j := (monthIndex - 14) quo: 12.\n    i := j + yearInteger.\n\t\n    \"Calculate Julian day via Fliegal & Van Flandern method\n     -- ACM Algorithm 289. I have to subtract 2415386 to correct for Smalltalk\n     epoch, and I merged that constant in the one (32074) in their formula.\"\n    ^((i + 4800) * 1461 // 4)\n\t + ((monthIndex - 2 - (j * 12)) * 367 // 12)\n\t - ((i + 4900) // 100 * 3 // 4)\n\t - 2447461",
              "literals": [],
              "methodName": "daysUntilMonth:year:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayOfYear": {
              "src": "dayOfYear\n    \"Answer the days passed since 31/12 of last year; e.g. New Year's Day is 1\"\n    ^self days - (Date yearAsDays: self year)",
              "literals": [],
              "methodName": "dayOfYear",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "year": {
              "src": "year\n    \"Answer the year represented by the receiver\"\n    ^year",
              "literals": [],
              "methodName": "year",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "newDay:month:year:": {
              "src": "newDay: day month: monthName year: yearInteger\n    \"Answer a Date denoting the dayCount day of the given (named)\n     month and year\"\n    ^self new\n\tsetDay: day\n\tmonthIndex: (self indexOfMonth: monthName)\n\tyear: yearInteger",
              "literals": [],
              "methodName": "newDay:month:year:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "subtractDate:": {
              "src": "subtractDate: aDate\n    \"Answer the number of days between aDate and the receiver (negative\n     if the receiver is before aDate)\"\n    ^self days - aDate days",
              "literals": [],
              "methodName": "subtractDate:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysLeftInMonth": {
              "src": "daysLeftInMonth\n    \"Answer the days to the end of the month represented by the receiver\"\n    ^(Date daysInMonthIndex: month forYear: year) - day",
              "literals": [],
              "methodName": "daysLeftInMonth",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayOfWeekName": {
              "src": "dayOfWeekName\n    \"Answer the day of week of the receiver as a Symbol\"\n    ^Date nameOfDay: ((self days + 1) \\\\ 7 + 1)",
              "literals": [],
              "methodName": "dayOfWeekName",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "initDayNameDict": {
              "src": "initDayNameDict\n    \"Initialize the DayNameDict to the names of the days\"\n    | dayNames |\n    dayNames := #(\n    \t    \t (#monday #mon)\t\"1\"\n    \t    \t (#tuesday #tue) \"2\"\n    \t    \t (#wednesday #wed) \"3\"\n    \t    \t (#thursday #thu) \"4\"\n    \t    \t (#friday #fri)\t\"5\"\n    \t    \t (#saturday #sat) \"6\"\n    \t    \t (#sunday #sun)\t\"7\"\n    \t    \t).\n    dayNames keysAndValuesDo: [ :dayIndex :names |\n\tnames do:\n\t    [ :name | DayNameDict at: name put: dayIndex ]\n    ].",
              "literals": [],
              "methodName": "initDayNameDict",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "readFrom:": {
              "src": "readFrom: aStream\n    \"Parse an instance of the receiver from aStream\"\n    | t1 t2 t3 ch month ws |\n    1 to: 3 do: [ :i |\n        ws := WriteStream on: (String new: 10).\n\t[ aStream atEnd not and: [\n\t     (ch := aStream next) isAlphaNumeric not ]] whileTrue.\n\n\tch isAlphaNumeric ifTrue: [\n\t    [ ws nextPut: ch. aStream atEnd not and: [\n\t\t(ch := aStream next) isAlphaNumeric ]] whileTrue.\n\t].\n\t\n\tt1 := t2. t2 := t3. t3 := ws contents.\n\n\t(t3 at: 1) isDigit\n\t    ifTrue: [ t3 := t3 asNumber ]\n\t    ifFalse: [\n\t        month := i.\n\t        t3 := self indexOfMonth: t3 asSymbol.\n\t    ].\n\n\t(i = 2 and: [ month = 1 and: [ t3 > 31 ]])  \"January 2000\" \n\t    ifTrue: [ ^self newDay: 1 monthIndex: t2 year: t3 ].\n    ].\n\n    month isNil ifTrue: [\n\tt1 > 31\n\t    ifTrue: [ ^self newDay: t3 monthIndex: t2 year: t1 ]. \"YMD\"\n\t^t1 <= 12\n\t    ifTrue: [ ^self newDay: t2 monthIndex: t1 year: t3 ]  \"MDY\"\n\t    ifFalse: [ ^self newDay: t1 monthIndex: t2 year: t3 ] \"DMY\"\n    ].\n\n    ^month = 1 \n\tifTrue: [ self newDay: t2 monthIndex: t1 year: t3 ] \"MDY\"\n\tifFalse: [ self newDay: t1 monthIndex: t2 year: t3 ] \"DMY\"",
              "literals": [],
              "methodName": "readFrom:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "subtractDays:": {
              "src": "subtractDays: dayCount\n    \"Answer a new Date pointing dayCount before the receiver\"\n    ^Date fromDays: self days - dayCount",
              "literals": [],
              "methodName": "subtractDays:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "day": {
              "src": "day\n    \"Answer the day represented by the receiver\"\n    ^day",
              "literals": [],
              "methodName": "day",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "year:day:hour:minute:second:": {
              "src": "year: y day: d hour: h minute: min second: s\n    \"Answer a Date denoting the d-th day of the given year\"\n    ^self new\n\tsetDays: (self yearAsDays: y) + d",
              "literals": [],
              "methodName": "year:day:hour:minute:second:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "monthName": {
              "src": "monthName\n    \"Answer the name of the month represented by the receiver\"\n    ^Date nameOfMonth: self month",
              "literals": [],
              "methodName": "monthName",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "newDay:year:": {
              "src": "newDay: dayCount year: yearInteger\n    \"Answer a Date denoting the dayCount day of the yearInteger year\"\n    ^self new setDays:\n\tdayCount + (self yearAsDays: yearInteger)",
              "literals": [],
              "methodName": "newDay:year:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dateAndTimeNow": {
              "src": "dateAndTimeNow\n    \"Answer an array containing the current date and time\"\n    | secondClock utcSecondClock |\n    secondClock := Time secondClock.\n    utcSecondClock := Time utcSecondClock.\n    ^DateTime\n\tfromDays: secondClock // 86400\n\tseconds: secondClock \\\\ 86400\n\toffset: (Duration fromSeconds: secondClock - utcSecondClock)",
              "literals": [],
              "methodName": "dateAndTimeNow",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "fromJulian:": {
              "src": "fromJulian: jd\n    \"Answer a Date denoting the jd-th day in the astronomical Julian calendar.\"\n    ^self new setDays: jd - 2415386",
              "literals": [],
              "methodName": "fromJulian:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "nameOfMonth:": {
              "src": "nameOfMonth: monthIndex\n    \"Answer the name of the month corresponding to the given index\"\n    ^#(#January #February  #March\n       #April   #May       #June\n       #July    #August    #September\n       #October #November  #December) at: monthIndex",
              "literals": [],
              "methodName": "nameOfMonth:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "month": {
              "src": "month\n    \"Answer the month represented by the receiver\"\n    ^month",
              "literals": [],
              "methodName": "month",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation for the receiver on aStream\"\n    aStream\n\tprint: self day;\n\tnextPut: $-;\n\tnextPutAll: (Date shortNameOfMonth: self month);\n\tnextPut: $-;\n\tprint: self year",
              "literals": [],
              "methodName": "printOn:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayOfMonth": {
              "src": "dayOfMonth\n    \"Answer the day represented by the receiver (same as #day)\"\n    ^day",
              "literals": [],
              "methodName": "dayOfMonth",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayOfWeekAbbreviation": {
              "src": "dayOfWeekAbbreviation\n    \"Answer the day of week of the receiver as a Symbol\"\n    ^Date abbreviationOfDay: ((self days + 1) \\\\ 7 + 1)",
              "literals": [],
              "methodName": "dayOfWeekAbbreviation",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "abbreviationOfDay:": {
              "src": "abbreviationOfDay: dayIndex\n    \"Answer the abbreviated name of the day of week corresponding to the given\n     index\"\n    ^#(#Mon #Tue #Wed #Thu #Fri #Sat #Sun) at: dayIndex",
              "literals": [],
              "methodName": "abbreviationOfDay:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysInYear:": {
              "src": "daysInYear: i\n    \"Answer the number of days in the given year\"\n    ^((i + 4800) * 1461 // 4) - ((i + 4900) // 100 * 3 // 4)\n    -((i + 4799) * 1461 // 4) + ((i + 4899) // 100 * 3 // 4)",
              "literals": [],
              "methodName": "daysInYear:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "<": {
              "src": "< aDate\n    \"Answer whether the receiver indicates a date preceding aDate\"\n    ^self days < aDate days",
              "literals": [],
              "methodName": "<",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysInMonthIndex:forYear:": {
              "src": "daysInMonthIndex: monthIndex forYear: yearInteger\n    \"Private - Answer the number of days in the given (indexed) month,\n     for the given year\"\n\n    monthIndex = 2\n    \tifTrue: [ ^(self daysInYear: yearInteger) - 337 ].\n\n    ^#[ 31 0 31\t\t\t\t\"Jan Feb Mar\"\n\t30 31 30\t\t\t\"Apr May Jun\"\n\t31 31 30\t\t\t\"Jul Aug Sep\"\n\t31 30 31] at: monthIndex\t\"Oct Nov Dec\"",
              "literals": [],
              "methodName": "daysInMonthIndex:forYear:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "=": {
              "src": "= aDate\n    \"Answer whether the receiver indicates the same date as aDate\"\n    ^(aDate class == self class) and: [ aDate days = self days ]",
              "literals": [],
              "methodName": "=",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysLeftInYear": {
              "src": "daysLeftInYear\n    \"Answer the days to the end of the year represented by the receiver\"\n    ^(Date yearAsDays: self year + 1) - self days",
              "literals": [],
              "methodName": "daysLeftInYear",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "nameOfDay:": {
              "src": "nameOfDay: dayIndex\n    \"Answer the name of the day of week corresponding to the given index\"\n    ^#(#Monday #Tuesday #Wednesday #Thursday #Friday #Saturday #Sunday)\n\tat: dayIndex",
              "literals": [],
              "methodName": "nameOfDay:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "hash": {
              "src": "hash\n    \"Answer an hash value for the receievr\"\n    ^self days",
              "literals": [],
              "methodName": "hash",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "utcDateAndTimeNow": {
              "src": "utcDateAndTimeNow\n    \"Answer an array containing the current date and time in Coordinated\n     Universal Time (UTC)\"\n    | utcSecondClock |\n    utcSecondClock := Time utcSecondClock.\n    ^DateTime\n\tfromDays: utcSecondClock // 86400\n\tseconds: utcSecondClock \\\\ 86400\n\toffset: Duration zero",
              "literals": [],
              "methodName": "utcDateAndTimeNow",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "storeOn:": {
              "src": "storeOn: aStream\n    \"Store on aStream Smalltalk code compiling to the receiver\"\n\n    aStream\n\tnextPut: $(;\n\tnextPutAll: self classNameString;\n\tnextPutAll: ' newDay: ';\n\tstore: self day;\n\tnextPutAll: ' monthIndex: ';\n\tstore: self month;\n\tnextPutAll: ' year: ';\n\tstore: self year;\n\tnextPut: $)",
              "literals": [],
              "methodName": "storeOn:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "year:month:day:hour:minute:second:": {
              "src": "year: y month: m day: d hour: h minute: min second: s\n    \"Answer a Date denoting the d-th day of the given (as a number)\n     month and year\"\n    ^self new\n\tsetDay: d\n\tmonthIndex: m\n\tyear: y",
              "literals": [],
              "methodName": "year:month:day:hour:minute:second:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "yearAsDays:": {
              "src": "yearAsDays: i\n    \"Private - Returns the number of days between Jan 1, 1901\n     and Jan 0th of the given year yearInteger\"\n\t\n    \"Calculate Julian day via Fliegal & Van Flandern method\n     -- ACM Algorithm 289. I have to subtract 2415387 to correct for Smalltalk\n     epoch, and I merged that constant in the one (32074) in their formula.\"\n    ^((i + 4799) * 1461 // 4)\n\t - ((i + 4899) // 100 * 3 // 4)\n\t - 2447125",
              "literals": [],
              "methodName": "yearAsDays:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayOfWeek:": {
              "src": "dayOfWeek: dayName\n    \"Answer the index of the day of week corresponding to the given name\"\n    ^DayNameDict at: dayName asLowercase asSymbol",
              "literals": [],
              "methodName": "dayOfWeek:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "dayOfWeek": {
              "src": "dayOfWeek\n    \"Answer the day of week of the receiver. 1 = Monday, 7 = Sunday\"\n    ^(self days + 1) \\\\ 7 + 1",
              "literals": [],
              "methodName": "dayOfWeek",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "fromSeconds:": {
              "src": "fromSeconds: time\n    \"Answer a Date denoting the date time seconds past Jan 1st, 1901\"\n    | days |\n    days := time // (24 * 60 * 60).\n    ^self new setDays: days",
              "literals": [],
              "methodName": "fromSeconds:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "asSeconds": {
              "src": "asSeconds\n    \"Answer the date as the number of seconds from 1/1/1901.\"\n    ^self days * 86400",
              "literals": [],
              "methodName": "asSeconds",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "today": {
              "src": "today\n    \"Answer a Date denoting the current date in local time\"\n    ^self fromSeconds: Time secondClock",
              "literals": [],
              "methodName": "today",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "setDays:": {
              "src": "setDays: dayCount\n    \"Private - Compute the date parts from the given dayCount and initialize\n     the receiver\"\n\n    \"Fliegal and Van Flandern's methods for computing y/m/d from Julian.\n     The original algorithm starts by summing 68569 to the Julian day --\n     I sum 2483955 to adjust for smalltalk epoch.\"\n\n    | julian n |\n    days := dayCount.\n    julian := days + 2483955.\n    n := (4 * julian) // 146097.\n    julian := julian - ((146097 * n + 3) // 4).\n    year := (4000 * (julian + 1)) // 1461001.\n    julian := julian - ((1461 * year) // 4) + 31.\n    month := (80 * julian) // 2447.\n    day := julian - ((2447 * month) // 80).\n    julian := month // 11.\n    month := month + 2 - (12 * julian).\n    year := (100 * (n - 49)) + year + julian.",
              "literals": [],
              "methodName": "setDays:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "newDay:monthIndex:year:": {
              "src": "newDay: day monthIndex: monthIndex year: yearInteger\n    \"Answer a Date denoting the dayCount day of the given (as a number)\n     month and year\"\n    ^self new\n\tsetDay: day\n\tmonthIndex: monthIndex\n\tyear: yearInteger",
              "literals": [],
              "methodName": "newDay:monthIndex:year:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "firstDayOfMonth": {
              "src": "firstDayOfMonth\n    \"Answer a Date representing the first day of the month represented by the\n     receiver\"\n    ^self subtractDays: self dayOfMonth - 1",
              "literals": [],
              "methodName": "firstDayOfMonth",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "shortNameOfMonth:": {
              "src": "shortNameOfMonth: monthIndex\n    \"Answer the name of the month corresponding to the given index\"\n    ^#(#Jan #Feb #Mar #Apr #May #Jun #Jul #Aug #Sep #Oct #Nov #Dec)\n\tat: monthIndex",
              "literals": [],
              "methodName": "shortNameOfMonth:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "isLeapYear": {
              "src": "isLeapYear\n    \"Answer whether the receiver refers to a date in a leap year.\"\n    ^self daysInYear == 366",
              "literals": [],
              "methodName": "isLeapYear",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "monthAbbreviation": {
              "src": "monthAbbreviation\n    \"Answer the abbreviated name of the month represented by the receiver\"\n    ^Date shortNameOfMonth: self month",
              "literals": [],
              "methodName": "monthAbbreviation",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "lastDayOfMonth": {
              "src": "lastDayOfMonth\n    \"Answer a Date representing the last day of the month represented by the\n     receiver\"\n    ^self addDays: self daysLeftInMonth",
              "literals": [],
              "methodName": "lastDayOfMonth",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysInMonth:forYear:": {
              "src": "daysInMonth: monthName forYear: yearInteger\n    \"Answer the number of days in the given (named) month for the given year\"\n    | monthIndex |\n    monthIndex := self indexOfMonth: monthName.\n    ^self daysInMonthIndex: monthIndex forYear: yearInteger",
              "literals": [],
              "methodName": "daysInMonth:forYear:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysInMonth": {
              "src": "daysInMonth\n    \"Answer the days in the month represented by the receiver\"\n    ^Date daysInMonthIndex: month forYear: year",
              "literals": [],
              "methodName": "daysInMonth",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "fromDays:": {
              "src": "fromDays: dayCount\n    \"Answer a Date denoting dayCount days past 1/1/1901\"\n    ^self new setDays: dayCount",
              "literals": [],
              "methodName": "fromDays:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "addDays:": {
              "src": "addDays: dayCount\n    \"Answer a new Date pointing dayCount past the receiver\"\n    ^Date fromDays: self days + dayCount",
              "literals": [],
              "methodName": "addDays:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "setDay:monthIndex:year:": {
              "src": "setDay: dayOfMonth monthIndex: monthIndex year: yearInteger\n    \"Private - Set the receiver to the given date parts\"\n\n    days := dayOfMonth + (Date daysUntilMonth: monthIndex year: yearInteger).\n    dayOfMonth < 1\n\tifTrue: [ ^self setDays: days ].\n    dayOfMonth > (Date daysInMonthIndex: monthIndex forYear: yearInteger)\n\tifTrue: [ ^self setDays: days ].\n\n    day := dayOfMonth.\n    month := monthIndex.\n    year := yearInteger.",
              "literals": [],
              "methodName": "setDay:monthIndex:year:",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "shortMonthName": {
              "src": "shortMonthName\n    \"Answer the abbreviated name of the month represented by the receiver\"\n    ^Date shortNameOfMonth: self month",
              "literals": [],
              "methodName": "shortMonthName",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "initMonthNameDict": {
              "src": "initMonthNameDict\n    \"Initialize the MonthNameDict to the names of the months\"\n    | monthNames |\n    monthNames := #(\n    \t    \t (#january   #jan)\t\"1\"\n    \t    \t (#february  #feb)\t\"2\"\n    \t    \t (#march     #mar)    \t\"3\"\n    \t    \t (#april     #apr)    \t\"4\"\n    \t    \t (#may)\t    \t    \t\"5\"\n    \t    \t (#june\t     #jun)    \t\"6\"\n    \t    \t (#july\t     #jul)\t\"7\"\n    \t    \t (#august    #aug)\t\"8\"\n    \t    \t (#september #sep)\t\"9\"\n    \t    \t (#october   #oct)\t\"10\"\n    \t    \t (#november  #nov)\t\"11\"\n    \t    \t (#december  #dec)\t\"12\"\n    \t    \t).\n    monthNames doWithIndex: [ :names :dayIndex |\n\tnames do:\n\t    [ :name | MonthNameDict at: name put: dayIndex ]\n    ].",
              "literals": [],
              "methodName": "initMonthNameDict",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "days": {
              "src": "days\n    \"Private - Same as daysFromBaseDay\"\n    ^days",
              "literals": [],
              "methodName": "days",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "initialize": {
              "src": "initialize\n    \"Initialize the receiver\"\n\n    \"28 = 7 days*2 keys each day, multiplied by 2 to make hashing effective.\n     48 = 12 months*2 keys each month, multiplied by 2 for the same reason.\"\n    DayNameDict := IdentityDictionary new: 28.\n    MonthNameDict := IdentityDictionary new: 48.\n    self initDayNameDict.\n    self initMonthNameDict",
              "literals": [],
              "methodName": "initialize",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            },
            "daysInYear": {
              "src": "daysInYear\n    \"Answer the days in the year represented by the receiver\"\n    ^Date daysInYear: self year",
              "literals": [],
              "methodName": "daysInYear",
              "className": "Date",
              "category": "private methods",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": [
            {
              "className": "DateTime",
              "instance_methods": {
                "negated": {
                  "src": "negated\n    \"Answer a Duration that is as long as the receiver, but with past and\n     future exchanged.\"\n    ^Duration fromSeconds: self asSeconds negated",
                  "literals": [],
                  "methodName": "negated",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "storeOn:": {
                  "src": "storeOn: aStream\n    \"Store on aStream Smalltalk code compiling to the receiver\"\n\n    self notYetImplemented",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asLocal": {
                  "src": "asLocal\n    \"Answer the receiver, since DateTime objects store themselves\n     in Local time\"\n    ^self",
                  "literals": [],
                  "methodName": "asLocal",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "year:month:day:hour:minute:second:": {
                  "src": "year: y month: m day: d hour: h minute: min second: s\n    \"Answer a DateTime denoting the d-th day of the given (as a number)\n     month and year, setting the time part to the given hour, minute,\n     and second\"\n    ^(super year: y month: m day: d hour: h minute: min second: s)\n\tsetSeconds: (h * 60 + min) * 60 + s",
                  "literals": [],
                  "methodName": "year:month:day:hour:minute:second:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "hour12": {
                  "src": "hour12\n    \"Answer the hour in a 12-hour clock\"\n    | h | \n    h := self hour \\\\ 12.\n    ^h = 0 ifTrue: [ 12 ] ifFalse: [ h ]",
                  "literals": [],
                  "methodName": "hour12",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "second": {
                  "src": "second\n    \"Answer the month represented by the receiver\"\n    ^seconds \\\\ 60",
                  "literals": [],
                  "methodName": "second",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "zero": {
                  "src": "zero\n    \"Answer a duration of zero seconds.\"\n    ^Zero",
                  "literals": [],
                  "methodName": "zero",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "seconds": {
                  "src": "seconds\n    ^seconds",
                  "literals": [],
                  "methodName": "seconds",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "negative": {
                  "src": "negative\n    \"Answer whether the receiver is in the past.\"\n    ^self asSeconds < 0",
                  "literals": [],
                  "methodName": "negative",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "dayOfWeek": {
                  "src": "dayOfWeek\n    \"Answer the day of week of the receiver. Unlike Dates, DateAndTimes\n     have 1 = Sunday, 7 = Saturday\"\n    ^#(2 3 4 5 6 7 1) at: super dayOfWeek",
                  "literals": [],
                  "methodName": "dayOfWeek",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "setSeconds:": {
                  "src": "setSeconds: secs\n    seconds := secs",
                  "literals": [],
                  "methodName": "setSeconds:",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "hour": {
                  "src": "hour\n    \"Answer the hour in a 24-hour clock\"\n    ^seconds // 3600",
                  "literals": [],
                  "methodName": "hour",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asSeconds": {
                  "src": "asSeconds\n    \"Answer the date as the number of seconds from 1/1/1901.\"\n    ^super asSeconds + seconds",
                  "literals": [],
                  "methodName": "asSeconds",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "now": {
                  "src": "now\n    \"Answer an instance of the receiver referring to the current\n     date and time.\"\n    ^self dateAndTimeNow",
                  "literals": [],
                  "methodName": "now",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "year:month:day:hour:minute:second:offset:": {
                  "src": "year: y month: m day: d hour: h minute: min second: s offset: ofs\n    \"Answer a DateTime denoting the d-th day of the given (as a number)\n     month and year. Set the offset field to ofs (a Duration), and\n     the the time part to the given hour, minute, and second\"\n    ^(super year: y month: m day: d hour: h minute: min second: s)\n\tsetSeconds: (h * 60 + min) * 60 + s;\n\tsetOffset: ofs",
                  "literals": [],
                  "methodName": "year:month:day:hour:minute:second:offset:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "readFrom:": {
                  "src": "readFrom: aStream\n    \"Parse an instance of the receiver from aStream\"\n    ^(super readFrom: aStream) + (Duration readFrom: aStream)",
                  "literals": [],
                  "methodName": "readFrom:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "setDays:": {
                  "src": "setDays: dayCount\n    \"Private - Compute the date parts from the given dayCount and initialize\n     the receiver\"\n\n    seconds := 0.\n    offset := Duration zero.\n    ^super setDays: dayCount",
                  "literals": [],
                  "methodName": "setDays:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asTime": {
                  "src": "asTime\n    \"Answer a Time referring to the same time (from midnight) as the receiver\"\n    ^Time fromSeconds: seconds",
                  "literals": [],
                  "methodName": "asTime",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "year:day:hour:minute:second:": {
                  "src": "year: y day: d hour: h minute: min second: s\n    \"Answer a DateTime denoting the d-th day of the given year, and\n    setting the time part to the given hour, minute, and second\"\n    ^(super year: y day: d hour: h minute: min second: s)\n\tsetSeconds: (h * 60 + min) * 60 + s",
                  "literals": [],
                  "methodName": "year:day:hour:minute:second:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asUTC": {
                  "src": "asUTC\n    \"Convert the receiver to UTC time, and answer a new DateTime object.\"\n    | newSecs |\n    newSecs := self seconds - self offset asSeconds.\n    ^newSecs < 0\n\tifTrue: [\n\t    DateTime\n\t\tfromDays: self days + offset days - 1\n\t\tseconds: newSecs + 86400\n\t\toffset: Duration zero\n\t]\n\tifFalse: [\n\t    DateTime\n\t\tfromDays: self days + offset days\n\t\tseconds: newSecs\n\t\toffset: Duration zero\n\t]",
                  "literals": [],
                  "methodName": "asUTC",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "days:hours:minutes:seconds:": {
                  "src": "days: d hours: h minutes: m seconds: s\n    \"Answer a duration of `d' days and the given number of hours,\n     minutes, and seconds.\"\n    ^self fromSeconds: ((d * 24 + h) * 60 + m) * 60 + s",
                  "literals": [],
                  "methodName": "days:hours:minutes:seconds:",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "offset": {
                  "src": "offset\n    \"Answer the receiver's offset from UTC to local time (e.g. +3600 seconds\n     for Central Europe Time, -3600*6 seconds for Eastern Standard Time).\n     The offset is expressed as a Duration\"\n    ^offset",
                  "literals": [],
                  "methodName": "offset",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "at:": {
                  "src": "at: anIndex\n    \"Since in the past timestamps were referred to as Arrays containing\n     a Date and a Time (in this order), this method provides access to\n     DateTime objects like if they were two-element Arrays.\"\n    anIndex = 1 ifTrue: [ ^self asDate ].\n    anIndex = 2 ifTrue: [ ^self asTime ].\n    SystemExceptions IndexOutOfRange signalOn: self withIndex: anIndex.",
                  "literals": [],
                  "methodName": "at:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "*": {
                  "src": "* factor\n    \"Answer a Duration that is `factor' times longer than the receiver\"\n    ^Duration fromSeconds: self asSeconds * factor",
                  "literals": [],
                  "methodName": "*",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "+": {
                  "src": "+ aDuration\n    \"Answer a Duration that is the sum of the receiver and aDuration's\n     lengths.\"\n    ^Duration fromSeconds: self asSeconds + aDuration asSeconds",
                  "literals": [],
                  "methodName": "+",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "positive": {
                  "src": "positive\n    \"Answer whether the receiver is a zero-second duration or is\n     in the future.\"\n    ^self asSeconds >= 0",
                  "literals": [],
                  "methodName": "positive",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "days:": {
                  "src": "days: d\n    \"Answer a duration of `d' days\"\n    ^self fromSeconds: d * 86400",
                  "literals": [],
                  "methodName": "days:",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "-": {
                  "src": "- aDuration\n    \"Answer a Duration that is the difference of the receiver and aDuration's\n     lengths.\"\n    ^Duration fromSeconds: self asSeconds - aDuration asSeconds",
                  "literals": [],
                  "methodName": "-",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "hour24": {
                  "src": "hour24\n    \"Answer the hour in a 24-hour clock\"\n    ^self hour",
                  "literals": [],
                  "methodName": "hour24",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "meridianAbbreviation": {
                  "src": "meridianAbbreviation\n    \"Answer either #AM (for anti-meridian) or #PM (for post-meridian)\"\n    ^self hour < 12 ifTrue: [ #AM ] ifFalse: [ #PM ]",
                  "literals": [],
                  "methodName": "meridianAbbreviation",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "fromDays:seconds:offset:": {
                  "src": "fromDays: days seconds: secs offset: unused\n    \"Answer a duration of `d' days and `secs' seconds.  The last\n     parameter is unused; this message is available for interoperability\n     with the DateTime class.\"\n    ^self fromSeconds: days * 86400 + secs",
                  "literals": [],
                  "methodName": "fromDays:seconds:offset:",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "minute": {
                  "src": "minute\n    \"Answer the minute\"\n    ^(seconds // 60) \\\\ 60",
                  "literals": [],
                  "methodName": "minute",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "/": {
                  "src": "/ factorOrDuration\n    \"If the parameter is a Duration, answer the ratio between the receiver\n     and factorOrDuration.  Else divide the receiver by factorOrDuration (a\n     Number) and answer a new Duration that is correspondingly shorter.\"\n    ^factorOrDuration isNumber\n\tifFalse: [ self asSeconds / factorOrDuration asSeconds ]\n\tifTrue: [ Duration fromSeconds: self asSeconds / factorOrDuration ]",
                  "literals": [],
                  "methodName": "/",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "clockPrecision": {
                  "src": "clockPrecision\n    ^ClockPrecision",
                  "literals": [],
                  "methodName": "clockPrecision",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "offset:": {
                  "src": "offset: anOffset\n    \"Answer a copy of the receiver with the offset from UTC to local time\n     changed to anOffset (a Duration).\"\n    anOffset = offset ifTrue: [ ^self ].\n    ^self copy setOffset: anOffset; yourself",
                  "literals": [],
                  "methodName": "offset:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "timeZoneName": {
                  "src": "timeZoneName\n    \"Answer the time zone name for the receiver (currently, it is\n     simply `GMT +xxxx', where `xxxx' is the receiver's\n     #timeZoneAbbreviation).\"\n    ^'GMT ', self timeZoneAbbreviation",
                  "literals": [],
                  "methodName": "timeZoneName",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "abs": {
                  "src": "abs\n    \"Answer a Duration that is as long as the receiver, but always in\n     the future.\"\n    ^Duration fromSeconds: self asSeconds abs",
                  "literals": [],
                  "methodName": "abs",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream\n    \"Print a represention of the receiver on aStream.\"\n    self negative ifTrue: [ aStream nextPut: $-; print: self negated. ^self ].\n    aStream\n\tprint: self days;\n\tnextPut: $:;\n\tnext: (self hours < 10 ifTrue: [ 1 ] ifFalse: [ 0 ]) put: $0;\n\tprint: self hours;\n\tnextPut: $:;\n\tnext: (self minutes < 10 ifTrue: [ 1 ] ifFalse: [ 0 ]) put: $0;\n\tprint: self minutes;\n\tnextPut: $:;\n\tnext: (self seconds < 10 ifTrue: [ 1 ] ifFalse: [ 0 ]) put: $0;\n\tprint: self seconds",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "setDay:monthIndex:year:": {
                  "src": "setDay: dayOfMonth monthIndex: monthIndex year: yearInteger\n    \"Private - Set the receiver to the given date parts\"\n\n    seconds := 0.\n    offset := Duration zero.\n    ^super setDay: dayOfMonth monthIndex: monthIndex year: yearInteger",
                  "literals": [],
                  "methodName": "setDay:monthIndex:year:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "setOffset:": {
                  "src": "setOffset: offsetDuration\n    offset := offsetDuration",
                  "literals": [],
                  "methodName": "setOffset:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "year:day:hour:minute:second:offset:": {
                  "src": "year: y day: d hour: h minute: min second: s offset: ofs\n    \"Answer a DateTime denoting the d-th day of the given year.\n     Set the offset field to ofs (a Duration), and the time part\n     to the given hour, minute, and second\"\n    ^(super year: y day: d hour: h minute: min second: s)\n\tsetSeconds: (h * 60 + min) * 60 + s;\n\tsetOffset: ofs",
                  "literals": [],
                  "methodName": "year:day:hour:minute:second:offset:",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "timeZoneAbbreviation": {
                  "src": "timeZoneAbbreviation\n    \"Answer an abbreviated indication of the receiver's offset, expressed\n     as `shhmm', where `hh' is the number of hours and `mm' is the number\n     of minutes between UTC and local time, and `s' can be `+' for the\n     Eastern hemisphere and `-' for the Western hemisphere.\"\n    ^String\n\twith: (self offset positive ifTrue: [ $+ ] ifFalse: [ $- ])\n\twith: (self offset hour   // 10) digitValue\n\twith: (self offset hour   \\\\ 10) digitValue\n\twith: (self offset minute // 10) digitValue\n\twith: (self offset minute \\\\ 10) digitValue",
                  "literals": [],
                  "methodName": "timeZoneAbbreviation",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "days": {
                  "src": "days\n    \"Answer the number of days in the receiver\"\n    ^self asSeconds quo: 86400",
                  "literals": [],
                  "methodName": "days",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "initialize": {
                  "src": "initialize\n    \"Initialize the receiver's instance variables\"\n    Zero := self new",
                  "literals": [],
                  "methodName": "initialize",
                  "className": "Duration",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asDate": {
                  "src": "asDate\n    \"Answer a Date referring to the same day as the receiver\"\n    ^Date fromDays: self days",
                  "literals": [],
                  "methodName": "asDate",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "<": {
                  "src": "< aDateTime\n    \"Answer whether the receiver indicates a date preceding aDate\"\n    self offset = aDateTime offset ifFalse: [ ^self asUTC < aDateTime asUTC ].\n    ^super < aDateTime\n\tor: [ super = aDateTime and: [ seconds < aDateTime seconds ] ]",
                  "literals": [],
                  "methodName": "<",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "=": {
                  "src": "= aDateTime\n    \"Answer whether the receiver indicates the same date as aDate\"\n    self class == aDateTime class ifFalse: [ ^false ].\n    self offset = aDateTime offset ifFalse: [ ^self asUTC = aDateTime asUTC ].\n    ^super = aDateTime and: [ seconds = aDateTime seconds ]",
                  "literals": [],
                  "methodName": "=",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "hash": {
                  "src": "hash\n    \"Answer an hash value for the receievr\"\n    ^super hash * 37 + (self seconds - self offset seconds)",
                  "literals": [],
                  "methodName": "hash",
                  "className": "DateTime",
                  "category": "<unknown>",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            }
          ]
        },
        {
          "className": "LookupKey",
          "instance_methods": {
            "storeOn:": {
              "src": "storeOn: aStream\n    \"Put on aStream some Smalltalk code compiling to the receiver\"\n    aStream nextPutAll: '(LookupKey key: '.\n    self key storeOn: aStream.\n    aStream nextPut: $)",
              "literals": [],
              "methodName": "storeOn:",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Put on aStream a representation of the receiver\"\n    self key printOn: aStream.",
              "literals": [],
              "methodName": "printOn:",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            },
            "key:": {
              "src": "key: aKey\n    \"Set the receiver's key to aKey\"\n    key := aKey.",
              "literals": [],
              "methodName": "key:",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            },
            "<": {
              "src": "< aLookupKey\n    \"Answer whether the receiver's key is less than aLookupKey's\"\n    ^self key < aLookupKey key",
              "literals": [],
              "methodName": "<",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            },
            "=": {
              "src": "= aLookupKey\n    \"Answer whether the receiver's key and value are the same as\n     aLookupKey's, or false if aLookupKey is not an instance of\n     the receiver\"\n    ^self class == aLookupKey class and: [ self key = aLookupKey key ]",
              "literals": [],
              "methodName": "=",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            },
            "key": {
              "src": "key\n    \"Answer the receiver's key\"\n    ^key",
              "literals": [],
              "methodName": "key",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            },
            "hash": {
              "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^key hash",
              "literals": [],
              "methodName": "hash",
              "className": "LookupKey",
              "category": "storing",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": [
            {
              "className": "Association",
              "instance_methods": {
                "storeOn:": {
                  "src": "storeOn: aStream\n    \"Put on aStream some Smalltalk code compiling to the receiver\"\n    aStream nextPutAll: '(Association key: '.\n    self key storeOn: aStream.\n    aStream nextPutAll: ' value: '.\n    self value storeOn: aStream.\n    aStream nextPut: $)",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream\n    \"Put on aStream a representation of the receiver\"\n    self key printOn: aStream.\n    aStream nextPutAll: '->'.\n    self value printOn: aStream",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                },
                "key:value:": {
                  "src": "key: aKey value: aValue\n    \"Set the association's key to aKey, and its value to aValue\"\n    key := aKey.\n    value := aValue",
                  "literals": [],
                  "methodName": "key:value:",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                },
                "value:": {
                  "src": "value: aValue\n    \"Set the association's value to aValue\"\n    value := aValue",
                  "literals": [],
                  "methodName": "value:",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                },
                "value": {
                  "src": "value\n    \"Answer the association's value\"\n    ^value",
                  "literals": [],
                  "methodName": "value",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                },
                "=": {
                  "src": "= anAssociation\n    \"Answer whether the association's key and value are the same as\n     anAssociation's, or false if anAssociation is not an Association\"\n    ^self class == anAssociation class and: [\n\tself key = anAssociation key and: [ self value = anAssociation value ] ]",
                  "literals": [],
                  "methodName": "=",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                },
                "hash": {
                  "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^key hash bitXor: value hash",
                  "literals": [],
                  "methodName": "hash",
                  "className": "Association",
                  "category": "storing",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            }
          ]
        },
        {
          "className": "Number",
          "instance_methods": {
            "asScaledDecimal:scale:": {
              "src": "asScaledDecimal: denDigits scale: n\n    \"Answer the receiver, divided by 10^denDigits and converted to\n     a ScaledDecimal object.\"\n    ^ScaledDecimal\n\tnewFromNumber: (self asFraction *\n\t  (10 raisedToInteger: denDigits))\n\tscale: n",
              "literals": [],
              "methodName": "asScaledDecimal:scale:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "\\\\": {
              "src": "\\\\ aNumber\n    \"Return the remainder of dividing the receiver by aNumber with\n    truncation towards negative infinity.  Raise a ZeroDivide\n    exception if aNumber is zero\"\n\n    aNumber = 0 ifTrue: [ self zeroDivide ].\n    ^self negative == aNumber negative\n\tifTrue: [ self rem: aNumber ]\n\tifFalse: [ (self rem: aNumber) + aNumber ]",
              "literals": [],
              "methodName": "\\\\",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "negated": {
              "src": "negated\n    \"Answer the negated of the receiver\"\n    ^self zero - self",
              "literals": [],
              "methodName": "negated",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "ln": {
              "src": "ln\n    \"return log base e of the receiver\"\n    ^self asFloatD ln",
              "literals": [],
              "methodName": "ln",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "to:by:do:": {
              "src": "to: stop by: step do: aBlock\n    \"Evaluate aBlock for each value in the interval going from the receiver\n     to stop with the given step. Compiled in-line for integer literal steps,\n     and for one-argument aBlocks without temporaries, and therefore\n     not overridable.\"\n    | i |\n    i := self.\n    step > step zero\n\tifTrue: [\n    \t    [ i <= stop ]\n\t    \twhileTrue: [ aBlock value: i.\n\t\t    \t     i := i + step ]\n    \t]\n\tifFalse: [\n    \t    [ i >= stop ]\n\t    \twhileTrue: [ aBlock value: i.\n\t\t    \t     i := i + step ]\n\t].\n    ^stop",
              "literals": [],
              "methodName": "to:by:do:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "cos": {
              "src": "cos\n    \"return the cosine of the receiver\"\n    ^self asFloatD cos",
              "literals": [],
              "methodName": "cos",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "sign": {
              "src": "sign\n    \"Returns the sign of the receiver.\"\n    self < self zero ifTrue: [ ^-1 ].\n    self > self zero ifTrue: [ ^1 ].\n    ^0",
              "literals": [],
              "methodName": "sign",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "arithmeticError:": {
              "src": "arithmeticError: message\n    self error: message",
              "literals": [],
              "methodName": "arithmeticError:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "isNaN": {
              "src": "isNaN\n    \"Answer whether the receiver is a Not-A-Number.  Most numeric\n     classes don't handle nans, so the default is to answer false\n     rather than calling #subclassResponsibility.\"\n    ^false",
              "literals": [],
              "methodName": "isNaN",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "zero": {
              "src": "zero\n    \"Coerce 0 to the receiver's class. The default implementation works,\n     but is inefficient\"\n    ^self coerce: 0",
              "literals": [],
              "methodName": "zero",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "asFloatQ": {
              "src": "asFloatQ\n    self subclassResponsibility",
              "literals": [],
              "methodName": "asFloatQ",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryMultiplicationCoercing:": {
              "src": "retryMultiplicationCoercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling #*.\"\n\n\n    | selfGen aNumGen |\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen ifTrue: [ ^self * (self coerce: aNumber) ].\n    selfGen < aNumGen ifTrue: [ ^(aNumber coerce: self) * aNumber ].\n\n    self retryError",
              "literals": [],
              "methodName": "retryMultiplicationCoercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "arcTan": {
              "src": "arcTan\n    \"return the arc tangent of the receiver\"\n    ^self asFloatD arcTan",
              "literals": [],
              "methodName": "arcTan",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "sqrt": {
              "src": "sqrt\n    \"return the square root of the receiver\"\n    ^self asFloatD sqrt",
              "literals": [],
              "methodName": "sqrt",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "isNumber": {
              "src": "isNumber\n    ^true",
              "literals": [],
              "methodName": "isNumber",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryDivisionCoercing:": {
              "src": "retryDivisionCoercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling #/.\"\n\n    | selfGen aNumGen |\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen ifTrue: [ ^self / (self coerce: aNumber) ].\n    selfGen < aNumGen ifTrue: [ ^(aNumber coerce: self) / aNumber ].\n\n    self retryError",
              "literals": [],
              "methodName": "retryDivisionCoercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "readFrom:": {
              "src": "readFrom: aStream\n    \"Answer the number read from the rest of aStream, converted to an\n     instance of the receiver. If the receiver is number, the class of the\n     result is undefined -- but the result is good.\"\n    | value ch scale |\n    value := 0.\n    scale := (aStream peekFor: $-) ifTrue: [ -1 ] ifFalse: [ 1 ].\n\n    [ aStream atEnd ifTrue: [^self coerce: value].\n      (ch := aStream next) isDigit ] whileTrue: [\n\t value := ch digitValue * scale + (value * 10).\n    ].\n    ch = $. ifFalse: [aStream skip: -1. ^value].\n\n    [ aStream atEnd ifTrue: [^self coerce: value].\n      (ch := aStream next) isDigit ] whileTrue: [\n\t scale := scale / 10.\n\t value := ch digitValue * scale + value.\n    ].\n\n    aStream skip: -1.\n    ^self coerce: value",
              "literals": [],
              "methodName": "readFrom:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "min:": {
              "src": "min: aNumber\n    \"Redefined to ensure that a NaN is never answered.  Answer\n     the minimum between the receiver and aNumber.\"\n    self isNaN ifTrue: [ ^aNumber ].\n\n    \"< will return false if aNumber is a NaN, then self will\n     be answered\"\n    ^aNumber < self ifTrue: [ aNumber ] ifFalse: [ self ]",
              "literals": [],
              "methodName": "min:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "exp": {
              "src": "exp\n    \"return e raised to the receiver\"\n    ^self asFloatD exp",
              "literals": [],
              "methodName": "exp",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "raisedToInteger:": {
              "src": "raisedToInteger: anInteger\n    \"Return self raised to the anInteger-th power\"\n    | result y n |\n\n    \"Some special cases first\"\n    anInteger isInteger ifFalse: [ SystemExceptions WrongClass signalOn: anInteger mustBe: Integer ].\n    anInteger < 0 ifTrue: [ ^self reciprocal raisedToInteger: 0 - anInteger ].\n    anInteger = 0 ifTrue: [ ^self unity ].\n    anInteger = 1 ifTrue: [ ^self ].\n\n    result := self unity.\n    y := self.\n    n := anInteger.\n    [   (n bitAnd: 1) == 1 ifTrue: [ result := result * y ].\n\tn := n bitShift: -1. n > 0\n    ]   whileTrue: [ y := y * y ].\n\n    ^result",
              "literals": [],
              "methodName": "raisedToInteger:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "shallowCopy": {
              "src": "shallowCopy\n    \"Return the receiver - it's an immediate (immutable) object\"\n    ^self",
              "literals": [],
              "methodName": "shallowCopy",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "to:": {
              "src": "to: stop\n    \"Return an interval going from the receiver to stop by 1\"\n    ^Interval from: self to: stop",
              "literals": [],
              "methodName": "to:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "estimatedLog": {
              "src": "estimatedLog\n    \"Answer an estimate of (self abs floorLog: 10). This method\n     should be overridden by subclasses, but Number's implementation\n     does not raise errors - simply, it gives a correct result, so\n     it is slow.\"\n    ^self abs floorLog: 10",
              "literals": [],
              "methodName": "estimatedLog",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "tan": {
              "src": "tan\n    \"return the tangent of the receiver\"\n    ^self asFloatD tan",
              "literals": [],
              "methodName": "tan",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "closeTo:": {
              "src": "closeTo: num\n    \"Answer whether the receiver can be considered sufficiently\n     close to num (this is done by checking equality if num is\n     not a number, and by checking with 0.01% tolerance if num\n     is a number).\"\n    num isNumber ifFalse: [ ^self = num ].\n    self = self zero ifTrue: [ ^num abs < 0.0001 ].\n    num = num zero ifTrue: [ ^self abs < 0.0001 ].\n    ^(self - num) abs / 0.0001 <= (self abs max: num abs)",
              "literals": [],
              "methodName": "closeTo:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryRelationalOp:coercing:": {
              "src": "retryRelationalOp: aSymbol coercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling aSymbol (<, <=, >, >=).\"\n\n    | delta |\n    delta := self retryDifferenceCoercing: aNumber.\n\n    \"Avoids a #perform: which is usually more expensive -- all the comparisons\n     below are inlined by both the compiler and the interpreter\"\n\n    aSymbol == #< ifTrue: [ ^delta < delta zero ].\n    aSymbol == #<= ifTrue: [ ^delta <= delta zero ].\n    aSymbol == #>= ifTrue: [ ^delta >= delta zero ].\n    aSymbol == #> ifTrue: [ ^delta > delta zero ].\n    self error: 'bad relational operator'",
              "literals": [],
              "methodName": "retryRelationalOp:coercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryInequalityCoercing:": {
              "src": "retryInequalityCoercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling #~=.\"\n\n    | selfGen aNumGen |\n    (aNumber isKindOf: Number) ifFalse: [ ^true ].\n\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen ifTrue: [ ^false == (self = (self coerce: aNumber)) ].\n    selfGen < aNumGen ifTrue: [ ^false == ((aNumber coerce: self) ~= aNumber) ].\n\n    self retryError",
              "literals": [],
              "methodName": "retryInequalityCoercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "strictlyPositive": {
              "src": "strictlyPositive\n    \"Answer whether the receiver is > 0\"\n    ^self > self zero",
              "literals": [],
              "methodName": "strictlyPositive",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "truncateTo:": {
              "src": "truncateTo: aNumber\n    \"Answer the receiver, truncated towards zero to a multiple\n     of aNumber\"\n    ^(self / aNumber) integerPart * aNumber",
              "literals": [],
              "methodName": "truncateTo:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "*": {
              "src": "* aNumber\n    \"Subtract the receiver and aNumber, answer the result\"\n    self subclassResponsibility",
              "literals": [],
              "methodName": "*",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "+": {
              "src": "+ aNumber\n    \"Sum the receiver and aNumber, answer the result\"\n    self subclassResponsibility",
              "literals": [],
              "methodName": "+",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "asScaledDecimal:": {
              "src": "asScaledDecimal: n\n    \"Answer the receiver, converted to a ScaledDecimal object.\"\n    ^ScaledDecimal\n\tnewFromNumber: self asFraction\n\tscale: n",
              "literals": [],
              "methodName": "asScaledDecimal:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "-": {
              "src": "- aNumber\n    \"Subtract aNumber from the receiver, answer the result\"\n    self subclassResponsibility",
              "literals": [],
              "methodName": "-",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "positiveDifference:": {
              "src": "positiveDifference: aNumber\n    \"Answer the positive difference of the receiver and\n     aNumber, that is self - aNumber if it is positive,\n     0 otherwise.\"\n    | diff |\n    diff := self - aNumber.\n    diff isNaN ifTrue: [ ^diff ].\n    ^diff negative ifTrue: [ diff zero ] ifFalse: [ diff ]",
              "literals": [],
              "methodName": "positiveDifference:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "odd": {
              "src": "odd\n    \"Returns true if self is not divisible by 2\"\n    ^self truncated odd",
              "literals": [],
              "methodName": "odd",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "/": {
              "src": "/ aNumber\n    \"Divide the receiver by aNumber, answer the result (no loss of\n     precision).  Raise a ZeroDivide exception or return a valid\n     (possibly infinite) continuation value if aNumber is zero.\"\n    self subclassResponsibility",
              "literals": [],
              "methodName": "/",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "asInteger": {
              "src": "asInteger\n    \"Answer the receiver, rounded to the nearest integer\"\n    ^self rounded",
              "literals": [],
              "methodName": "asInteger",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "arcCos": {
              "src": "arcCos\n    \"return the arc cosine of the receiver\"\n    ^self asFloatD arcCos",
              "literals": [],
              "methodName": "arcCos",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "raisedTo:": {
              "src": "raisedTo: aNumber\n    \"Return self raised to aNumber power\"\n\n    ^aNumber isInteger\n        ifTrue: [ self raisedToInteger: aNumber ]\n        ifFalse: [ self asFloatD raisedTo: aNumber asFloatD ]",
              "literals": [],
              "methodName": "raisedTo:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "even": {
              "src": "even\n    \"Returns true if self is divisible by 2\"\n    ^self truncated even",
              "literals": [],
              "methodName": "even",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retry:coercing:": {
              "src": "retry: aSymbol coercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling aSymbol.  aSymbol is\n     supposed not to be #= or #~= (since those don't fail if aNumber is not\n     a Number).\"\n\n    | selfGen aNumGen |\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen\n    \tifTrue: [ ^self perform: aSymbol with: (self coerce: aNumber) ].\n    selfGen < aNumGen\n    \tifTrue: [ ^(aNumber coerce: self) perform: aSymbol with: aNumber ].\n\n    self retryError",
              "literals": [],
              "methodName": "retry:coercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "rounded": {
              "src": "rounded\n    \"Returns the integer nearest the receiver\"\n    ^self negative\n\tifTrue: [ (self - 0.5) ceiling ]\n\tifFalse: [ (self + 0.5) floor ]",
              "literals": [],
              "methodName": "rounded",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "squared": {
              "src": "squared\n    \"Answer the square of the receiver\"\n    ^self * self",
              "literals": [],
              "methodName": "squared",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "to:do:": {
              "src": "to: stop do: aBlock\n    \"Evaluate aBlock for each value in the interval going from the receiver\n     to stop by 1. Compiled in-line for one-argument aBlocks without\n     temporaries, and therefore not overridable.\"\n    | i |\n    i := self.\n    [ i <= stop ]\n    \twhileTrue: [ aBlock value: i.\n\t    \t     i := i + self unity ]",
              "literals": [],
              "methodName": "to:do:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "withSignOf:": {
              "src": "withSignOf: aNumber\n    \"Answer the receiver, with its sign possibly changed to match\n     that of aNumber.\"\n    ^aNumber positive == self positive\n\tifTrue: [ self ]\n\tifFalse: [ self negated ]",
              "literals": [],
              "methodName": "withSignOf:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "log:": {
              "src": "log: aNumber\n    \"return log base aNumber of the receiver\"\n    ^self asFloatD ln / aNumber asFloatD ln",
              "literals": [],
              "methodName": "log:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "log": {
              "src": "log\n    \"return log base aNumber of the receiver\"\n    ^self asFloatD ln / FloatD ln10",
              "literals": [],
              "methodName": "log",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "floorLog:": {
              "src": "floorLog: radix\n    \"return (self log: radix) floor. Optimized to answer an integer.\"\n\n    | me answer |\n\n    self < self zero ifTrue: [\n       ^self arithmeticError: 'cannot extract logarithm of a negative number'\n    ].\n    radix <= radix unity ifTrue: [\n\t(radix <= radix zero) ifTrue: [ ^self arithmeticError: 'bad radix' ].\n\t(radix = radix unity) ifTrue: [ ^self arithmeticError: 'bad radix' ].\n\t^(self floorLog: radix reciprocal) negated\n    ].\n\n    me := self.\n    self < self unity\n\tifTrue: [\n\t    answer := -1.\n\t    [   me := me * radix. me < me unity ] whileTrue: [\n\t\tanswer := answer - 1\n\t    ]\n\t]\n\tifFalse: [\n\t    answer := 0.\n\t    [   me > radix ] whileTrue: [\n\t\tme := me / radix.\n\t\tanswer := answer + 1\n\t    ]\n\t].\n\n   ^answer",
              "literals": [],
              "methodName": "floorLog:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "reciprocal": {
              "src": "reciprocal\n    \"Return the reciprocal of the receiver\"\n    self = self zero\n\tifTrue: [self zeroDivide]\n\tifFalse: [^self unity / self]",
              "literals": [],
              "methodName": "reciprocal",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "asFloat": {
              "src": "asFloat\n    \"Convert the receiver to an arbitrary subclass of Float\"\n    ^self asFloatD",
              "literals": [],
              "methodName": "asFloat",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "roundTo:": {
              "src": "roundTo: aNumber\n    \"Answer the receiver, truncated to the nearest multiple\n     of aNumber\"\n    ^(self + (aNumber / 2) / aNumber) integerPart * aNumber",
              "literals": [],
              "methodName": "roundTo:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "integerPart": {
              "src": "integerPart\n    \"Answer the receiver, truncated towards zero\"\n    ^self truncated",
              "literals": [],
              "methodName": "integerPart",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "isFinite": {
              "src": "isFinite\n    \"Answer whether the receiver represents a finite quantity.  Most\n     numeric classes are for finite quantities, so the default is to\n     answer true rather than calling #subclassResponsibility.\"\n    ^true",
              "literals": [],
              "methodName": "isFinite",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "isRational": {
              "src": "isRational\n    \"Answer whether the receiver is rational - false by default\"\n    ^false",
              "literals": [],
              "methodName": "isRational",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "unity": {
              "src": "unity\n    \"Coerce 1 to the receiver's class. The default implementation works,\n     but is inefficient\"\n    ^self coerce: 1",
              "literals": [],
              "methodName": "unity",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryDifferenceCoercing:": {
              "src": "retryDifferenceCoercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling #-.\"\n\n    | selfGen aNumGen |\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen ifTrue: [ ^self - (self coerce: aNumber) ].\n    selfGen < aNumGen ifTrue: [ ^(aNumber coerce: self) - aNumber ].\n\n    self retryError",
              "literals": [],
              "methodName": "retryDifferenceCoercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "negative": {
              "src": "negative\n    \"Answer whether the receiver is < 0\"\n    ^self < self zero",
              "literals": [],
              "methodName": "negative",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "isInfinite": {
              "src": "isInfinite\n    \"Answer whether the receiver represents an infinite quantity.  Most\n     numeric classes are for finite quantities, so the default is to\n     answer false rather than calling #subclassResponsibility.\"\n    ^false",
              "literals": [],
              "methodName": "isInfinite",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "rem:": {
              "src": "rem: aNumber\n    \"Return the remainder of dividing the receiver by aNumber with\n    truncation towards zero.  Raise a ZeroDivide exception if aNumber is\n    zero\"\n\n    ^self - ((self quo: aNumber) * aNumber)",
              "literals": [],
              "methodName": "rem:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "radiansToDegrees": {
              "src": "radiansToDegrees\n    \"Convert the receiver from radians to degrees\"\n    ^self asFloatD * 57.295779513082320876846364344191",
              "literals": [],
              "methodName": "radiansToDegrees",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "sin": {
              "src": "sin\n    \"return the sine of the receiver\"\n    ^self asFloatD sin",
              "literals": [],
              "methodName": "sin",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "arcSin": {
              "src": "arcSin\n    \"return the arc sine of the receiver\"\n    ^self asFloatD arcSin",
              "literals": [],
              "methodName": "arcSin",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "floor": {
              "src": "floor\n    \"Return the integer nearest the receiver toward negative infinity.\"\n\n    | selfTruncated |\n    selfTruncated := self truncated.\n    \"If positive, truncation to zero is what we want.\"\n    self >= self zero ifTrue: [^selfTruncated].\n\n    \"Must be negative.\"\n    self = (self coerce: selfTruncated)\n\tifTrue: [^selfTruncated]\n\tifFalse: [^selfTruncated - 1]",
              "literals": [],
              "methodName": "floor",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "//": {
              "src": "// aNumber\n    \"Return the integer quotient of dividing the receiver by aNumber with\n    truncation towards negative infinity.  Raise a ZeroDivide\n    exception if aNumber is zero\"\n\n    aNumber = 0 ifTrue: [ self zeroDivide ].\n    ^(self / aNumber) floor",
              "literals": [],
              "methodName": "//",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "zeroDivide": {
              "src": "zeroDivide\n    self error: 'cannot divide by zero'",
              "literals": [],
              "methodName": "zeroDivide",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "max:": {
              "src": "max: aNumber\n    \"Redefined to ensure that a NaN is never answered.  Answer\n     the maximum between the receiver and aNumber.\"\n    self isNaN ifTrue: [ ^aNumber ].\n\n    \"> will return false if aNumber is a NaN, then self will\n     be answered\"\n    ^aNumber > self ifTrue: [ aNumber ] ifFalse: [ self ]",
              "literals": [],
              "methodName": "max:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "isImmediate": {
              "src": "isImmediate\n    \"Answer whether, if x is an instance of the receiver, x copy == x\"\n    ^true",
              "literals": [],
              "methodName": "isImmediate",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "coerce:": {
              "src": "coerce: aNumber\n    \"Answer aNumber - whatever class it belongs to, it is good\"\n    ^aNumber",
              "literals": [],
              "methodName": "coerce:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "truncated": {
              "src": "truncated\n    \"Answer the receiver, truncated towards zero\"\n    ^self subclassResponsibility",
              "literals": [],
              "methodName": "truncated",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "fractionPart": {
              "src": "fractionPart\n    \"Answer a number which, summed to the #integerPart of the\n     receiver, gives the receiver itself.\"\n    ^self - self integerPart",
              "literals": [],
              "methodName": "fractionPart",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "positive": {
              "src": "positive\n    \"Answer whether the receiver is >= 0\"\n    ^self >= self zero",
              "literals": [],
              "methodName": "positive",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "asFloatE": {
              "src": "asFloatE\n    self subclassResponsibility",
              "literals": [],
              "methodName": "asFloatE",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "degreesToRadians": {
              "src": "degreesToRadians\n    \"Convert the receiver to radians\"\n    ^self asFloatD / 57.295779513082320876846364344191",
              "literals": [],
              "methodName": "degreesToRadians",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "asFloatD": {
              "src": "asFloatD\n    self subclassResponsibility",
              "literals": [],
              "methodName": "asFloatD",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "to:by:": {
              "src": "to: stop by: step\n    \"Return an interval going from the receiver to stop with the given step\"\n    ^Interval from: self to: stop by: step",
              "literals": [],
              "methodName": "to:by:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "deepCopy": {
              "src": "deepCopy\n    \"Return the receiver - it's an immediate (immutable) object\"\n    ^self",
              "literals": [],
              "methodName": "deepCopy",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "generality": {
              "src": "generality\n    \"Answer the receiver's generality\"\n    self subclassResponsibility",
              "literals": [],
              "methodName": "generality",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "abs": {
              "src": "abs\n    \"Answer the absolute value of the receiver\"\n    ^self > self zero\n\tifTrue: [ self ]\n\tifFalse: [ self negated ]",
              "literals": [],
              "methodName": "abs",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryEqualityCoercing:": {
              "src": "retryEqualityCoercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling #=.\"\n\n    | selfGen aNumGen |\n    (aNumber isKindOf: Number) ifFalse: [ ^false ].\n\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen ifTrue: [ ^self = (self coerce: aNumber) ].\n    selfGen < aNumGen ifTrue: [ ^(aNumber coerce: self) = aNumber ].\n\n    self retryError",
              "literals": [],
              "methodName": "retryEqualityCoercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "quo:": {
              "src": "quo: aNumber\n    \"Return the integer quotient of dividing the receiver by aNumber with\n    truncation towards zero.  Raise a ZeroDivide exception if aNumber is\n    zero\"\n    aNumber = 0 ifTrue: [ self zeroDivide ].\n    ^(self / aNumber) truncated",
              "literals": [],
              "methodName": "quo:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retryError": {
              "src": "retryError\n    \"Raise an error---a retrying method was called with two arguments\n     having the same generality.\"\n    ^self error: 'retry:coercing: called with arguments of the same generality'",
              "literals": [],
              "methodName": "retryError",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            },
            "retrySumCoercing:": {
              "src": "retrySumCoercing: aNumber\n    \"Coerce to the other number's class the one number between the receiver and\n     aNumber which has the lowest, and retry calling #+.\"\n\n    | selfGen aNumGen |\n    selfGen := self generality.\n    aNumGen := aNumber generality.\n    selfGen > aNumGen ifTrue: [ ^self + (self coerce: aNumber) ].\n    selfGen < aNumGen ifTrue: [ ^(aNumber coerce: self) + aNumber ].\n\n    self retryError",
              "literals": [],
              "methodName": "retrySumCoercing:",
              "className": "Number",
              "category": "errors",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": [
            {
              "className": "Fraction",
              "instance_methods": {
                "\\\\": {
                  "src": "\\\\ aNumber\n    \"Return the remainder from dividing the receiver by aNumber, (using //).\"\n    ^self - (self // aNumber * aNumber)",
                  "literals": [],
                  "methodName": "\\\\",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "<=": {
                  "src": "<= arg \n    \"Test if the receiver is less than or equal to arg.\"\n\n    (arg generality = self generality)\n\tifFalse: [^self retryRelationalOp: #<= coercing: arg].\n\n    ^(self compare: arg) <= 0",
                  "literals": [],
                  "methodName": "<=",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "negated": {
                  "src": "negated\n    \"Return the receiver, with its sign changed.\"\n    ^Fraction\n\tnumerator: 0 - numerator\n\tdenominator: denominator",
                  "literals": [],
                  "methodName": "negated",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "storeOn:": {
                  "src": "storeOn: aStream\n    \"Store Smalltalk code compiling to the receiver on aStream\"\n    aStream nextPutAll: '(Fraction numerator: ';\n\tstore: numerator;\n\tnextPutAll: ' denominator: ';\n\tstore: numerator ;\n\tnextPut: $)",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "setNumerator:setDenominator:": {
                  "src": "setNumerator: numInteger setDenominator: denInteger \n    \"Set the fraction's numerator and denominator\"\n    denInteger = 0\n\tifTrue: [ ^numInteger zeroDivide ].\n    denInteger < 0\n\tifTrue: [numerator := numInteger negated.\n\t\t denominator := denInteger negated ]\n\tifFalse: [numerator := numInteger.\n\t\t  denominator := denInteger]",
                  "literals": [],
                  "methodName": "setNumerator:setDenominator:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "numerator:denominator:": {
                  "src": "numerator: nInteger denominator: dInteger \n    \" Answer a new instance of fraction (nInteger/dInteger)\"\n \n    ^self new setNumerator: nInteger setDenominator: dInteger",
                  "literals": [],
                  "methodName": "numerator:denominator:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "reciprocal": {
                  "src": "reciprocal\n    \"Return the reciprocal of the receiver\"\n    denominator < 0\n\tifTrue: [^Fraction numerator: denominator negated \n\t\t\t   denominator: numerator negated ]\n\tifFalse: [^Fraction numerator: denominator denominator: numerator]",
                  "literals": [],
                  "methodName": "reciprocal",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "integerPart": {
                  "src": "integerPart\n    \"Answer the integer part of the receiver, expressed as a Fraction\"\n    ^Fraction numerator: self truncated denominator: 1",
                  "literals": [],
                  "methodName": "integerPart",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "asFraction": {
                  "src": "asFraction\n    \"Answer the receiver, it is already a Fraction\"\n    ^self",
                  "literals": [],
                  "methodName": "asFraction",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "isRational": {
                  "src": "isRational\n    \"Answer whether the receiver is rational - true\"\n    ^true",
                  "literals": [],
                  "methodName": "isRational",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "asFloatQ": {
                  "src": "asFloatQ\n    \"Answer the receiver converted to a FloatD\"\n    ^self asFloat: FloatQ",
                  "literals": [],
                  "methodName": "asFloatQ",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "unity": {
                  "src": "unity\n    \"Coerce 1 to the receiver's class\"\n    ^One",
                  "literals": [],
                  "methodName": "unity",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "floor": {
                  "src": "floor\n    \"Truncate the receiver towards negative infinity\n     and return the truncated result\"\n    ^numerator // denominator",
                  "literals": [],
                  "methodName": "floor",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "raisedToInteger:": {
                  "src": "raisedToInteger: anInteger \n    \"Return self raised to the anInteger-th power.\"\n    \"No need to reduce\"\n    anInteger < 0 ifTrue: [ ^self reciprocal raisedToInteger: 0 - anInteger ].\n\n    ^Fraction\n\tnumerator: (numerator raisedToInteger: anInteger)\n\tdenominator: (denominator raisedToInteger: anInteger)",
                  "literals": [],
                  "methodName": "raisedToInteger:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "estimatedLog": {
                  "src": "estimatedLog\n    \"Answer an estimate of (self abs floorLog: 10)\"\n    ^numerator estimatedLog - denominator estimatedLog",
                  "literals": [],
                  "methodName": "estimatedLog",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "//": {
                  "src": "// aNumber\n     \"Return the integer quotient of dividing the receiver by aNumber with\n      truncation towards negative infinity.\"\n     ^(self / aNumber) floor",
                  "literals": [],
                  "methodName": "//",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "reduce": {
                  "src": "reduce\n    \"Reduce the fraction.\"\n    | gcd |\n    numerator = 1 ifTrue: [ ^self ].\n    denominator = 1 ifTrue: [ ^numerator ].\n    numerator = 0 ifTrue: [^0].\n    numerator = denominator ifTrue: [^1].\n\n    gcd := numerator gcd: denominator.\n    gcd = 1 ifTrue: [^self].\n    denominator = gcd ifTrue: [^numerator quo: gcd].\n    numerator := numerator quo: gcd.\n    denominator := denominator quo: gcd.\n    ^self",
                  "literals": [],
                  "methodName": "reduce",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "ceiling": {
                  "src": "ceiling\n    \"Truncate the receiver towards positive infinity\n     and return the truncated result\"\n    ^(numerator + denominator - 1) // denominator",
                  "literals": [],
                  "methodName": "ceiling",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "asFloat:": {
                  "src": "asFloat: characterization\n    \"Answer the receiver converted to a Float\"\n    | n d shift sign |\n    n := numerator.\n    d := denominator.\n    sign := n sign * d sign.\n\n    \"Avoid answering NaNs and infinite values.\n     1e1800 asFloat / (1e1799 + 1) asFloat = NaN, but\n     (1e1800 / (1e1799 + 1)) asFloat must be 10.\"\n\n    shift := (characterization emax - numerator highBit).\n    shift := shift min: (characterization emax - denominator highBit).\n    shift < 0 ifTrue: [\n\t\"Lose some more precision, but we MUST avoid infinites and NaNs!\"\n\tshift := shift - 10. n := n bitShift: shift. d := d bitShift: shift ].\n\n    d = 0 ifTrue: [\n\t^sign > 0\n\t    ifTrue: [ characterization infinity ]\n\t    ifFalse: [ characterization negativeInfinity ] ].\n    n = 0 ifTrue: [\n\t^sign > 0\n\t    ifTrue: [ characterization coerce: 0 ]\n\t    ifFalse: [ characterization negativeInfinity reciprocal ] ].\n\n    ^(characterization coerce: n)\n\t / (characterization coerce: d)",
                  "literals": [],
                  "methodName": "asFloat:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "coerce:": {
                  "src": "coerce: aNumber \n    \"Coerce aNumber to the receiver's class\"\n    ^aNumber asFraction",
                  "literals": [],
                  "methodName": "coerce:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "truncated": {
                  "src": "truncated\n    \"Truncate the receiver and return the truncated result\"\n    ^numerator quo: denominator",
                  "literals": [],
                  "methodName": "truncated",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "*": {
                  "src": "* aNumber \n    \"Multiply two numbers and answer the result.\"\n\n    | num den gcd |\n    (aNumber generality = self generality)\n\tifFalse: [^self retryMultiplicationCoercing: aNumber].\n\n    num := numerator * aNumber numerator.\n    den := denominator * aNumber denominator.\n\n    aNumber == self ifFalse: [\n\tgcd := (numerator gcd: aNumber denominator) * \n\t       (denominator gcd: aNumber numerator).\n\n\tnum := num quo: gcd.\n\tden := den quo: gcd\n    ].\n\n    den = 1 ifTrue: [ ^num ].\n    ^Fraction numerator: num denominator: den",
                  "literals": [],
                  "methodName": "*",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "+": {
                  "src": "+ aNumber \n    \"Sum two numbers and answer the result.\"\n    | gcd num den |\n    (aNumber generality = self generality)\n\tifFalse: [^self retrySumCoercing: aNumber].\n\n    gcd := denominator gcd: aNumber denominator.\n    gcd == 1 ifTrue: [\n\t^Fraction\n\t    numerator: (numerator * aNumber denominator) +\n\t\t       (aNumber numerator * denominator) \n\t    denominator: denominator * aNumber denominator ].\n\n    num := (numerator * (aNumber denominator quo: gcd)) +\n\t   (aNumber numerator * (denominator quo: gcd)).\n    den := denominator * aNumber denominator quo: gcd.\n\n    \"Compute a GCD on smaller operands\"\n    gcd := gcd gcd: num.\n\n    num := num quo: gcd.\n    den := den quo: gcd.\n    den = 1 ifTrue: [ ^num ].\n    ^Fraction numerator: num denominator: den",
                  "literals": [],
                  "methodName": "+",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "asFloatE": {
                  "src": "asFloatE\n    \"Answer the receiver converted to a FloatD\"\n    ^self asFloat: FloatE",
                  "literals": [],
                  "methodName": "asFloatE",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "-": {
                  "src": "- aNumber\n     \"Subtract aNumber from the receiver and answer the result.\"\n\n    | gcd num den |\n    (aNumber generality = self generality)\n\t ifFalse: [^self retryDifferenceCoercing: aNumber].\n\n    gcd := denominator gcd: aNumber denominator.\n    gcd == 1 ifTrue: [\n\t^Fraction\n\t    numerator: (numerator * aNumber denominator) -\n\t\t       (aNumber numerator * denominator) \n\t    denominator: denominator * aNumber denominator ].\n\n    num := (numerator * (aNumber denominator quo: gcd)) -\n\t   (aNumber numerator * (denominator quo: gcd)).\n    den := denominator * aNumber denominator quo: gcd.\n\n    \"Compute a GCD on smaller operands\"\n    gcd := gcd gcd: num.\n\n    num := num quo: gcd.\n    den := den quo: gcd.\n    den = 1 ifTrue: [ ^num ].\n    ^Fraction numerator: num denominator: den",
                  "literals": [],
                  "methodName": "-",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "asFloatD": {
                  "src": "asFloatD\n    \"Answer the receiver converted to a FloatD\"\n    ^self asFloat: FloatD",
                  "literals": [],
                  "methodName": "asFloatD",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "denominator": {
                  "src": "denominator\n    \"Answer the receiver's denominator\"\n    ^denominator",
                  "literals": [],
                  "methodName": "denominator",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "numerator": {
                  "src": "numerator\n    \"Answer the receiver's numerator\"\n    ^numerator",
                  "literals": [],
                  "methodName": "numerator",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "/": {
                  "src": "/ aNumber \n    \"Divide the receiver by aNumber and answer the result.\"\n\n    | num den gcd |\n    (aNumber generality = self generality)\n\tifFalse: [^self retryDivisionCoercing: aNumber].\n\n    num := numerator * aNumber denominator.\n    den := denominator * aNumber numerator.\n    gcd := (numerator gcd: aNumber numerator) * \n\t(denominator gcd: aNumber denominator).\n\n    num := num quo: gcd.\n    den := den quo: gcd.\n    den = 1 ifTrue: [ ^num ].\n    ^Fraction numerator: num denominator: den",
                  "literals": [],
                  "methodName": "/",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "generality": {
                  "src": "generality\n    \"Return the receiver's generality\"\n    ^300",
                  "literals": [],
                  "methodName": "generality",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n\n    aStream\n\tprint: numerator;\n\tnextPut: $/;\n\tprint: denominator",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "compare:": {
                  "src": "compare: arg\n    \"Answer an integer <, >, = 0 depending on the ordering\n     between the receiver and arg.\"\n\n    | n1 n2 delta |\n\n    \"Comparing numbers with different signs, we just care about that;\n     canonical form further restricts the check to the numerator.\"\n    self numerator sign = arg numerator sign\n\tifFalse: [ ^numerator sign - arg numerator sign ].\n\n    n1 := numerator abs.\n    n2 := arg numerator abs.\n\n    \"The first line is (n1 * d2) highBit +/- 1, and similarly for the second.\"\n    delta := numerator abs highBit + arg denominator highBit -\n             arg numerator abs highBit - denominator highBit.\n\n    delta < -1 ifTrue: [ ^delta * numerator sign ].\n    delta >  1 ifTrue: [ ^delta * numerator sign ].\n\n    \"Cross multiply and compare.  Sending #* to the denominators is\n     faster because they cannot be LargeNegativeIntegers.\"\n    ^((arg denominator * numerator) - (denominator * arg numerator)) sign",
                  "literals": [],
                  "methodName": "compare:",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "squared": {
                  "src": "squared\n    \"Return the square of the receiver.\"\n    ^Fraction\n\tnumerator: numerator squared\n\tdenominator: denominator squared",
                  "literals": [],
                  "methodName": "squared",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "initialize": {
                  "src": "initialize\n    \"Initialize the receiver's class variables\"\n    Zero := self numerator: 0 denominator: 1.\n    One := self numerator: 1 denominator: 1.",
                  "literals": [],
                  "methodName": "initialize",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "<": {
                  "src": "< arg \n    \"Test if the receiver is less than arg.\"\n\n    (arg generality = self generality)\n\tifFalse: [^self retryRelationalOp: #< coercing: arg].\n\n    ^(self compare: arg) < 0",
                  "literals": [],
                  "methodName": "<",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "=": {
                  "src": "= arg \n    \"Test if the receiver equals arg.\"\n\n    (arg isKindOf: Number)\n\tifFalse: [^false].\n\n    (arg generality = self generality)\n\tifFalse: [^self retryEqualityCoercing: arg].\n\n    ^self numerator = arg numerator and: [\n\tself denominator = arg denominator ].",
                  "literals": [],
                  "methodName": "=",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                ">": {
                  "src": "> arg \n    \"Test if the receiver is more than arg.\"\n\n    (arg generality = self generality)\n\tifFalse: [^self retryRelationalOp: #> coercing: arg].\n\n    ^(self compare: arg) > 0",
                  "literals": [],
                  "methodName": ">",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                "hash": {
                  "src": "hash\n    \"Answer an hash value for the receiver\"\n    denominator = 1 ifTrue: [ ^numerator hash ].\n    ^(numerator asFloatD / denominator asFloatD) hash",
                  "literals": [],
                  "methodName": "hash",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                },
                ">=": {
                  "src": ">= arg \n    \"Test if the receiver is greater than or equal to arg.\"\n\n    (arg generality = self generality)\n\tifFalse: [^self retryRelationalOp: #>= coercing: arg].\n\n    ^(self compare: arg) >= 0",
                  "literals": [],
                  "methodName": ">=",
                  "className": "Fraction",
                  "category": "optimized cases",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            },
            {
              "className": "Integer",
              "instance_methods": {
                "storeOn:base:": {
                  "src": "storeOn: aStream base: b\n    \"Print on aStream Smalltalk code compiling to the receiver, \n     represented in base b\"\n    self printOn: aStream base: b showRadix: true",
                  "literals": [],
                  "methodName": "storeOn:base:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "reverseStringBase:on:": {
                  "src": "reverseStringBase: b on: revStr\n    \"Print on str the reversed base b representation of the receiver\n     (which is > 0)\"\n\n    | num |\n    self = 0 ifTrue: [ revStr nextPut: $0. ^1 ].\n\n    num := self.\n    [ num = 0 ] whileFalse:\n    \t[ revStr nextPut: (Character digitValue: (num \\\\ b)).\n\t  num := num // b ].\n\n    ^revStr size",
                  "literals": [],
                  "methodName": "reverseStringBase:on:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "gcd:": {
                  "src": "gcd: anInteger\n    \"Return the greatest common divisor (Euclid's algorithm) between the\n     receiver and anInteger\"\n    | a b remainder |\n    self negative | anInteger negative ifTrue: [ ^self abs gcd: anInteger abs ].\n\n    self < anInteger\n\tifTrue: [ a := anInteger. b := self ]\n\tifFalse: [ a := self. b := anInteger ].\n    [ b = 0 ] whileFalse: [\n\tremainder := a \\\\ b.\n\ta := b.\n\tb := remainder. ].\n    ^a",
                  "literals": [],
                  "methodName": "gcd:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "storeOn:": {
                  "src": "storeOn: aStream\n    \"Print on aStream the base 10 representation of the receiver\"\n    self printOn: aStream\t\t\"they print and store the same\"",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "allMask:": {
                  "src": "allMask: anInteger\n    \"True if all 1 bits in anInteger are 1 in the receiver\"\n    ^(self bitAnd: anInteger) = anInteger",
                  "literals": [],
                  "methodName": "allMask:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "asCharacter": {
                  "src": "asCharacter\n    \"Return self as an ascii character\"\n    ^Character value: self",
                  "literals": [],
                  "methodName": "asCharacter",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "setBit:": {
                  "src": "setBit: index\n    \"Set the index-th bit of the receiver and answer a new Integer\"\n    ^self bitOr: (1 bitShift: (index - 1))",
                  "literals": [],
                  "methodName": "setBit:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "factorial": {
                  "src": "factorial\n    \"Return the receiver's factorial.\"\n    | mask k n a b max stack |\n\n    self < 0 ifTrue: [\n        ^self arithmeticError: 'factorial of a negative number' ].\n\n    self < 2 ifTrue: [ ^1 ].\n\n    \"The number of SmallInteger factors we computed so far\"\n    k := 1.\n\n    \"The next factor to be multiplied.\"\n    n := self.\n\n    \"The stack holding intermediate factors.\"\n    stack := OrderedCollection new.\n\n    [\n\ta := n - 1.\n\tb := n.\n\tmax := SmallInteger largest // n.\n        [\n\t    n := n - 2.\n            n < 2 ifTrue: [\n\t\t\"Done, empty the stack and combine all the factors.\"\n\t\ta := a * b.\n\t\tstack size timesRepeat: [ a := a * stack removeLast ].\n\t\t^a\n\t    ].\n\t    b < max\n        ] whileTrue: [\n            a := a * (n - 1).\n            b := b * n\n\t].\n\n\t\"Compose the two SmallInteger factors\"\n\ta := a * b.\n\n\t\"Pop factors from the stack and combine them.  The number of factors\n\t we pop is equal to the order of the lowest bit set.\n\n\t That is, on the first iteration we push a size 1 LargeInteger;\n\t on the second iteration we pop it and make a size 2 LargeInteger;\n\t on the third iteration we push another size 1 LargeInteger;\n\t on the fourth iteration we pop it and make a size 2 LargeInteger;\n\t we then combine it with the other similarly sized integer and\n\t make a size 4 LargeInteger; and so on.\"\n\n\tmask := k bitXor: k - 1.\n\t[ mask = 1 ] whileFalse: [\n\t    a := a * stack removeLast.\n\t    mask := mask bitShift: -1.\n\t].\n\tstack addLast: a.\n\tk := k + 1.\n    ] repeat",
                  "literals": [],
                  "methodName": "factorial",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "floorLog:": {
                  "src": "floorLog: radix\n    \"return (self log: radix) floor. Optimized to answer an integer.\"\n\n    | me answer |\n\n    self < self zero ifTrue: [\n       ^self arithmeticError: 'cannot extract logarithm of a negative number'\n    ].\n\n    radix <= radix unity ifTrue: [\n\t(radix <= radix zero)\n\t    ifTrue: [ ^self arithmeticError: 'base of a logarithm cannot be negative' ].\n\t(radix = radix unity)\n\t    ifTrue: [ ^self arithmeticError: 'base of a logarithm cannot be 1' ].\n\t^(self floorLog: radix reciprocal) negated\n    ].\n    radix isInteger ifFalse: [\n\t^(self coerce: radix) floorLog: radix\n    ].\n\n    me := self.\n    answer := 0.\n    [   me >= radix ] whileTrue: [\n\tme := me // radix.\n\tanswer := answer + 1\n    ].\n    ^answer",
                  "literals": [],
                  "methodName": "floorLog:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "clearBit:": {
                  "src": "clearBit: index\n    \"Clear the index-th bit of the receiver and answer a new Integer\"\n    | bit |\n    bit := 1 bitShift: (index - 1).\n    ^(self bitOr: bit) bitXor: bit",
                  "literals": [],
                  "methodName": "clearBit:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "asFraction": {
                  "src": "asFraction\n    \"Return the receiver converted to a fraction\"\n    ^Fraction numerator: self denominator: 1",
                  "literals": [],
                  "methodName": "asFraction",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "noMask:": {
                  "src": "noMask: anInteger\n    \"True if no 1 bits in anInteger are 1 in the receiver\"\n    ^(self bitAnd: anInteger) = 0",
                  "literals": [],
                  "methodName": "noMask:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "isRational": {
                  "src": "isRational\n    \"Answer whether the receiver is rational - true\"\n    ^true",
                  "literals": [],
                  "methodName": "isRational",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "isInteger": {
                  "src": "isInteger\n    ^true",
                  "literals": [],
                  "methodName": "isInteger",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "lcm:": {
                  "src": "lcm: anInteger\n    \"Return the least common multiple between the receiver and anInteger\"\n    ^((self // (self gcd: anInteger)) * anInteger) abs",
                  "literals": [],
                  "methodName": "lcm:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "highBit": {
                  "src": "highBit\n    \"Return the index of the highest order 1 bit of the receiver\"\n    self subclassResponsibility",
                  "literals": [],
                  "methodName": "highBit",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "floor": {
                  "src": "floor\n    \"Return the receiver - it's already truncated\"\n    ^self",
                  "literals": [],
                  "methodName": "floor",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "binomial:": {
                  "src": "binomial: anInteger\n    \"Compute the number of combinations of anInteger objects among\n     a number of objects given by the receiver.\"\n\n    | n k mask gcd maxNum step num den stepNum stepDen |\n\n    (self < 0 or: [ anInteger < 0 or: [ anInteger > self ]]) ifTrue: [\n        ^self arithmeticError: 'binomial coefficient with invalid arguments' ].\n\n    \"The number of SmallInteger factors we computed so far\"\n    step := 1.\n\n    \"Two stacks holding intermediate factors.\"\n    num := OrderedCollection new.\n    den := OrderedCollection new.\n\n    \"The next factors to be multiplied.\"\n    n := self. \n    k := anInteger+anInteger > n ifTrue: [n - anInteger] ifFalse: [ anInteger ].\n    [\n\tstepNum := stepDen := 1.\n\t[\n            maxNum := SmallInteger largest // n.\n\t    [ stepNum <= maxNum ] whileTrue: [\n\t\tstepNum := stepNum * n. stepDen := stepDen * k.\n\t\tk = 1 ifTrue: [ \n\t\t    \"We're finishing, empty the stack and then simplify the\n\t\t     remaining common factors.\"\n\t\t    gcd := stepNum gcd: stepDen.\n\t\t    stepNum := stepNum // gcd.\n\t\t    stepDen := stepDen // gcd.\n\n\t\t    num size timesRepeat: [\n\t\t\tstepNum := stepNum * num removeLast.\n\t\t\tstepDen := stepDen * den removeLast\n\t\t    ].\n\n\t\t    ^stepNum // stepDen\n\t\t].\n\t\tn := n - 1. k := k - 1 ].\n\n\t    (gcd := stepNum gcd: stepDen) > 1 and: [\n\t        stepNum := stepNum // gcd.\n\t\tstepDen := stepDen // gcd.\n \t    \n\t\t\"The numerators and denominators have been simplified, try\n\t         to add some more factors.\"\n\t\tstepNum <= maxNum ]\n\t] whileTrue.\n\n        \"Pop factors from the stack and combine them.  The number of factors\n         we pop is equal to the order of the lowest bit set.\n\n         That is, on the first iteration we push a size 1 LargeInteger;\n         on the second iteration we pop it and make a size 2 LargeInteger;\n         on the third iteration we push another size 1 LargeInteger;\n         on the fourth iteration we pop it and make a size 2 LargeInteger;\n         we then combine it with the other similarly sized integer and\n         make a size 4 LargeInteger; and so on.\n\n\t For the denominator the balancing is probably worse, since we\n\t decide when to stop multiplying based on the numerator's magnitude,\n\t but it is not a serious problem.\"\n\n        mask := step bitXor: step - 1.\n        [ mask = 1 ] whileFalse: [\n            stepNum := stepNum * num removeLast.\n            stepDen := stepDen * den removeLast.\n            mask := mask bitShift: -1.\n        ].\n        num addLast: stepNum.\n        den addLast: stepDen.\n        step := step + 1.\n    ] repeat",
                  "literals": [],
                  "methodName": "binomial:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "estimatedLog": {
                  "src": "estimatedLog\n    \"Answer an estimate of (self abs floorLog: 10)\"\n    ^(self highBit asFloatD / FloatD log10Base2) ceiling",
                  "literals": [],
                  "methodName": "estimatedLog",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "bitAt:put:": {
                  "src": "bitAt: index put: value\n    \"Answer an integer which is identical to the receiver,\n     possibly with the exception of the index-th bit of the\n     receiver (the LSB having an index of 1), which assumes\n     a value equal to the low-order bit of the second parameter.\"\n\n    | bit |\n    bit := (value bitAnd: 1) bitXor: (self bitAt: index).\n    bit := bit bitShift: (index - 1).\n    ^self bitXor: bit",
                  "literals": [],
                  "methodName": "bitAt:put:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "ceiling": {
                  "src": "ceiling\n    \"Return the receiver - it's already truncated\"\n    ^self",
                  "literals": [],
                  "methodName": "ceiling",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "bitAt:": {
                  "src": "bitAt: index\n    \"Answer the index-th bit of the receiver (the LSB has an index \n     of 1)\"\n    ^(self bitShift: (index - 1) negated) bitAnd: 1",
                  "literals": [],
                  "methodName": "bitAt:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "anyMask:": {
                  "src": "anyMask: anInteger\n    \"True if any 1 bits in anInteger are 1 in the receiver\"\n    ^(self bitAnd: anInteger) ~= 0",
                  "literals": [],
                  "methodName": "anyMask:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "coerce:": {
                  "src": "coerce: aNumber\n    \"Coerce aNumber to the receiver's class\"\n    ^aNumber truncated",
                  "literals": [],
                  "methodName": "coerce:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "truncated": {
                  "src": "truncated\n    \"Return the receiver - it's already truncated\"\n    ^self",
                  "literals": [],
                  "methodName": "truncated",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "bitClear:": {
                  "src": "bitClear: aMask \n    \"Answer an Integer equal to the receiver, except that all the bits\n     that are set in aMask are cleared.\"\n\n    ^(self bitOr: aMask) bitXor: aMask",
                  "literals": [],
                  "methodName": "bitClear:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "asScaledDecimal:": {
                  "src": "asScaledDecimal: n\n    \"Answer the receiver, converted to a ScaledDecimal object.\n     The scale is forced to be 0.\"\n    ^ScaledDecimal\n        newFromNumber: self asFraction\n        scale: 0",
                  "literals": [],
                  "methodName": "asScaledDecimal:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "odd": {
                  "src": "odd\n    \"Return whether the receiver is odd\"\n    ^(self bitAnd: 1) ~= 0",
                  "literals": [],
                  "methodName": "odd",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "numerator": {
                  "src": "numerator\n    ^self",
                  "literals": [],
                  "methodName": "numerator",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "denominator": {
                  "src": "denominator\n    ^1",
                  "literals": [],
                  "methodName": "denominator",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "isBitSet:": {
                  "src": "isBitSet: index\n    \"Answer whether the index-th bit of the receiver is set\"\n    ^((self bitShift: (index - 1) negated) bitAnd: 1) == 1",
                  "literals": [],
                  "methodName": "isBitSet:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "printStringRadix:": {
                  "src": "printStringRadix: baseInteger\n    \"Return the base b representation of the receiver, with BBr in\n     front of it\"\n    | str |\n    str := WriteStream on: (String new: 10).\n    self printOn: str base: baseInteger showRadix: true.\n    ^str contents",
                  "literals": [],
                  "methodName": "printStringRadix:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "printString:": {
                  "src": "printString: baseInteger\n    \"Return the base b representation of the receiver\"\n    | str |\n    str := WriteStream on: (String new: 10).\n    self printOn: str base: baseInteger showRadix: false.\n    ^str contents",
                  "literals": [],
                  "methodName": "printString:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "timesRepeat:": {
                  "src": "timesRepeat: aBlock\n    \"Evaluate aBlock a number of times equal to the receiver's value.\n     Compiled in-line for no argument aBlocks without temporaries, and\n     therefore not overridable.\"\n    1 to: self do: [ :each | aBlock value ]",
                  "literals": [],
                  "methodName": "timesRepeat:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "bitInvert": {
                  "src": "bitInvert\n    \"Return the 1's complement of the bits of the receiver\"\n    ^self bitXor: -1",
                  "literals": [],
                  "methodName": "bitInvert",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "printOn:base:showRadix:": {
                  "src": "printOn: str base: baseInteger showRadix: showRadix\n    \"Append to str the base baseInteger representation of the receiver\"\n    | sign num revStr |\n    sign := (self sign = -1).\n    num := sign ifTrue: [ self negated ] ifFalse: [ self ].\n\n    showRadix ifTrue:\n    \t[ baseInteger printOn: str.\n\t  str nextPut: $r ].\n    sign ifTrue: [ str nextPut: $- ].\n\n    revStr := WriteStream on: (String new: 8).\n    num reverseStringBase: baseInteger on: revStr.\n    revStr contents reverseDo: [ :each | str nextPut: each ].",
                  "literals": [],
                  "methodName": "printOn:base:showRadix:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream\n    \"Print on aStream the base 10 representation of the receiver\"\n    self printOn: aStream base: 10 showRadix: false",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "even": {
                  "src": "even\n    \"Return whether the receiver is even\"\n    ^(self bitAnd: 1) = 0",
                  "literals": [],
                  "methodName": "even",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "radix:": {
                  "src": "radix: baseInteger\n    \"Return the base b representation of the receiver, with BBr in\n     front of it.  This method is deprecated, use #printStringRadix:\n     instead.\"\n    | str |\n    str := WriteStream on: (String new: 10).\n    self printOn: str base: baseInteger showRadix: true.\n    ^str contents",
                  "literals": [],
                  "methodName": "radix:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "rounded": {
                  "src": "rounded\n    \"Return the receiver - it's already truncated\"\n    ^self",
                  "literals": [],
                  "methodName": "rounded",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "printOn:base:": {
                  "src": "printOn: aStream base: b\n    \"Print on aStream the base b representation of the receiver\"\n    self printOn: aStream base: b showRadix: false",
                  "literals": [],
                  "methodName": "printOn:base:",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                },
                "hash": {
                  "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^self",
                  "literals": [],
                  "methodName": "hash",
                  "className": "Integer",
                  "category": "accessing",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": [
                {
                  "className": "SmallInteger",
                  "instance_methods": {
                    "zero": {
                      "src": "zero\n    \"Coerce 0 to the receiver's class\"\n    ^0",
                      "literals": [],
                      "methodName": "zero",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "largest": {
                      "src": "largest\n    \"Answer the largest integer represented directly in an object pointer\"\n    | maxBit |\n    maxBit := 1 bitShift: CLongSize * 8 - 3.\n    ^(maxBit - 1) + maxBit",
                      "literals": [],
                      "methodName": "largest",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "unity": {
                      "src": "unity\n    \"Coerce 1 to the receiver's class\"\n    ^1",
                      "literals": [],
                      "methodName": "unity",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "generality": {
                      "src": "generality\n    \"Return the receiver's generality\"\n    ^100",
                      "literals": [],
                      "methodName": "generality",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "smallest": {
                      "src": "smallest\n    \"Answer the smallest integer represented directly in an object pointer\"\n    | maxBit |\n    maxBit := 1 bitShift: CLongSize * 8 - 3.\n    ^maxBit negated - maxBit",
                      "literals": [],
                      "methodName": "smallest",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "isIdentity": {
                      "src": "isIdentity\n    \"Answer whether x = y implies x == y for instances of the receiver\"\n    ^true",
                      "literals": [],
                      "methodName": "isIdentity",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "bits": {
                      "src": "bits\n    \"Answer the number of bits (excluding the sign) that can be represented\n    directly in an object pointer\"\n    ^CLongSize * 8 - 3",
                      "literals": [],
                      "methodName": "bits",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "highBit": {
                      "src": "highBit\n    \"Return the index of the highest order 1 bit of the receiver\"\n\n    | n bit |\n    self = 0 ifTrue: [ ^0 ].\n\n    bit := 0.\n    self < 0\n\tifTrue: [\n\t    \"Increment the result by one if not a power of two\"\n\t    n := self negated. \n\t    (n bitAnd: self) = n ifFalse: [ bit := 1 ]\n\t]\n\tifFalse: [ n := self. bit := 0 ].\n\n    [ n > 16r3FFFFFFF ] whileTrue: [\n\tbit := bit + 30. n := n bitShift: -30 ].\n\n    n > 16rFFFF ifTrue: [ bit := bit + 16. n := n bitShift: -16 ].\n    n > 16rFF ifTrue: [ bit := bit + 8. n := n bitShift: -8 ].\n    n > 16rF ifTrue: [ bit := bit + 4. n := n bitShift: -4 ].\n    n > 16r3 ifTrue: [ bit := bit + 2. n := n bitShift: -2 ].\n    n > 16r1 ifTrue: [ bit := bit + 1. n := n bitShift: -1 ].\n    ^n + bit",
                      "literals": [],
                      "methodName": "highBit",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    },
                    "isSmallInteger": {
                      "src": "isSmallInteger\n    ^true",
                      "literals": [],
                      "methodName": "isSmallInteger",
                      "className": "SmallInteger",
                      "category": "testing functionality",
                      "byteCodes": []
                    }
                  },
                  "class_methods": {},
                  "subclasses": []
                }
              ]
            },
            {
              "className": "ScaledDecimal",
              "instance_methods": {
                "\\\\": {
                  "src": "\\\\ aNumber \n    \"Answer the remainder after integer division the receiver by aNumber \n    with truncation towards negative infinity.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^ScaledDecimal\n\t    newFromNumber: fraction \\\\ aNumber asFraction\n\t    scale: (scale max: aNumber scale) ]\n\tifFalse: [^self retry: #\\\\ coercing: aNumber]",
                  "literals": [],
                  "methodName": "\\\\",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "<=": {
                  "src": "<= aNumber \n     \"Answer whether the receiver is less than or equal to arg.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^(self compare: aNumber) <= 0 ]\n\tifFalse: [^self retryRelationalOp: #<= coercing: aNumber]",
                  "literals": [],
                  "methodName": "<=",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "storeOn:": {
                  "src": "storeOn: aStream \n    \"Print Smalltalk code that compiles to the receiver on aStream.\"\n    self printOn: aStream",
                  "literals": [],
                  "methodName": "storeOn:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "newFromNumber:scale:": {
                  "src": "newFromNumber: aNumber scale: scale\n    \"Answer a new instance of ScaledDecimal, representing a decimal\n     fraction with a decimal representation considered valid up to the\n     scale-th digit.\"\n    ^(self basicNew)\n\tsetFraction: aNumber asFraction scale: scale;\n\tyourself",
                  "literals": [],
                  "methodName": "newFromNumber:scale:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "scale": {
                  "src": "scale\n    \"Private - Answer a integer which represents the total number of digits \n    used to represent the fraction part of the receiver, including trailing \n    zeroes.\"\n    ^scale",
                  "literals": [],
                  "methodName": "scale",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "integerPart": {
                  "src": "integerPart\n    \"Answer the fractional part of the receiver.\"\n    ^ScaledDecimal newFromNumber: fraction integerPart scale: scale",
                  "literals": [],
                  "methodName": "integerPart",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asFraction": {
                  "src": "asFraction\n    \"Answer the receiver, converted to a Fraction\"\n    ^fraction",
                  "literals": [],
                  "methodName": "asFraction",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "zero": {
                  "src": "zero\n    \"Answer the receiver's representation of zero.\"\n    ^Zero",
                  "literals": [],
                  "methodName": "zero",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asFloatQ": {
                  "src": "asFloatQ\n    \"Answer the receiver, converted to a FloatQ\"\n    ^fraction asFloatQ",
                  "literals": [],
                  "methodName": "asFloatQ",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "setFraction:scale:": {
                  "src": "setFraction: theFraction scale: theScale\n    \"Private - Set the fraction to theFraction and the total number of digits \n    used to represent the fraction part of the receiver, including trailing \n    zeroes, to the Integer theScale.\"\n    fraction := theFraction.\n    scale := theScale",
                  "literals": [],
                  "methodName": "setFraction:scale:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "//": {
                  "src": "// aNumber \n    \"Answer the integer quotient after dividing the receiver by aNumber \n    with truncation towards negative infinity.\"\n    ^fraction // aNumber",
                  "literals": [],
                  "methodName": "//",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "ceiling": {
                  "src": "ceiling\n    \"Answer the receiver, converted to an Integer and truncated towards\n     +infinity.\"\n    ^fraction ceiling",
                  "literals": [],
                  "methodName": "ceiling",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "displayOn:": {
                  "src": "displayOn: aStream\n    \"Print a representation of the receiver on aStream, intended to\n     be directed to a user.  In this particular case, the `scale'\n     part of the #printString is not emitted.\"\n    | aFraction fracDigits |\n    self < 0 ifTrue: [aStream nextPut: $-].\n    aFraction := fraction abs.\n    aStream nextPutAll: aFraction truncated printString.\n    scale = 0 ifTrue: [^self].\n    aStream nextPut: $. .\n    fracDigits := aFraction fractionPart.\n    scale timesRepeat: [\n\tfracDigits := fracDigits * 10.\n\taStream nextPut: (Character digitValue: fracDigits truncated).\n\tfracDigits := fracDigits fractionPart\n    ]",
                  "literals": [],
                  "methodName": "displayOn:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "one": {
                  "src": "one\n    \"Answer the receiver's representation of one.\"\n    ^One",
                  "literals": [],
                  "methodName": "one",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "coerce:": {
                  "src": "coerce: aNumber\n    \"Answer aNumber, converted to a ScaledDecimal with the same scale\n     as the receiver.\"\n    ^ScaledDecimal\n\tnewFromNumber: aNumber asFraction\n\tscale: scale",
                  "literals": [],
                  "methodName": "coerce:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "truncated": {
                  "src": "truncated\n    \"Answer the receiver, converted to an Integer and truncated towards\n     -infinity.\"\n    ^fraction truncated",
                  "literals": [],
                  "methodName": "truncated",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "*": {
                  "src": "* aNumber \n     \"Multiply two numbers and answer the result.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^ScaledDecimal\n\t    newFromNumber: fraction * aNumber asFraction\n\t    scale: (scale max: aNumber scale) ]\n\tifFalse: [^self retryMultiplicationCoercing: aNumber]",
                  "literals": [],
                  "methodName": "*",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "fractionPart": {
                  "src": "fractionPart\n    \"Answer the fractional part of the receiver.\"\n    ^ScaledDecimal newFromNumber: fraction fractionPart scale: scale",
                  "literals": [],
                  "methodName": "fractionPart",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "+": {
                  "src": "+ aNumber \n    \"Sum two numbers and answer the result.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^ScaledDecimal\n\t    newFromNumber: fraction + aNumber asFraction\n\t    scale: (scale max: aNumber scale) ]\n\tifFalse: [^self retrySumCoercing: aNumber]",
                  "literals": [],
                  "methodName": "+",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asFloatE": {
                  "src": "asFloatE\n    \"Answer the receiver, converted to a FloatE\"\n    ^fraction asFloatE",
                  "literals": [],
                  "methodName": "asFloatE",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "asFloatD": {
                  "src": "asFloatD\n    \"Answer the receiver, converted to a FloatD\"\n    ^fraction asFloatD",
                  "literals": [],
                  "methodName": "asFloatD",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "-": {
                  "src": "- aNumber \n     \"Subtract aNumber from the receiver and answer the result.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^ScaledDecimal\n\t    newFromNumber: fraction - aNumber asFraction\n\t    scale: (scale max: aNumber scale) ]\n\tifFalse: [^self retryDifferenceCoercing: aNumber]",
                  "literals": [],
                  "methodName": "-",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "/": {
                  "src": "/ aNumber \n     \"Divide two numbers and answer the result.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^ScaledDecimal\n\t    newFromNumber: fraction / aNumber asFraction\n\t    scale: (scale max: aNumber scale) ]\n\tifFalse: [^self retryDivisionCoercing: aNumber]",
                  "literals": [],
                  "methodName": "/",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "generality": {
                  "src": "generality\n    \"Return the receiver's generality\"\n    ^250",
                  "literals": [],
                  "methodName": "generality",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "printOn:": {
                  "src": "printOn: aStream \n    \"Print a representation of the receiver on aStream.\"\n    self displayOn: aStream.\n    aStream nextPut: $s.\n    scale printOn: aStream",
                  "literals": [],
                  "methodName": "printOn:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "compare:": {
                  "src": "compare: arg\n    \"Private - Answer a Number that is the receiver - arg,\n     truncated to a number of digits equal to the minimum of our\n     scale and aScaledDecimal's.\"\n    ^((fraction - arg asFraction) *\n          (10 raisedToInteger: (self scale min: arg scale))) rounded",
                  "literals": [],
                  "methodName": "compare:",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "initialize": {
                  "src": "initialize\n    \"Initialize the receiver's class variables\"\n\n    \"We cannot create ScaledDecimal with 1.0s0 during the very\n     first phases of bootstrapping, because the lexer calls in to\n     #asScaledDecimal: -- but it is not a problem.\"\n    One := self newFromNumber: 1 scale: 0.\n    Zero := self newFromNumber: 0 scale: 0",
                  "literals": [],
                  "methodName": "initialize",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "<": {
                  "src": "< aNumber \n     \"Answer whether the receiver is less than arg.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^(self compare: aNumber) < 0 ]\n\tifFalse: [^self retryRelationalOp: #< coercing: aNumber]",
                  "literals": [],
                  "methodName": "<",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "=": {
                  "src": "= arg \n     \"Answer whether the receiver is equal to arg.\"\n\n    (arg isKindOf: Number) ifFalse: [^false].\n\n    (arg generality = self generality)\n\tifTrue: [^(self compare: arg) = 0 ]\n\tifFalse: [^self retryEqualityCoercing: arg]",
                  "literals": [],
                  "methodName": "=",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                ">": {
                  "src": "> aNumber \n     \"Answer whether the receiver is greater than arg.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^(self compare: aNumber) > 0 ]\n\tifFalse: [^self retryRelationalOp: #> coercing: aNumber]",
                  "literals": [],
                  "methodName": ">",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "hash": {
                  "src": "hash\n    \"Answer an hash value for the receiver.\"\n\n    ^fraction hash",
                  "literals": [],
                  "methodName": "hash",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                ">=": {
                  "src": ">= aNumber \n     \"Answer whether the receiver is greater than or equal to arg.\"\n\n    (aNumber generality = self generality)\n\tifTrue: [^(self compare: aNumber) >= 0 ]\n\tifFalse: [^self retryRelationalOp: #>= coercing: aNumber]",
                  "literals": [],
                  "methodName": ">=",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                },
                "~=": {
                  "src": "~= arg \n     \"Answer whether the receiver is not equal arg.\"\n\n    (arg isKindOf: Number) ifFalse: [^true].\n\n    (arg generality = self generality)\n\tifTrue: [^(self compare: arg) ~= 0 ]\n\tifFalse: [^self retryInequalityCoercing: arg]",
                  "literals": [],
                  "methodName": "~=",
                  "className": "ScaledDecimal",
                  "category": "<unknown>",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            }
          ]
        },
        {
          "className": "Time",
          "instance_methods": {
            "hours:": {
              "src": "hours: h\n    \"Answer a Time that is the given number of hours past midnight\"\n    ^self fromSeconds: h * 3600",
              "literals": [],
              "methodName": "hours:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "hour12": {
              "src": "hour12\n    \"Answer the hour in a 12-hour clock\"\n    | h |\n    h := self hour \\\\ 12.\n    ^h = 0 ifTrue: [ 12 ] ifFalse: [ h ]",
              "literals": [],
              "methodName": "hour12",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "second": {
              "src": "second\n    \"Answer the number of seconds in the receiver\"\n    ^seconds \\\\ 60",
              "literals": [],
              "methodName": "second",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "millisecondClockValue": {
              "src": "millisecondClockValue\n    \"Answer the number of milliseconds since startup\"\n\n    | second milli |\n    [\n\tsecond := self primSecondClock.\n\tmilli := self primMillisecondClock \\\\ 1000.\n\t(second = self primSecondClock) and: [ milli > 10 ]\n    ] whileFalse.\n    ^(second - ClockOnStartup) * 1000 + milli",
              "literals": [],
              "methodName": "millisecondClockValue",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "minutes:": {
              "src": "minutes: m\n    \"Answer a Time that is the given number of minutes past midnight\"\n    ^self fromSeconds: m * 60",
              "literals": [],
              "methodName": "minutes:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "seconds": {
              "src": "seconds\n    \"Answer the number of seconds in the receiver\"\n    ^seconds rem: 60",
              "literals": [],
              "methodName": "seconds",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "setSeconds:": {
              "src": "setSeconds: secs\n    seconds := secs \\\\ 86400",
              "literals": [],
              "methodName": "setSeconds:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "fromSeconds:": {
              "src": "fromSeconds: secondCount\n    \"Answer a Time representing secondCount seconds past midnight\"\n    ^self new setSeconds: secondCount",
              "literals": [],
              "methodName": "fromSeconds:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "hour": {
              "src": "hour\n    \"Answer the number of hours in the receiver\"\n    ^(seconds // 3600) \\\\ 24",
              "literals": [],
              "methodName": "hour",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "asSeconds": {
              "src": "asSeconds\n    ^seconds",
              "literals": [],
              "methodName": "asSeconds",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "update:": {
              "src": "update: aspect\n    \"Private - Initialize the receiver's instance variables\"\n    aspect == #returnFromSnapshot\n\tifTrue: [ ClockOnStartup := Time primSecondClock ].",
              "literals": [],
              "methodName": "update:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "now": {
              "src": "now\n    \"Answer a time representing the current time of day\"\n\n    \"\\\\ rounds towards -infinity, so it is good for negative numbers too\"\n    ^self new setSeconds: self primSecondClock",
              "literals": [],
              "methodName": "now",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "millisecondsPerDay": {
              "src": "millisecondsPerDay\n    \"Answer the number of milliseconds in a day\"\n    ^86400000",
              "literals": [],
              "methodName": "millisecondsPerDay",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "addTime:": {
              "src": "addTime: timeAmount\n    \"Answer a new Time that is timeAmount seconds after the receiver\"\n    ^Time new setSeconds: seconds + timeAmount asSeconds",
              "literals": [],
              "methodName": "addTime:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "readFrom:": {
              "src": "readFrom: aStream\n    \"Parse an instance of the receiver (hours/minutes/seconds) from\n     aStream\"\n    | t1 t2 t3 ch ws |\n    t1 := t2 := t3 := 0.\n\n    1 to: 3 do: [ :i |\n        ws := WriteStream on: (String new: 10).\n\n\tch := $:.\n\t[ aStream atEnd not and: [\n\t     (ch := aStream next) isDigit not]] whileTrue.\n\n\tch isDigit\n\t    ifTrue: [\n\t        [ ws nextPut: ch. aStream atEnd not and: [\n\t\t    (ch := aStream next) isDigit ]] whileTrue.\n\t    ].\n\t\n\tt1 := t2. t2 := t3. t3 := ws contents asNumber.\n    ].\n\n    ^self fromSeconds: (t1 * 3600) + (t2 * 60) + t3",
              "literals": [],
              "methodName": "readFrom:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "hours:minutes:seconds:": {
              "src": "hours: h minutes: m seconds: s\n    \"Answer a Time that is the given number of hours, minutes and\n     seconds past midnight\"\n    ^self fromSeconds: (h * 60 + m) * 60 + s",
              "literals": [],
              "methodName": "hours:minutes:seconds:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "millisecondClock": {
              "src": "millisecondClock\n    \"Answer the number of milliseconds since startup.\"\n\n    | second milli |\n    [\n\tsecond := self primSecondClock.\n\tmilli := self primMillisecondClock \\\\ 1000.\n\t(second = self primSecondClock) and: [ milli > 10 ]\n    ] whileFalse.\n    ^(second - ClockOnStartup) * 1000 + milli",
              "literals": [],
              "methodName": "millisecondClock",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "new": {
              "src": "new\n    \"Answer a Time representing midnight\"\n    ^self basicNew setSeconds: 0",
              "literals": [],
              "methodName": "new",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "hours": {
              "src": "hours\n    \"Answer the number of hours in the receiver\"\n    ^(seconds quo: 3600) rem: 24",
              "literals": [],
              "methodName": "hours",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "utcNow": {
              "src": "utcNow\n    \"Answer a time representing the current time of day in Coordinated\n     Universal Time (UTC)\"\n\n    \"\\\\ rounds towards -infinity, so it is good for negative numbers too\"\n    ^self new setSeconds: self utcSecondClock",
              "literals": [],
              "methodName": "utcNow",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "millisecondsToRun:": {
              "src": "millisecondsToRun: timedBlock\n    \"Answer the number of milliseconds which timedBlock took to run\"\n    | startTime|\n    startTime := self millisecondClock.\n    timedBlock value.\n    ^self millisecondClock - startTime",
              "literals": [],
              "methodName": "millisecondsToRun:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "minutes": {
              "src": "minutes\n    \"Answer the number of minutes in the receiver\"\n    ^(seconds quo: 60) rem: 60",
              "literals": [],
              "methodName": "minutes",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "seconds:": {
              "src": "seconds: s\n    \"Answer a Time that is the given number of seconds past midnight\"\n    ^self fromSeconds: s",
              "literals": [],
              "methodName": "seconds:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "utcSecondClock": {
              "src": "utcSecondClock\n    \"Answer the number of seconds since the midnight of 1/1/1901 (unlike\n     #secondClock, the reference time is here expressed as UTC, that is\n     as Coordinated Universal Time).\"\n    ^self secondClock - self timezoneBias",
              "literals": [],
              "methodName": "utcSecondClock",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "hour24": {
              "src": "hour24\n    \"Answer the hour in a 24-hour clock\"\n    ^self hour",
              "literals": [],
              "methodName": "hour24",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "subtractTime:": {
              "src": "subtractTime: timeAmount\n    \"Answer a new Time that is timeAmount seconds before the receiver\"\n    ^Time new setSeconds: seconds - timeAmount asSeconds",
              "literals": [],
              "methodName": "subtractTime:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "minute": {
              "src": "minute\n    \"Answer the number of minutes in the receiver\"\n    ^(seconds // 60) \\\\ 60",
              "literals": [],
              "methodName": "minute",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    self hours printOn: aStream.\n    aStream nextPut: $:.\n    self minutes < 10 ifTrue: [ aStream nextPut: $0 ].\n    self minutes printOn: aStream.\n    aStream nextPut: $:.\n    self seconds < 10 ifTrue: [ aStream nextPut: $0 ].\n    self seconds printOn: aStream.",
              "literals": [],
              "methodName": "printOn:",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "initialize": {
              "src": "initialize\n    \"Initialize the Time class after the image has been bootstrapped\"\n\n    \"(99 * 365 + 25) * 86400 secs/day.\"\n    SecondClockAdjustment := 86400 * 36159.\n    ObjectMemory addDependent: self",
              "literals": [],
              "methodName": "initialize",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "<": {
              "src": "< aTime\n    \"Answer whether the receiver is less than aTime\"\n    ^seconds < aTime asSeconds",
              "literals": [],
              "methodName": "<",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "=": {
              "src": "= aTime\n    \"Answer whether the receiver is equal to aTime\"\n    ^self class == aTime class and: [ seconds = aTime asSeconds ]",
              "literals": [],
              "methodName": "=",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "secondClock": {
              "src": "secondClock\n    \"Answer the number of seconds since the midnight of 1/1/1901\"\n    ^self primSecondClock + SecondClockAdjustment",
              "literals": [],
              "methodName": "secondClock",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            },
            "hash": {
              "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^seconds",
              "literals": [],
              "methodName": "hash",
              "className": "Time",
              "category": "private",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        }
      ]
    },
    {
      "className": "Message",
      "instance_methods": {},
      "class_methods": {
        "argument": {
          "src": "argument\n    \"Answer the first of the receiver's arguments\"\n    ^args at: 1",
          "literals": [],
          "methodName": "argument",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "selector:": {
          "src": "selector: aSymbol\n    \"Set the receiver's selector\"\n    selector := aSymbol",
          "literals": [],
          "methodName": "selector:",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n\n    (self selector includes: $:)\n\tifFalse: [\n\t    aStream nextPutAll: self selector.\n\t    self arguments do: [ :arg |\n\t\taStream\n\t\t    nextPutAll: ' <';\n\t\t    print: arg;\n\t\t    nextPutAll: '> '\n\t    ]\n\t]\n\tifTrue: [\n\t    (self selector substrings: $:) with: self arguments do: [:sel :arg |\n\t\taStream\n\t\t    nextPutAll: sel;\n\t\t    nextPutAll: ': <';\n\t\t    print: arg;\n\t\t    nextPutAll: '> '\n\t    ]\n\t]",
          "literals": [],
          "methodName": "printOn:",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "sendTo:": {
          "src": "sendTo: aReceiver\n    \"Resend to aReceiver\"\n    ^aReceiver perform: selector withArguments: args",
          "literals": [],
          "methodName": "sendTo:",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "arguments:": {
          "src": "arguments: anArray\n    \"Set the receiver's arguments\"\n    args := anArray",
          "literals": [],
          "methodName": "arguments:",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "selector:arguments:": {
          "src": "selector: aSymbol arguments: anArray\n    \"Create a new Message with the given selector and arguments\"\n    ^self new selector: aSymbol; arguments: anArray",
          "literals": [],
          "methodName": "selector:arguments:",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "selector": {
          "src": "selector\n    \"Answer the receiver's selector\"\n    ^selector",
          "literals": [],
          "methodName": "selector",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "arguments": {
          "src": "arguments\n    \"Answer the receiver's arguments\"\n    ^args",
          "literals": [],
          "methodName": "arguments",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        },
        "reinvokeFor:": {
          "src": "reinvokeFor: aReceiver\n    \"Resend to aReceiver - present for compatibility\"\n    ^aReceiver perform: selector withArguments: args",
          "literals": [],
          "methodName": "reinvokeFor:",
          "className": "Message",
          "category": "creating instances",
          "byteCodes": []
        }
      },
      "subclasses": [
        {
          "className": "DirectedMessage",
          "instance_methods": {},
          "class_methods": {
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n\n    aStream print: receiver; space.\n    super printOn: aStream",
              "literals": [],
              "methodName": "printOn:",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "receiver": {
              "src": "receiver\n    \"Answer the receiver\"\n    ^receiver",
              "literals": [],
              "methodName": "receiver",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "selector:arguments:receiver:": {
              "src": "selector: aSymbol arguments: anArray receiver: anObject\n    \"Create a new instance of the receiver\"\n\n    ^(super selector: aSymbol arguments: anArray)\n\treceiver: anObject",
              "literals": [],
              "methodName": "selector:arguments:receiver:",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "reconstructOriginalObject": {
              "src": "reconstructOriginalObject\n    \"This method is used when DirectedMessages are used together\n     with PluggableProxies (see ObjectDumper).  It sends the receiver\n     to reconstruct the object that was originally stored.\"\n    ^self send",
              "literals": [],
              "methodName": "reconstructOriginalObject",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "selector:arguments:": {
              "src": "selector: aSymbol arguments: anArray \n    self shouldNotImplement",
              "literals": [],
              "methodName": "selector:arguments:",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "receiver:": {
              "src": "receiver: anObject\n    \"Change the receiver\"\n    receiver := anObject",
              "literals": [],
              "methodName": "receiver:",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "send": {
              "src": "send\n    \"Send the message\"\n    ^self sendTo: receiver",
              "literals": [],
              "methodName": "send",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            },
            "value": {
              "src": "value\n    \"Send the message (this message provides interoperability\n     between DirectedMessages and blocks)\"\n    ^self sendTo: receiver",
              "literals": [],
              "methodName": "value",
              "className": "DirectedMessage",
              "category": "creating instances",
              "byteCodes": []
            }
          },
          "subclasses": []
        }
      ]
    },
    {
      "className": "MethodInfo",
      "instance_methods": {
        "selector:": {
          "src": "selector: aSymbol\n    \"Set the selector through which the method is called\"\n    selector := aSymbol",
          "literals": [],
          "methodName": "selector:",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "methodClass": {
          "src": "methodClass\n    \"Answer the class in which the method is defined\"\n    ^class",
          "literals": [],
          "methodName": "methodClass",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "category:": {
          "src": "category: aCategory\n    \"Set the method category\"\n    category := aCategory",
          "literals": [],
          "methodName": "category:",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "sourceString": {
          "src": "sourceString\n    \"Answer a String containing the method source code\"\n    ^sourceCode asString",
          "literals": [],
          "methodName": "sourceString",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "sourceFile": {
          "src": "sourceFile\n    \"Answer the name of the file where the method source code is\"\n    ^sourceCode fileName",
          "literals": [],
          "methodName": "sourceFile",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "sourceCode": {
          "src": "sourceCode\n    \"Answer a FileSegment or String or nil containing the method source code\"\n    ^sourceCode",
          "literals": [],
          "methodName": "sourceCode",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "setSourceCode:": {
          "src": "setSourceCode: source\n    sourceCode := source",
          "literals": [],
          "methodName": "setSourceCode:",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "selector": {
          "src": "selector\n    \"Answer the selector through which the method is called\"\n    ^selector",
          "literals": [],
          "methodName": "selector",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "methodClass:": {
          "src": "methodClass: aClass\n    \"Set the class in which the method is defined\"\n    class := aClass",
          "literals": [],
          "methodName": "methodClass:",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "category": {
          "src": "category\n    \"Answer the method category\"\n    ^category",
          "literals": [],
          "methodName": "category",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "sourcePos": {
          "src": "sourcePos\n    \"Answer the starting position of the method source code in the sourceFile\"\n    ^sourceCode filePos",
          "literals": [],
          "methodName": "sourcePos",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "=": {
          "src": "= aMethodInfo\n    \"Compare the receiver and aMethodInfo, answer whether they're equal\"\n\n    self class == aMethodInfo class ifFalse: [ ^false ].\n    self == aMethodInfo ifTrue: [ ^true ].\n\n    sourceCode = aMethodInfo sourceCode ifFalse: [ ^false ].\n    ^category = aMethodInfo category",
          "literals": [],
          "methodName": "=",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "stripSourceCode": {
          "src": "stripSourceCode\n    \"Remove the reference to the source code for the method\"\n    sourceCode := nil",
          "literals": [],
          "methodName": "stripSourceCode",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        },
        "hash": {
          "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^sourceCode hash bitXor: category hash",
          "literals": [],
          "methodName": "hash",
          "className": "MethodInfo",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "ObjectMemory",
      "instance_methods": {},
      "class_methods": {
        "update:": {
          "src": "update: aspect\n    \"Do any global tasks for the ObjectMemory events.\"\n    aspect == #returnFromSnapshot ifFalse: [ ^self ].\n\n    ContextPart checkPresenceOfJIT.",
          "literals": [],
          "methodName": "update:",
          "className": "ObjectMemory",
          "category": "<unknown>",
          "byteCodes": []
        },
        "initialize": {
          "src": "initialize\n    \"Initialize the globals\"\n\n    \"This method is called after all the kernel Smalltalk classes have been\n     loaded.  It generally performs any initializations that might depend on\n     the full Smalltalk class hierarchy being defined. After this is file is\n     loaded, some 'advanced' class definitions are loaded (CFuncs, Autoload,\n     exception handling, ...) and then the binary image is saved.\"\n\n    Smalltalk at: #Dependencies put: (IdentityDictionary new).\n\n    Fraction initialize.\n    LargeInteger initialize.\n    Date initialize.\n    Time initialize.\n    FileDescriptor initialize.\n    Delay initialize.\n\n    Smalltalk addFeature: #Kernel.\n    KernelInitialized := true.\n    self addDependent: self.\n    self changed: #returnFromSnapshot",
          "literals": [],
          "methodName": "initialize",
          "className": "ObjectMemory",
          "category": "<unknown>",
          "byteCodes": []
        },
        "snapshot": {
          "src": "snapshot\n    \"Save a snapshot on the image file that was loaded on startup.\"\n    self snapshot: File image",
          "literals": [],
          "methodName": "snapshot",
          "className": "ObjectMemory",
          "category": "<unknown>",
          "byteCodes": []
        }
      },
      "subclasses": []
    },
    {
      "className": "PackageLoader",
      "instance_methods": {},
      "class_methods": {
        "primFileInPackage:": {
          "src": "primFileInPackage: package\n    \"Private - File in the given package without paying attention at\n     dependencies and C callout availability\"\n    | dir |\n    (self hasFeature: package) ifTrue: [ ^self ].\n\n    Transcript\n\tnextPutAll: 'Loading package ', package;\n\tnl.\n\n    dir := Directory working.\n    Directory working: (self directoryFor: package).\n    (self modulesFor: package) do: [ :each | DLD addModule: each ].\n    (self fileInsFor: package) do: [ :each | FileStream fileIn: each ].\n    Directory working: dir.\n\n    Smalltalk addFeature: package asSymbol",
          "literals": [],
          "methodName": "primFileInPackage:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "extractDependenciesFor:onError:": {
          "src": "extractDependenciesFor: packagesList onError: aBlock\n    \"Answer an OrderedCollection containing all the packages which you\n     have to load to enable the packages in packagesList, in an appropriate\n     order. For example\n\n     PackageLoader extractDependenciesFor: #('BloxTestSuite' 'Blox' 'Browser')\n\n     on a newly built image will evaluate to an OrderedCollection containing\n     'Kernel', 'C:tclInit', 'Blox', 'BloxTestSuite' and 'Browser'. Note that\n     Blox has been moved before BloxTestSuite.\n     Pass an error message to aBlock if any of the packages needs C call-outs which\n     are not defined.\"\n\n    | toBeLoaded oldDep newDep |\n    toBeLoaded := packagesList asOrderedCollection.\n    oldDep := packagesList.\n    [   newDep := Set new.\n\toldDep do: [ :each |\n\t    (self hasFeature: each) ifFalse: [\n\t\t(self isCallout: each)\n\t\t    ifTrue: [ ^aBlock value: 'C callout not available: ', each ].\n\t\t(self isLoadable: each)\n\t\t    ifFalse: [ ^aBlock value: 'package not available: ', each ].\n\t\tnewDep addAll: (self prerequisitesFor: each)\n\t    ]\n\t].\n\n\t\"I don't think there will never be lots of packages in newDep (say\n\t (more than 5), so I think it is acceptable to remove duplicates\n\t this naive way.\n\t Note that we remove duplicates from toBeLoaded so that prerequisites\n\t are always loaded *before*.\"\n\ttoBeLoaded removeAll: newDep ifAbsent: [ :doesNotMatter | ].\n\tnewDep isEmpty\n    ]   whileFalse: [\n\ttoBeLoaded addAllFirst: newDep.\n\t\n\t\"Proceed recursively with the prerequisites for newDep\"\n\toldDep := newDep.\n    ].\n    ^toBeLoaded",
          "literals": [],
          "methodName": "extractDependenciesFor:onError:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "fileInsFor:": {
          "src": "fileInsFor: package\n    \"Answer a Set of Strings containing the filenames of the given package's\n     file-ins (relative to the directory answered by #directoryFor:)\"\n    ^(self filesFor: package) select: [ :each | '*.st' match: each ]",
          "literals": [],
          "methodName": "fileInsFor:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "stillValid": {
          "src": "stillValid\n    ^{ self packageFileName. self localPackageFileName. self systemPackageFileName } \n\tallSatisfy: [ :name || file |\n\t    file := File name: name.\n\t    file exists not or: [ file lastModifyTime < LoadDate ]\n\t]",
          "literals": [],
          "methodName": "stillValid",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "fileInPackage:": {
          "src": "fileInPackage: package\n    \"File in the given package into GNU Smalltalk.\"\n    self fileInPackages: {package}",
          "literals": [],
          "methodName": "fileInPackage:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "packageFileName": {
          "src": "packageFileName\n    ^Directory kernel, '/../packages'",
          "literals": [],
          "methodName": "packageFileName",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "ignoreCallouts": {
          "src": "ignoreCallouts\n    \"Answer whether unavailable C callouts must generate errors or not.\"\n    ^IgnoreCallouts",
          "literals": [],
          "methodName": "ignoreCallouts",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "canLoad:": {
          "src": "canLoad: package\n    \"Answer whether all the needed C call-outs are registered within\n     GNU Smalltalk\"\n    self\n\textractDependenciesFor: {package}\n\tonError: [ :errorMessage | ^false ].\n    ^true",
          "literals": [],
          "methodName": "canLoad:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "processPackageFile:baseDirectory:": {
          "src": "processPackageFile: fileName baseDirectory: baseDir\n    \"Private - Process each non-empty line in the packages file, passing\n     to #line:state: a TokenStream containing the line's contents\n     and an association object initialized to nil->1.\n     Every character in line, after a #, is discarded as a comment. \"\n\n    | file line discard ch tokens state |\n    file := [ FileStream open: fileName mode: FileStream read ]\n\ton: Error\n\tdo: [ :ex | ex return: nil ].\n\n    file isNil ifTrue: [ ^self ].\n    line := WriteStream on: (String new: 50).\n    discard := false. \n    state := nil -> 1.\n\n    [ file atEnd ] whileFalse: [\n\tch := file next.\n\tdiscard ifFalse: [\n\t    (discard := (ch = $#))\n\t\tifFalse: [ line nextPut: ch ].\n\t].\n\tch = Character cr ifTrue: [ file peekFor: (ch := Character nl) ].\n\tch = Character nl ifTrue: [\n\t    tokens := TokenStream on: line contents.\n\t    tokens atEnd ifFalse: [\n\t\tself line: tokens state: state baseDirectory: baseDir.\n\t\tline emptyStream\n\t    ].\n\t    discard := false\n\t].\n    ].\n    \n    tokens := TokenStream on: line contents.\n    tokens atEnd ifFalse: [\n\tself line: tokens state: state.\n\tline emptyStream\n    ].\n    file close.\n    state value = 1 ifFalse: [ \n\t^self error: 'bad packages file'\n    ].",
          "literals": [],
          "methodName": "processPackageFile:baseDirectory:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "isCallout:": {
          "src": "isCallout: feature\n    \"Private - Answer whether the given `feature' represents a C callout in the\n     form C:funcName\"\n    ^(feature size > 2) and: [\n\t((feature at: 1) = $C) & ((feature at: 2) = $:)\n    ]",
          "literals": [],
          "methodName": "isCallout:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "systemPackageFileName": {
          "src": "systemPackageFileName\n    ^Directory systemKernel, '/../packages'",
          "literals": [],
          "methodName": "systemPackageFileName",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "fileInPackages:": {
          "src": "fileInPackages: packagesList\n    \"File in all the packages in packagesList into GNU Smalltalk.\"\n    | toBeLoaded |\n    toBeLoaded := self\n\textractDependenciesFor: packagesList\n\tonError: [ :errorMessage | ^self error: errorMessage ].\n\t\n    toBeLoaded do: [ :each | self primFileInPackage: each ]",
          "literals": [],
          "methodName": "fileInPackages:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "localPackageFileName": {
          "src": "localPackageFileName\n    ^Directory image, '/packages'",
          "literals": [],
          "methodName": "localPackageFileName",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "flush": {
          "src": "flush\n    \"Set to reload the `packages' file the next time it is needed.\"\n    LoadDate := nil",
          "literals": [],
          "methodName": "flush",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "refreshDependencies": {
          "src": "refreshDependencies\n    \"Reload the `packages' file in the image and kernel directories\"\n    | state |\n    LoadDate isNil ifFalse: [\n\tself stillValid ifTrue: [ ^self ]\n    ].\n\n    LoadDate := Date dateAndTimeNow.\n    Files := Dictionary new.\n    Directories := Dictionary new.\n    Prerequisites := Dictionary new.\n    self\n\tprocessPackageFile: self systemPackageFileName\n\tbaseDirectory: Directory systemKernel, '/..'.\n    self\n\tprocessPackageFile: self packageFileName\n\tbaseDirectory: Directory kernel, '/..'.\n    self\n\tprocessPackageFile: self localPackageFileName\n\tbaseDirectory: Directory image.",
          "literals": [],
          "methodName": "refreshDependencies",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "isLoadable:": {
          "src": "isLoadable: feature\n    \"Private - Answer whether the packages file includes an entry for `feature'\"\n    self refreshDependencies.\n    ^Files includesKey: feature asString",
          "literals": [],
          "methodName": "isLoadable:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "modulesFor:": {
          "src": "modulesFor: package\n    \"Answer a Set of Strings containing the filenames of the given package's\n     file-ins (relative to the directory answered by #directoryFor:)\"\n    ^(self filesFor: package) reject: [ :each | '*.st' match: each ]",
          "literals": [],
          "methodName": "modulesFor:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "filesFor:": {
          "src": "filesFor: package\n    \"Answer a Set of Strings containing the filenames of the given package's\n     files (file-ins are relative to the directory answered by #directoryFor:,\n     shared modules are relative to the ModulePath)\"\n    self refreshDependencies.\n    ^Files at: package asString",
          "literals": [],
          "methodName": "filesFor:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "prerequisitesFor:": {
          "src": "prerequisitesFor: package\n    \"Answer a Set of Strings containing the prerequisites for the given package\"\n    self refreshDependencies.\n    ^Prerequisites at: package asString",
          "literals": [],
          "methodName": "prerequisitesFor:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "addPackage:directory:fileIn:needs:": {
          "src": "addPackage: package directory: dir fileIn: fileIns needs: prerequisites\n    \"Add the given package to the `packages' file, with the given\n     directory (if relative, it is relative to the kernel directory),\n     fileIns and prerequisites. fileIns and prerequisites should be\n     two Collections of Strings.\n     Note that none of this fields are optional. If there are no prere-\n     quisites, just use #('Kernel') as the prerequisites.\"\n    | file |\n    fileIns isEmpty\n\tifTrue: [ SystemExceptions InvalidArgument signalOn: fileIns reason: 'parameter not optional' ].\n    prerequisites isEmpty\n\tifTrue: [ SystemExceptions InvalidArgument signalOn: prerequisites reason: 'parameter not optional' ].\n    dir isEmpty\n\tifTrue: [ SystemExceptions InvalidArgument signalOn: dir reason: 'parameter not optional' ].\n\n    Prerequisites isNil ifFalse: [\n\tself refreshDependencies.\n\tPrerequisites at: package asString put: prerequisites asSet.\n\tFiles at: package asString put: fileIns.\n\tDirectories at: package asString put: dir.\n    ].\n\n    file := FileStream\n\topen: Directory image, '/packages'\n\tmode: FileStream append\n    file\n\tnl;\n\tnl;\n\tnextPutAll: '# Added on';\n\tprint: Date dateAndTimeNow; nl;\n\tnextPutAll: package; nl;\n\tnextPutAll: '   '.\n\n    prerequisites do: [ :each | file space; nextPutAll: each ].\n\n    file\n\tnl;\n\tnextPutAll: '   '.\n\n    fileIns do: [ :each | file space; nextPutAll: each ].\n\n    file\n\tnl;\n\tnextPutAll: '    ';\n\tnextPutAll: dir;\n\tnl;\n\tclose.",
          "literals": [],
          "methodName": "addPackage:directory:fileIn:needs:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "directoryFor:": {
          "src": "directoryFor: package\n    \"Answer a complete path to the given package's file-in\"\n    self refreshDependencies.\n    ^Directories at: package asString.",
          "literals": [],
          "methodName": "directoryFor:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "line:state:baseDirectory:": {
          "src": "line: line state: state baseDirectory: baseDir\n    \"Private - Parse the given line (a TokenStream) of the `packages' file,\n     expecting the file as a sequence of:\n     - line with package name\n     - line with package prerequisites (either C callouts in the form\n       C:funcName or package names)\n     - line with file-ins\n     - line with the file-ins' directory, relative to the kernel directory.\n     \n     Blank lines are discarded, like everything coming after a # field.\"\n\n    | coll dir |\n    state value = 1 ifTrue: [\n\t^state key: {line next. Set new. OrderedCollection new} value: 2\n    ].\n    state value = 2 ifTrue: [\n\tcoll := state key at: 2.\n\t[ line atEnd ] whileFalse: [ coll add: line next ].\n\t^state value: 3\n    ].\n    state value = 3 ifTrue: [\n\tcoll := state key at: 3.\n\t[ line atEnd ] whileFalse: [ coll add: line next ].\n\t^state value: 4.\n    ].\n    state value = 4 ifTrue: [\n\t| dir |\n\tdir := line next.\n        (dir size = 1 or: [ \n\t    ((dir at: 1) ~= $/) & ((dir at: 1) ~= $\\) & (dir includes: $:) not])\n\t        ifTrue: [ dir := baseDir, '/', dir ].\n\n\t(Directory name: dir) exists ifTrue: [\n\t    Prerequisites at: (state key at: 1) put: (state key at: 2).\n\t    Files at: (state key at: 1) put: (state key at: 3).\n\t    Directories at: (state key at: 1) put: dir\n\t].\n\t^state value: 1.\n    ]",
          "literals": [],
          "methodName": "line:state:baseDirectory:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "ignoreCallouts:": {
          "src": "ignoreCallouts: aBoolean\n    \"Set whether unavailable C callouts must generate errors or not.\"\n    IgnoreCallouts := aBoolean",
          "literals": [],
          "methodName": "ignoreCallouts:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        },
        "hasFeature:": {
          "src": "hasFeature: feature\n    \"Private - Answer whether the given `feature' (either a C callout in the\n     form C:funcName or a package name) is present in GNU Smalltalk\"\n    | descriptor |\n    (self isCallout: feature)\n\tifFalse: [ ^Smalltalk hasFeatures: feature asSymbol ].\n\n    ^IgnoreCallouts or: [\n\tCFunctionDescriptor isFunction: (feature copyFrom: 3 to: feature size)]",
          "literals": [],
          "methodName": "hasFeature:",
          "className": "PackageLoader",
          "category": "<unknown>",
          "byteCodes": []
        }
      },
      "subclasses": []
    },
    {
      "className": "Point",
      "instance_methods": {
        "@": {
          "src": "@ y\n    \"Answer a new point whose x is the receiver and whose y is y\"\n    ^ Point x: self y: y",
          "literals": [],
          "methodName": "@",
          "className": "Number",
          "category": "point functions",
          "byteCodes": []
        },
        "<=": {
          "src": "<= aPoint\n    \"Answer whether aPoint is equal to the receiver, or the receiver\n     is higher and to the left of aPoint\"\n    ^(self x <= aPoint x) and: [ (self y <= aPoint y) ]",
          "literals": [],
          "methodName": "<=",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "x:": {
          "src": "x: aNumber\n    \"Set the x coordinate to aNumber\"\n    x := aNumber",
          "literals": [],
          "methodName": "x:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Print Smalltalk code compiling to the receiver on aStream\"\n    aStream nextPut: $(;\n\tstore: x;\n\tnextPutAll: ' @ ';\n\tstore: y;\n\tnextPut: $)",
          "literals": [],
          "methodName": "storeOn:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "x:y:": {
          "src": "x: anXNumber y: aYNumber\n    \"Set the x and y coordinate to anXNumber and aYNumber, respectively\"\n    x := anXNumber.\n    y := aYNumber",
          "literals": [],
          "methodName": "x:y:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "grid:": {
          "src": "grid: aPoint\n    \"Answer a new point whose coordinates are rounded towards the nearest\n     multiple of aPoint\"\n    ^Point \n\tx: (self x roundTo: (aPoint x))\n\ty: (self y roundTo: (aPoint y))",
          "literals": [],
          "methodName": "grid:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "truncatedGrid:": {
          "src": "truncatedGrid: aPoint\n    \"Answer a new point whose coordinates are rounded towards -infinity,\n     to a multiple of grid (which must be a Point)\"\n    ^Point\n\tx: (self x truncateTo: (aPoint x))\n\ty: (self y truncateTo: (aPoint y))",
          "literals": [],
          "methodName": "truncatedGrid:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "arcTan": {
          "src": "arcTan\n    \"Answer the angle (measured counterclockwise) between the receiver and\n     a ray starting in (0, 0) and moving towards (1, 0) - i.e. 3 o'clock\"\n\n    | result |\n    self x = 0 ifTrue: [ ^self y sign * FloatD pi / -2 ].\n    \n    result := (self y / self x) arcTan.\n    self x < 0 ifTrue: [ result := result + FloatD pi ].\n    result > FloatD pi ifTrue: [ result := result - FloatD pi - FloatD pi ].\n    ^result",
          "literals": [],
          "methodName": "arcTan",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "min:": {
          "src": "min: aPoint\n    \"Answer self if it is higher and to the left of aPoint, aPoint otherwise\"\n    (self < aPoint)\n       ifTrue: [^ self ]\n       ifFalse:[^ aPoint ]",
          "literals": [],
          "methodName": "min:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "//": {
          "src": "// scale\n    \"Divide the receiver by scale, which can be a Number or a Point, with\n     truncation towards -infinity\"\n    | scalePoint |\n    scalePoint := scale asPoint.\n    ^Point x: (self x // scalePoint x) y: (self y // scalePoint y)",
          "literals": [],
          "methodName": "//",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "new": {
          "src": "new\n    \"Create a new point with both coordinates set to 0\"\n    ^self basicNew x: 0 y: 0",
          "literals": [],
          "methodName": "new",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "y:": {
          "src": "y: aNumber\n    \"Set the y coordinate to aNumber\"\n    y := aNumber",
          "literals": [],
          "methodName": "y:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "normal": {
          "src": "normal\n    \"Rotate the Point 90degrees clockwise and get the unit vector\"\n    | len |\n    len := ((self x squared) + (self y squared)) sqrt.\n    ^Point x: (self y negated / len) y: (x / len)",
          "literals": [],
          "methodName": "normal",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "dotProduct:": {
          "src": "dotProduct: aPoint\n    \"Answer the dot product between the receiver and aPoint\"\n    ^(self x * aPoint x) + (self y * aPoint y)",
          "literals": [],
          "methodName": "dotProduct:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "max:": {
          "src": "max: aPoint\n    \"Answer self if it is lower and to the right of aPoint, aPoint otherwise\"\n    (self > aPoint)\n       ifTrue: [ ^self ]\n       ifFalse:[ ^aPoint ]",
          "literals": [],
          "methodName": "max:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "dist:": {
          "src": "dist: aPoint\n    \"Answer the distance between the receiver and aPoint\"\n    | a b |\n    a := self x - aPoint x.\n    b := self y - aPoint y.\n    ^((a squared) + (b squared)) sqrt",
          "literals": [],
          "methodName": "dist:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "truncateTo:": {
          "src": "truncateTo: grid\n    \"Answer a new point whose coordinates are rounded towards -infinity,\n     to a multiple of grid (which must be a Number)\"\n    ^Point x: (self x truncateTo: grid) y: (self y truncateTo: grid)",
          "literals": [],
          "methodName": "truncateTo:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "*": {
          "src": "* scale\n    \"Multiply the receiver by scale, which can be a Number or a Point\"\n    | scalePoint |\n    scalePoint := scale asPoint.\n    ^Point x: (self x * scalePoint x) y: (self y * scalePoint y)",
          "literals": [],
          "methodName": "*",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "asPoint": {
          "src": "asPoint\n    ^self\t\t\t\"But I already AM a point!\"",
          "literals": [],
          "methodName": "asPoint",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "+": {
          "src": "+ delta\n    \"Sum the receiver and delta, which can be a Number or a Point\"\n    | deltaPoint |\n    deltaPoint := delta asPoint.\n    ^Point x: (self x + deltaPoint x) y: (self y + deltaPoint y)",
          "literals": [],
          "methodName": "+",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "-": {
          "src": "- delta\n    \"Subtract delta, which can be a Number or a Point, from the receiver\"\n    | deltaPoint |\n    deltaPoint := delta asPoint.\n    ^Point x: (self x - deltaPoint x) y: (self y - deltaPoint y)",
          "literals": [],
          "methodName": "-",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "/": {
          "src": "/ scale\n    \"Divide the receiver by scale, which can be a Number or a Point, with\n     no loss of precision\"\n    | scalePoint |\n    scalePoint := scale asPoint.\n    ^Point x: (self x / scalePoint x) y: (self y / scalePoint y)",
          "literals": [],
          "methodName": "/",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "abs": {
          "src": "abs\n    \"Answer a new point whose coordinates are the absolute values of the\n     receiver's\"\n    ^Point x: (self x abs) y: (self y abs)",
          "literals": [],
          "methodName": "abs",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Print a representation for the receiver on aStream\"\n    aStream print: x;\n\tnextPut: $@;\n\tprint: y",
          "literals": [],
          "methodName": "printOn:",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "x": {
          "src": "x\n    \"Answer the x coordinate\"\n    ^x",
          "literals": [],
          "methodName": "x",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "y": {
          "src": "y\n    \"Answer the y coordinate\"\n    ^y",
          "literals": [],
          "methodName": "y",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "rounded": {
          "src": "rounded\n    \"Answer a new point whose coordinates are rounded to the nearest integer\"\n    ^Point x: (self x rounded) y: (self y rounded)",
          "literals": [],
          "methodName": "rounded",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "transpose": {
          "src": "transpose\n    \"Answer a new point whose coordinates are the receiver's coordinates\n     exchanged (x becomes y, y becomes x)\"\n    ^Point x: y y: x",
          "literals": [],
          "methodName": "transpose",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "<": {
          "src": "< aPoint\n    \"Answer whether the receiver is higher and to the left of aPoint\"\n    ^(self x < aPoint x) and: [ (self y < aPoint y) ]",
          "literals": [],
          "methodName": "<",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "=": {
          "src": "= aPoint\n    \"Answer whether the receiver is equal to aPoint\"\n    ^(aPoint class == Point) and: [ (self x = aPoint x) & (self y = aPoint y) ]",
          "literals": [],
          "methodName": "=",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        "hash": {
          "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^self x hash bitXor: self y hash",
          "literals": [],
          "methodName": "hash",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        ">": {
          "src": "> aPoint\n    \"Answer whether the receiver is lower and to the right of aPoint\"\n    ^(self x > aPoint x) and: [ (self y > aPoint y) ]",
          "literals": [],
          "methodName": ">",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        },
        ">=": {
          "src": ">= aPoint\n    \"Answer whether aPoint is equal to the receiver, or the receiver\n     is lower and to the right of aPoint\"\n    ^(self x >= aPoint x) and: [ (self y >= aPoint y) ]",
          "literals": [],
          "methodName": ">=",
          "className": "Point",
          "category": "point functions",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "ProcessorScheduler",
      "instance_methods": {
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Store onto aStream a Smalltalk expression which evaluates to the receiver\"\n    aStream nextPutAll: 'Processor'",
          "literals": [],
          "methodName": "storeOn:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "timeSlice:": {
          "src": "timeSlice: milliSeconds\n    \"Set the timeslice that is assigned to each Process before it is\n     automatically preempted by the system.  Setting this to zero\n     disables preemptive multitasking.  Note that the system by\n     default is compiled with preemptive multitasking disabled, and\n     that even if it is enabled it will surely work only under BSD\n     derivatives (or, in general, systems that support ITIMER_VIRTUAL).\"\n    processTimeslice := milliSeconds",
          "literals": [],
          "methodName": "timeSlice:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "timeSlice": {
          "src": "timeSlice\n    \"Answer the timeslice that is assigned to each Process before it\n     is automatically preempted by the system (in milliseconds).  An\n     answer of zero means that preemptive multitasking is disabled.\n     Note that the system by default is compiled without preemptive\n     multitasking, and that even if it is enabled it will work only\n     under BSD derivatives (or, in general, systems that support\n     ITIMER_VIRTUAL).\"\n    ^processTimeslice",
          "literals": [],
          "methodName": "timeSlice",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "activeProcess": {
          "src": "activeProcess\n    \"Answer the active process\"\n    ^activeProcess",
          "literals": [],
          "methodName": "activeProcess",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "userInterruptPriority": {
          "src": "userInterruptPriority\n    \"Answer the priority for user interrupt-priority processes.\n    Processes run at this level will preempt the window scheduler\n    and should, therefore, not consume the processor forever.\"\n    ^5",
          "literals": [],
          "methodName": "userInterruptPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "rockBottomPriority": {
          "src": "rockBottomPriority\n    \"Answer the lowest valid priority\"\n    ^1",
          "literals": [],
          "methodName": "rockBottomPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "systemBackgroundPriority": {
          "src": "systemBackgroundPriority\n    \"Answer the priority for system background-priority processes.\n    Examples are an incremental garbage collector or status checker.\"\n\n    ^2",
          "literals": [],
          "methodName": "systemBackgroundPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "yield": {
          "src": "yield\n    \"Let the active process yield control to other processes\"\n    self activeProcess yield",
          "literals": [],
          "methodName": "yield",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "userSchedulingPriority": {
          "src": "userSchedulingPriority\n    \"Answer the priority for user standard-priority processes\"\n    ^4",
          "literals": [],
          "methodName": "userSchedulingPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "unpreemptedPriority": {
          "src": "unpreemptedPriority\n    \"Answer the highest priority avilable in the system; never\n     create a process with this priority, instead use\n     BlockClosure>>#valueWithoutPreemption.\"\n    ^9",
          "literals": [],
          "methodName": "unpreemptedPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "highIOPriority": {
          "src": "highIOPriority\n    \"Answer the priority for system high-priority I/O processes,\n    such as a process handling input from a network.\"\n    ^7",
          "literals": [],
          "methodName": "highIOPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "new": {
          "src": "new\n    \"Error---new instances of ProcessorScheduler should not be created.\"\n\n    self shouldNotImplement",
          "literals": [],
          "methodName": "new",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "terminateActive": {
          "src": "terminateActive\n    \"Terminate the active process\"\n    self activeProcess terminate",
          "literals": [],
          "methodName": "terminateActive",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "lowestPriority": {
          "src": "lowestPriority\n    \"Answer the lowest valid priority\"\n    ^1",
          "literals": [],
          "methodName": "lowestPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "priorityName:": {
          "src": "priorityName: priority\n    \"Private - Answer a name for the given process priority\"\n    ^#('rockBottomPriority' 'systemBackgroundPriority' 'userBackgroundPriority'\n       'userSchedulingPriority' 'userInterruptPriority' 'lowIOPriority'\n       'highIOPriority' 'timingPriority' 'unpreemptedPriority') at: priority",
          "literals": [],
          "methodName": "priorityName:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "idle": {
          "src": "idle\n    \"Private - Call the next idle task\"\n    | index |\n    idleTasks isNil ifTrue: [ ^self ].\n    index := idleTasks at: 1.\n    (idleTasks at: index + 2) value.\n    idleTasks at: 1 put: (index + 1) \\\\ (idleTasks size - 1)",
          "literals": [],
          "methodName": "idle",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "timingPriority": {
          "src": "timingPriority\n    \"Answer the priority for system real-time processes.\"\n    ^8",
          "literals": [],
          "methodName": "timingPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "idleAdd:": {
          "src": "idleAdd: aBlock\n    \"Register aBlock to be executed when things are idle\"\n    idleTasks isNil ifTrue: [ idleTasks := OrderedCollection with: 0 ].\n    idleTasks add: aBlock",
          "literals": [],
          "methodName": "idleAdd:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "processesAt:": {
          "src": "processesAt: aPriority\n    \"Answer a linked list of processes at the given priority\"\n    ^processLists at: aPriority",
          "literals": [],
          "methodName": "processesAt:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "userBackgroundPriority": {
          "src": "userBackgroundPriority\n    \"Answer the priority for user background-priority processes\"\n    ^3",
          "literals": [],
          "methodName": "userBackgroundPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "lowIOPriority": {
          "src": "lowIOPriority\n    \"Answer the priority for system low-priority I/O processes.\n    Examples are the process handling input from the user (keyboard, \n    pointing device, etc.) and the process distributing input from a\n    network.\"\n    ^6",
          "literals": [],
          "methodName": "lowIOPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "highestPriority": {
          "src": "highestPriority\n    \"Answer the highest valid priority\"\n    ^processLists size",
          "literals": [],
          "methodName": "highestPriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Store onto aStream a printed representation of the receiver\"\n    aStream nextPutAll: 'Processor'",
          "literals": [],
          "methodName": "printOn:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "activePriority": {
          "src": "activePriority\n    \"Answer the active process' priority\"\n    ^self activeProcess priority",
          "literals": [],
          "methodName": "activePriority",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        },
        "changePriorityOf:to:": {
          "src": "changePriorityOf: aProcess to: aPriority\n    \"Private - Move aProcess to the execution list for aPriority,\n     answer the new execution list\"\n\n    aProcess priority isNil ifFalse: [\n\t(processLists at: aProcess priority) remove: aProcess ifAbsent: [ ]\n    ].\n    ^(processLists at: aPriority) addLast: aProcess; yourself",
          "literals": [],
          "methodName": "changePriorityOf:to:",
          "className": "ProcessorScheduler",
          "category": "storing",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "Rectangle",
      "instance_methods": {
        "extent": {
          "src": "extent\n    \"Answer the extent of the receiver\"\n    ^corner - origin",
          "literals": [],
          "methodName": "extent",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "origin:": {
          "src": "origin: aPoint\n    \"Change the top-left corner of the receiver to aPoint\"\n    origin := aPoint copy",
          "literals": [],
          "methodName": "origin:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottomLeft:": {
          "src": "bottomLeft: aPoint\n    \"Answer the receiver with the bottom-left changed to aPoint\"\n    origin x: aPoint x.\n    corner y: aPoint y.",
          "literals": [],
          "methodName": "bottomLeft:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "intersect:": {
          "src": "intersect: aRectangle\n    \"Returns the rectangle (if any) created by the overlap of\n     rectangles A and B.\"\n\n    \"This seems to be the right definition...\"\n    ^Rectangle \n\torigin: (origin max: aRectangle origin)\n\tcorner: (corner min: aRectangle corner)\n\n    \"| selfNorm rectNorm left top right bottom |\n\n    selfNorm := self       normalized.\n    rectNorm := aRectangle normalized.\n\n    right  := selfNorm right  min: rectNorm right.\n    left   := selfNorm left   max: rectNorm left.\n    right < left ifTrue: [ ^Rectangle new ].\n\n    bottom := selfNorm bottom min: rectNorm bottom.\n    top    := selfNorm top    max: rectNorm top.\n    bottom < top ifTrue: [ ^Rectangle new ].\n\n    ^Rectangle origin: left @ top corner: right @ bottom\"",
          "literals": [],
          "methodName": "intersect:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "moveTo:": {
          "src": "moveTo: aPoint\n    \"Change the receiver so that the origin moves to aPoint and the size\n     remains unchanged\"\n    | diff |\n    diff := aPoint - origin.\n    origin := aPoint copy.\n    corner := corner + diff",
          "literals": [],
          "methodName": "moveTo:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "corner": {
          "src": "corner\n    \"Answer the corner of the receiver\"\n    ^corner",
          "literals": [],
          "methodName": "corner",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "topRight:": {
          "src": "topRight: aPoint\n    \"Change the receiver's top-right corner to aPoint\"\n    corner x: aPoint x.\n    origin y: aPoint y",
          "literals": [],
          "methodName": "topRight:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "normalize": {
          "src": "normalize\n    \"Normalize the receiver (make origin < corner)\"\n    | t |\n    (origin > corner)\n\tifTrue: [t := corner. corner := origin. origin := t]",
          "literals": [],
          "methodName": "normalize",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "right:": {
          "src": "right: aNumber\n    \"Change the x of the bottom-right corner of the receiver\"\n    corner x: aNumber",
          "literals": [],
          "methodName": "right:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "height": {
          "src": "height\n    \"Answer the height of the receiver\"\n    ^self bottom - self top",
          "literals": [],
          "methodName": "height",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "area": {
          "src": "area\n    \"Answer the receiver's area. The area is the width times the height,\n     so it is possible for it to be negative if the rectangle is not\n     normalized.\"\n    ^self width * self height",
          "literals": [],
          "methodName": "area",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "new": {
          "src": "new\n    \"Answer the (0 @ 0 corner: 0 @ 0) rectangle\"\n\n    ^self origin: 0 @ 0 corner: 0 @ 0",
          "literals": [],
          "methodName": "new",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "leftCenter": {
          "src": "leftCenter\n    \"Answer the center of the receiver's left side\"\n    ^origin x @ self yCenter",
          "literals": [],
          "methodName": "leftCenter",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottom": {
          "src": "bottom\n    \"Answer the corner's y of the receiver\"\n    ^corner y",
          "literals": [],
          "methodName": "bottom",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottomRight:": {
          "src": "bottomRight: aPoint\n    \"Change the bottom-right corner of the receiver\"\n    corner := aPoint copy",
          "literals": [],
          "methodName": "bottomRight:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "height:": {
          "src": "height: aNumber\n    \"Set the height of the receiver\"\n    corner y: (self origin y + aNumber)",
          "literals": [],
          "methodName": "height:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "moveBy:": {
          "src": "moveBy: aPoint\n    \"Change the receiver so that the origin and corner are shifted by aPoint\"\n    origin := origin + aPoint.\n    corner := corner + aPoint",
          "literals": [],
          "methodName": "moveBy:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "amountToTranslateWithin:": {
          "src": "amountToTranslateWithin: aRectangle\n    \"Answer a Point so that if aRectangle is translated by that point,\n     its origin lies within the receiver's.\"\n    (aRectangle contains: self) ifTrue: [ ^0@0 ].\n    ^aRectangle origin - origin",
          "literals": [],
          "methodName": "amountToTranslateWithin:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "insetBy:": {
          "src": "insetBy: delta\n    \"Answer a new rectangle that is the receiver inset by aValue:\n     if aValue is a rectangle, calculate origin=origin+aValue origin,\n     corner=corner-aValue corner; else calculate origin=origin+aValue,\n     corner=corner-aValue.\"\n    (delta isMemberOf: Point) ifTrue:\n       [^Rectangle origin: (origin+delta)\n\t\t   corner: (corner-delta)].\n    (delta isMemberOf: Rectangle) ifTrue:\n       [^Rectangle origin: (origin+(delta origin))\n\t\t   corner: (corner-(delta corner))].\n    (delta isKindOf: Number) ifTrue:\n       [^Rectangle left: (origin x)+delta\n\t\t   right:(corner x)-delta\n\t\t   top:  (origin y)+delta\n\t\t   bottom:(corner y)-delta].\n\n    SystemExceptions WrongClass signalOn: delta\n\tmustBe: {Point. Rectangle. Number}",
          "literals": [],
          "methodName": "insetBy:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "intersects:": {
          "src": "intersects: aRectangle\n    \"Answer true if the receiver intersect aRectangle, i.e. if it contains\n     (see containsPoint:) any of aRectangle corners or if aRectangle contains\n     the receiver\"\n    | pnt |\n    pnt := aRectangle topRight.\n    (self containsPoint: pnt) ifTrue: [ ^true ].\n\n    pnt x: aRectangle left.\n    (self containsPoint: pnt) ifTrue: [ ^true ].\n\n    pnt y: aRectangle bottom.\n    (self containsPoint: pnt) ifTrue: [ ^true ].\n\n    pnt x: aRectangle right.\n    ^(self containsPoint: pnt) or: [ aRectangle contains: self ]",
          "literals": [],
          "methodName": "intersects:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "asRectangle": {
          "src": "asRectangle\n    \"Answer an empty rectangle whose origin is self\"\n    ^Rectangle origin: self corner: self copy",
          "literals": [],
          "methodName": "asRectangle",
          "className": "Point",
          "category": "converting",
          "byteCodes": []
        },
        "left:": {
          "src": "left: aValue\n    \"Set the x of the left edge of the receiver\"\n    origin x: aValue",
          "literals": [],
          "methodName": "left:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "top:": {
          "src": "top: aValue\n    \"Change the y of the receiver's top-left corner\"\n    origin y: aValue",
          "literals": [],
          "methodName": "top:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "width:": {
          "src": "width: aNumber\n    \"Change the receiver's width to aNumber\"\n    corner x: origin x + aNumber",
          "literals": [],
          "methodName": "width:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    aStream print: origin;\n\tnextPutAll: ' corner: ';\n\tprint: corner",
          "literals": [],
          "methodName": "printOn:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "left:right:top:bottom:": {
          "src": "left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber\n    \"Answer a rectangle with the given coordinates\"\n    ^self basicNew\n\torigin: (Point x: leftNumber y: topNumber)\n\tcorner: (Point x: rightNumber y: bottomNumber)",
          "literals": [],
          "methodName": "left:right:top:bottom:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "left": {
          "src": "left\n    \"Answer the x of the left edge of the receiver\"\n    ^origin x",
          "literals": [],
          "methodName": "left",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "rounded": {
          "src": "rounded\n    \"Answer a copy of the receiver with the coordinates rounded to the nearest\n     integers\"\n    ^Rectangle origin: origin rounded corner: corner rounded",
          "literals": [],
          "methodName": "rounded",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "=": {
          "src": "= aRectangle\n    \"Answer whether the receiver is equal to aRectangle\"\n    ^(self class == aRectangle class) \n\tand: [ origin = aRectangle origin\n\t    and: [ corner = aRectangle corner ] ]",
          "literals": [],
          "methodName": "=",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "hash": {
          "src": "hash\n    \"Answer an hash value for the receiver\"\n    ^origin hash bitXor: corner hash",
          "literals": [],
          "methodName": "hash",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "expandBy:": {
          "src": "expandBy: delta\n    \"Answer a new rectangle that is the receiver expanded by aValue:\n     if aValue is a rectangle, calculate origin=origin-aValue origin,\n     corner=corner+aValue corner; else calculate origin=origin-aValue,\n     corner=corner+aValue.\"\n    (delta isMemberOf: Point) ifTrue:\n       [^Rectangle origin: (origin-delta)\n\t\t   corner: (corner+delta)].\n    (delta isMemberOf: Rectangle) ifTrue:\n       [^Rectangle origin: (origin-(delta origin))\n\t\t   corner: (corner+(delta corner))].\n    (delta isKindOf: Number) ifTrue:\n       [^Rectangle left: (origin x)-delta\n\t\t   right:(corner x)+delta\n\t\t   top:  (origin y)-delta\n\t\t   bottom:(corner y)+delta].\n\n    SystemExceptions WrongClass signalOn: delta\n\tmustBe: {Point. Rectangle. Number}",
          "literals": [],
          "methodName": "expandBy:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Store Smalltalk code compiling to the receiver on aStream\"\n    aStream nextPutAll: '(Rectangle origin: ';\n\tstore: origin;\n\tnextPutAll: ' corner: ';\n\tstore: corner;\n\tnextPut: $)",
          "literals": [],
          "methodName": "storeOn:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottomRight": {
          "src": "bottomRight\n    \"Answer the bottom-right corner of the receiver\"\n    ^corner copy",
          "literals": [],
          "methodName": "bottomRight",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "containsPoint:": {
          "src": "containsPoint: aPoint\n    \"Answer true if aPoint is equal to, or below and to the right of, the\n     receiver's origin; and aPoint is above and to the left of the receiver's\n     corner\"\n    ^(aPoint >= origin) and: [aPoint < corner]",
          "literals": [],
          "methodName": "containsPoint:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "merge:": {
          "src": "merge: aRectangle\n    \"Answer a new rectangle which is the smallest rectangle containing\n     both the receiver and aRectangle.\"\n    \n    \"This seems to be the right definition...\"\n    ^Rectangle \n\torigin: (origin min: aRectangle origin)\n\tcorner: (corner max: aRectangle corner)\n\n    \"| orig corn |\n    orig := Point x: ((origin x) min: (aRectangle origin x))\n\t\ty: ((origin y) min: (aRectangle origin y)).\n    corn := Point x: ((corner x) max: (aRectangle corner x))\n\t\ty: ((corner y) max: (aRectangle corner y)).\n    ^Rectangle origin: orig corner: corn\"",
          "literals": [],
          "methodName": "merge:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "normalized": {
          "src": "normalized\n    \"Answer a copy of the receiver which is normalized (has origin < corner)\"\n    ^self copy normalize",
          "literals": [],
          "methodName": "normalized",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "origin": {
          "src": "origin\n    \"Answer the top-left corner of the receiver\"\n    ^origin",
          "literals": [],
          "methodName": "origin",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "yCenter": {
          "src": "yCenter\n    \"Answer the y of the receiver's center\"\n    ^origin y + corner y / 2",
          "literals": [],
          "methodName": "yCenter",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottom:": {
          "src": "bottom: aNumber\n    \"Set the corner's y of the receiver\"\n    corner y: aNumber",
          "literals": [],
          "methodName": "bottom:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "left:top:right:bottom:": {
          "src": "left: l top: t right: r bottom: b\n    \"Change all four the coordinates of the receiver's corners\"\n    origin := l @ t.\n    corner := r @ b",
          "literals": [],
          "methodName": "left:top:right:bottom:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "scaleBy:": {
          "src": "scaleBy: scale\n    \"Answer a copy of the receiver in which the origin and corner are\n     multiplied by scale\"\n    ^Rectangle origin: origin * scale corner: corner * scale",
          "literals": [],
          "methodName": "scaleBy:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "top": {
          "src": "top\n    \"Answer the y of the receiver's top-left corner\"\n    ^origin y",
          "literals": [],
          "methodName": "top",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottomCenter": {
          "src": "bottomCenter\n    \"Answer the center of the receiver's bottom side\"\n    ^self xCenter @ corner y",
          "literals": [],
          "methodName": "bottomCenter",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "copy": {
          "src": "copy\n    \"Return a deep copy of the receiver for safety.\"\n    ^self deepCopy",
          "literals": [],
          "methodName": "copy",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "origin:extent:": {
          "src": "origin: pnt1 extent: pnt2\n    \"Change the top-left corner and the size of the receiver\"\n    origin := pnt1 copy.\n    corner := pnt1 + pnt2",
          "literals": [],
          "methodName": "origin:extent:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "bottomLeft": {
          "src": "bottomLeft\n    \"Answer the bottom-left corner of the receiver\"\n    ^origin x @ corner y",
          "literals": [],
          "methodName": "bottomLeft",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "areasOutside:": {
          "src": "areasOutside: aRectangle\n    \"Answer a collection of rectangles containing the parts of the receiver\n     outside of aRectangle. For all points in the receiver, but outside\n     aRectangle, exactly one rectangle in the collection will contain that\n     point.\"\n     \n    \"----------------------------------------------------------------\n    | The basic methodology is to first determine that there is an\n    | intersection by finding the overlapping rectangle.  From the\n    | overlapping rectangle, determine which edges it runs along.\n    | For each edge, if it doesn't run along that edge, add a new\n    | rectangle to the collection.\n    | Most times 2 or 3 rectangles get formed, some times 0, 1 or 4.\n     ----------------------------------------------------------------\"\n    | ansSet rect2 xsect |\n    rect2 := self normalized.\n    xsect := rect2 intersect: aRectangle normalized.\n    xsect area = 0 ifTrue: [ ^{self copy} ].\n\n    ansSet := Set new: 8.\n    rect2 left = xsect left ifFalse: [\n\t ansSet add: (self topLeft corner: xsect left @ self bottom)\n    ].\n    rect2 top = xsect top ifFalse: [\n\t ansSet add: (xsect left @ self top corner: xsect topRight)\n    ].\n    rect2 bottom = xsect bottom ifFalse: [\n\t ansSet add: (xsect bottomLeft corner: xsect right @ self bottom)\n    ].\n    rect2 right = xsect right ifFalse: [\n\t ansSet add: (xsect right @ self top corner: self bottomRight)\n    ].\n    ^ansSet asArray",
          "literals": [],
          "methodName": "areasOutside:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "translateBy:": {
          "src": "translateBy: factor\n    \"Answer a copy of the receiver in which the origin and corner are shifted\n     by aPoint\"\n    ^Rectangle origin: origin + factor corner: corner + factor",
          "literals": [],
          "methodName": "translateBy:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "center": {
          "src": "center\n    \"Answer the center of the receiver\"\n    ^self xCenter @ self yCenter",
          "literals": [],
          "methodName": "center",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "topLeft:": {
          "src": "topLeft: aPoint\n    \"Change the receiver's top-left corner's coordinates to aPoint\"\n    origin := aPoint copy",
          "literals": [],
          "methodName": "topLeft:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "topRight": {
          "src": "topRight\n    \"Answer the receiver's top-right corner\"\n    ^corner x @ origin y",
          "literals": [],
          "methodName": "topRight",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "corner:": {
          "src": "corner: aPoint\n    \"Answer a Rectangle whose origin is the receiver and whose corner\n     is aPoint\"\n    ^Rectangle origin: self corner: aPoint",
          "literals": [],
          "methodName": "corner:",
          "className": "Point",
          "category": "converting",
          "byteCodes": []
        },
        "right": {
          "src": "right\n    \"Answer the x of the bottom-right corner of the receiver\"\n    ^corner x",
          "literals": [],
          "methodName": "right",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "origin:corner:": {
          "src": "origin: pnt1 corner: pnt2\n    \"Change both the origin (top-left corner) and the corner (bottom-right\n     corner) of the receiver\"\n    origin := pnt1 copy.\n    corner := pnt2 copy",
          "literals": [],
          "methodName": "origin:corner:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "xCenter": {
          "src": "xCenter\n    \"Answer the x of the receiver's center\"\n    ^origin x + corner x / 2",
          "literals": [],
          "methodName": "xCenter",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "rightCenter": {
          "src": "rightCenter\n    \"Answer the center of the receiver's right side\"\n    ^corner x @ self yCenter",
          "literals": [],
          "methodName": "rightCenter",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "topLeft": {
          "src": "topLeft\n    \"Answer the receiver's top-left corner\"\n    ^origin copy",
          "literals": [],
          "methodName": "topLeft",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "translatedToBeWithin:": {
          "src": "translatedToBeWithin: aRectangle\n    \"Answer a copy of the receiver that does not extend beyond aRectangle.\"\n\n    ^self translateBy: (self amountToTranslateWithin: aRectangle)",
          "literals": [],
          "methodName": "translatedToBeWithin:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "width": {
          "src": "width\n    \"Answer the receiver's width\"\n    ^self right - self left",
          "literals": [],
          "methodName": "width",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "contains:": {
          "src": "contains: aRectangle\n    \"Answer true if the receiver contains (see containsPoint:) both\n     aRectangle's origin and aRectangle's corner\"\n    ^(self containsPoint: aRectangle origin) and: [\n       (self containsPoint: aRectangle corner)]",
          "literals": [],
          "methodName": "contains:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "topCenter": {
          "src": "topCenter\n    \"Answer the center of the receiver's top side\"\n    ^self xCenter @ origin y",
          "literals": [],
          "methodName": "topCenter",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "insetOriginBy:corner:": {
          "src": "insetOriginBy: originDelta corner: cornerDelta\n    \"Answer a new rectangle that is the receiver inset so that\n     origin=origin+originDelta, corner=corner-cornerDelta.\n     The deltas can be points or numbers\"\n    ^Rectangle origin: origin + originDelta\n\t      corner: corner - cornerDelta",
          "literals": [],
          "methodName": "insetOriginBy:corner:",
          "className": "Rectangle",
          "category": "converting",
          "byteCodes": []
        },
        "extent:": {
          "src": "extent: aPoint\n    \"Answer a Rectangle whose origin is the receiver and whose extent\n     is aPoint\"\n    ^Rectangle origin: self extent: aPoint",
          "literals": [],
          "methodName": "extent:",
          "className": "Point",
          "category": "converting",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "SharedQueue",
      "instance_methods": {
        "next": {
          "src": "next\n    \"Wait for an object to be on the queue, then remove it and answer it\"\n    | result |\n    valueReady wait.\n    queueSem critical: [ result := queue removeFirst ].\n    ^result",
          "literals": [],
          "methodName": "next",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        },
        "new": {
          "src": "new\n    \"Create a new instance of the receiver\"\n    ^self basicNew init: (OrderedCollection new: 10)",
          "literals": [],
          "methodName": "new",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        },
        "init:": {
          "src": "init: aCollection\n    queue := aCollection.\n    valueReady := Semaphore new.\n    queueSem := Semaphore forMutualExclusion",
          "literals": [],
          "methodName": "init:",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        },
        "sortBlock:": {
          "src": "sortBlock: sortBlock\n    \"Create a new instance of the receiver which implements a\n     priority queue with the given sort block\"\n    ^self basicNew init: (SortedCollection sortBlock: sortBlock)",
          "literals": [],
          "methodName": "sortBlock:",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        },
        "isEmpty": {
          "src": "isEmpty\n    \"Answer whether there is an object on the queue\"\n    ^queue isEmpty",
          "literals": [],
          "methodName": "isEmpty",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        },
        "nextPut:": {
          "src": "nextPut: value\n    \"Put value on the queue and answer it\"\n    queueSem critical: [ queue add: value ].\n    valueReady signal.\n    ^value",
          "literals": [],
          "methodName": "nextPut:",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        },
        "peek": {
          "src": "peek\n    \"Wait for an object to be on the queue if necessary, then answer the\n     same object that #next would answer without removing it.\"\n    | result |\n    valueReady wait.\n    queueSem critical: [ result := queue first ].\n    valueReady signal.\n    ^result",
          "literals": [],
          "methodName": "peek",
          "className": "SharedQueue",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "Signal",
      "instance_methods": {
        "exception": {
          "src": "exception\n    \"Answer the CoreException that was raised\"\n    ^exception",
          "literals": [],
          "methodName": "exception",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "parent": {
          "src": "parent\n    \"Answer the parent of the receiver\"\n    ^parent",
          "literals": [],
          "methodName": "parent",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "signalWithArguments:": {
          "src": "signalWithArguments: args\n    \"Raise the exception described by the receiver, passing the parameters in\n     args\"\n\n    \"This is not refactored to avoid too long backtraces\"\n    | signal |\n    signal := signalClass new\n\tinitArguments: args;\n\tinitException: self.\n\n    self instantiateNextHandler: signal.\n    ^signal activateHandler: self isResumable",
          "literals": [],
          "methodName": "signalWithArguments:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "argument": {
          "src": "argument\n    \"Answer the first argument of the receiver\"\n    ^arguments at: 1",
          "literals": [],
          "methodName": "argument",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "retryUsing:": {
          "src": "retryUsing: aBlock\n    \"Execute aBlock reinstating all handlers, and return its result from\n     the #signal method.\"\n\n    CoreException resetAllHandlers.\n    self return: aBlock value",
          "literals": [],
          "methodName": "retryUsing:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "copyFrom:": {
          "src": "copyFrom: aSignal\n    \"Private - Initialize from another instance of Signal\"\n\n    self\n\tinitArguments: aSignal arguments;\n\tmessageText: aSignal messageText;\n\ttag: aSignal tag",
          "literals": [],
          "methodName": "copyFrom:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "add:": {
          "src": "add: aTrappableEvent\n    \"Private - Add aTrappableEvent to the receiver and answer aTrappableEvent\"\n    aTrappableEvent allExceptionsDo: [ :exc | collection add: exc ].\n\n    ^aTrappableEvent",
          "literals": [],
          "methodName": "add:",
          "className": "ExceptionSet",
          "category": "built ins",
          "byteCodes": []
        },
        "tag": {
          "src": "tag\n    \"Answer an exception's tag value.  If not specified, it\n     is the same as the message text.\"\n    ^tag == self noTag\n\tifTrue: [ self messageText ]\n\tifFalse: [ tag ]",
          "literals": [],
          "methodName": "tag",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "resetHandler": {
          "src": "resetHandler\n    \"Mark the handler that the receiver is using as not active.\"\n    context isNil ifFalse: [\n\tcontext at: context numArgs put: previousState ]",
          "literals": [],
          "methodName": "resetHandler",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "signal": {
          "src": "signal\n    \"Raise the exception described by the receiver, passing no parameters\"\n    \n    \"This is not refactored to avoid too long backtraces\"\n    | signal |\n    signal := signalClass new\n\tinitArguments: #();\n\tinitException: self.\n\n    self instantiateNextHandler: signal.\n    ^signal activateHandler: self isResumable",
          "literals": [],
          "methodName": "signal",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "signalClass": {
          "src": "signalClass\n    \"Answer the subclass of Signal to be passed to handler blocks\n     that handle the receiver\"\n    ^signalClass",
          "literals": [],
          "methodName": "signalClass",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "new": {
          "src": "new\n    \"Private - Answer a new, empty ExceptionSet\"\n    ^self basicNew\n\tcollection: Set new",
          "literals": [],
          "methodName": "new",
          "className": "ExceptionSet",
          "category": "built ins",
          "byteCodes": []
        },
        "messageText": {
          "src": "messageText\n    \"Answer an exception's message text.\"\n    ^messageText",
          "literals": [],
          "methodName": "messageText",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "initArguments:": {
          "src": "initArguments: args\n    \"Private - set the Signal's arguments to args.\"\n\n    arguments := args.\n    tag := self noTag.",
          "literals": [],
          "methodName": "initArguments:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "pass": {
          "src": "pass\n    \"Yield control to the enclosing exception action for the receiver.\n     Similar to #outer, but control does not return to the currently active exception\n     handler.\"\n\n    ^self exception passFor: self",
          "literals": [],
          "methodName": "pass",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "defaultHandler:": {
          "src": "defaultHandler: aBlock\n    \"Set the default handler of the receiver to aBlock. A Signal object will\n     be passed to aBlock\"\n\n    defaultHandler := aBlock",
          "literals": [],
          "methodName": "defaultHandler:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "outer": {
          "src": "outer\n    \"Raise the exception that instantiated the receiver, passing the same\n     parameters.\n     If the receiver is resumable and the evaluated exception action resumes\n     then the result returned from #outer will be the resumption value of the\n     evaluated exception action. If the receiver is not resumable or if the\n     exception action does not resume then this message will not return, and\n     #outer will be equivalent to #pass.\"\n\n    ^self exception signalFor: self",
          "literals": [],
          "methodName": "outer",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        ",": {
          "src": ", aTrappableEvent\n    \"Answer an ExceptionSet containing all the exceptions in the\n     receiver and all the exceptions in aTrappableEvent\"\n\n    ^ExceptionSet new\n\tadd: self;\n\tadd: aTrappableEvent;\n\tyourself",
          "literals": [],
          "methodName": ",",
          "className": "TrappableEvent",
          "category": "built ins",
          "byteCodes": []
        },
        "basicMessageText": {
          "src": "basicMessageText\n    \"Answer an exception's message text.  Do not override this method.\"\n    ^messageText",
          "literals": [],
          "methodName": "basicMessageText",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "instantiateNextHandler:": {
          "src": "instantiateNextHandler: aSignal\n    \"Private - Tell aSignal what it needs on the next handler for the receiver.\n     If one is not found found, look for an handler for our parent, until one\n     is found or ExAll if reached and there is no handler. In this case, answer\n     the default handler for anException.\"\n\n    | exc nested |\n    exc := self.\n\n    [\n\tnested := false. \n\tthisContext \n\t    scanBacktraceFor:\n\t\t#(#on:do:\n\t\t  #on:do:on:do:\n\t\t  #on:do:on:do:on:do:\n\t\t  #on:do:on:do:on:do:on:do:\n\t\t  #on:do:on:do:on:do:on:do:on:do:)\n\t    do: [ :context || best bestGoodness goodness activeHandlers |\n\t\tbestGoodness := -1.\n\t\tactiveHandlers := context at: context numArgs + 1.\n\n\t\t1 to: context numArgs - 1 by: 2 do: [ :i |\n\t\t    goodness := (context at: i) goodness: exc.\n\t\t    goodness > -1 ifTrue: [\n\t\t        (activeHandlers bitAt: i) = 1 ifTrue: [\n\t\t\t    \"Sorry, this handler is already active...\"\n\t\t\t    nested := true.\n\t\t\t    goodness := -1.\n\t\t\t]\n\t\t    ].\n\t\t    goodness > bestGoodness ifTrue: [\n\t\t\tbest := i.\n\t\t\tbestGoodness := goodness.\n\t\t    ]\n\t\t].\n\n\t\t\"Now instantiate the best handler we found\"\n\t\tbest isNil ifFalse: [\n\t\t    context\n\t\t\tat: context numArgs + 1\n\t\t\tput: (activeHandlers setBit: best).\n\n\t\t    aSignal\n\t\t\tonDoBlock: context receiver\n\t\t\thandlerBlock: (context at: best + 1)\n\t\t\tonDoContext: context\n\t\t\tnested: nested\n\t\t\tpreviousState: activeHandlers.\n\n\t\t    ^self\n\t\t]\n\t    ].\n\n\texc == ExAll\n    ]   whileFalse: [\n\texc := exc parent\n    ].\n    aSignal\n\tonDoBlock: nil\n\thandlerBlock: self actualDefaultHandler\n\tonDoContext: nil\n\tnested: false\n\tpreviousState: nil",
          "literals": [],
          "methodName": "instantiateNextHandler:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "passFor:": {
          "src": "passFor: aSignal\n    \"Private - Raise the exception described by the receiver, passing a\n     Signal modeled after aSignal, and without returning control to the\n     caller\"\n\n    \"This is not refactored to avoid too long backtraces\"\n    | signal |\n    signal := signalClass new\n\tinitException: self;\n\tcopyFrom: aSignal.\n\n    self instantiateNextHandler: signal.\n    ^signal activateHandler: false",
          "literals": [],
          "methodName": "passFor:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "defaultAction": {
          "src": "defaultAction\n    \"Execute the default handler for the raised exception\"\n    self exception actualDefaultHandler value: self",
          "literals": [],
          "methodName": "defaultAction",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "allExceptionsDo:": {
          "src": "allExceptionsDo: aBlock\n    \"Private - Evaluate aBlock for every exception in the receiver. Answer the\n     receiver\"\n\n    collection do: aBlock",
          "literals": [],
          "methodName": "allExceptionsDo:",
          "className": "ExceptionSet",
          "category": "built ins",
          "byteCodes": []
        },
        "isResumable:": {
          "src": "isResumable: aBoolean\n    \"Set the resumable flag of the receiver to aBoolean\"\n    resumable := aBoolean",
          "literals": [],
          "methodName": "isResumable:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "actualDefaultHandler": {
          "src": "actualDefaultHandler\n    \"Private - Answer the default handler for the receiver. It differs from\n     #defaultHandler because if the default handler of the parent has to be\n     used #defaultHandler answers nil, while #actualDefaultHandler calls\n     #actualDefaultHandler for the parent and answers its result\"\n\n    ^defaultHandler isNil\n\tifTrue: [self parent actualDefaultHandler]\n\tifFalse: [defaultHandler]",
          "literals": [],
          "methodName": "actualDefaultHandler",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "on:do:on:do:on:do:": {
          "src": "on: e1 do: b1 on: e2 do: b2 on: e3 do: b3\n    \"Evaluate the receiver; when e1, e2 or e3 are signaled, evaluate\n     respectively b1, b2 or b3, passing a Signal describing the exception.\n     Answer either the result of evaluating the receiver or the parameter of a\n     Signal>>#return:\"\n\n    | active |\n    active := 0.\n    ^self value",
          "literals": [],
          "methodName": "on:do:on:do:on:do:",
          "className": "BlockClosure",
          "category": "built ins",
          "byteCodes": []
        },
        "depth:": {
          "src": "depth: anInteger\n    \"Private - Set the depth of the receiver in the exception hierarchy\"\n    depth := anInteger",
          "literals": [],
          "methodName": "depth:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "argumentCount": {
          "src": "argumentCount\n    \"Answer how many arguments the receiver has\"\n    ^arguments size",
          "literals": [],
          "methodName": "argumentCount",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "description:": {
          "src": "description: aString\n    \"Set the description of the receiver to aString\"\n    description := aString",
          "literals": [],
          "methodName": "description:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "signalWith:": {
          "src": "signalWith: arg\n    \"Raise the exception described by the receiver, passing the parameter arg\"\n\n    \"This is not refactored to avoid too long backtraces\"\n    | signal |\n    signal := signalClass new\n\tinitArguments: {arg};\n\tinitException: self.\n\n    self instantiateNextHandler: signal.\n    ^signal activateHandler: self isResumable",
          "literals": [],
          "methodName": "signalWith:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "initException:": {
          "src": "initException: exc\n    \"Private - set the exception that was raised to exc\"\n\n    exception := exc.\n    messageText := exc description.",
          "literals": [],
          "methodName": "initException:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "isResumable": {
          "src": "isResumable\n    \"Answer whether the exception that instantiated the receiver is resumable.\"\n    ^self exception isResumable",
          "literals": [],
          "methodName": "isResumable",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "resume:": {
          "src": "resume: anObject\n    \"If the exception is resumable, resume the execution of the block that\n     raised the exception; the method that was used to signal the exception\n     will answer anObject.\n     Use this method IF AND ONLY IF you know who caused the exception and if\n     it is possible to resume it in that particular case\"\n\n    self isResumable ifFalse: [\n\tself primError: 'Exception not resumable - #resume: failed'\n    ].\n\n    self resetHandler.\n    resumeBlock value: anObject",
          "literals": [],
          "methodName": "resume:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "goodness:": {
          "src": "goodness: exception\n    \"Answer how good the receiver is at handling the given exception.  A\n     negative value indicates that the receiver is not able to handle\n     the exception.\"\n    ^collection\n\tinject: -1\n\tinto: [ :old :each | old max: (each goodness: exception) ]",
          "literals": [],
          "methodName": "goodness:",
          "className": "ExceptionSet",
          "category": "built ins",
          "byteCodes": []
        },
        "description": {
          "src": "description\n    \"Answer the description of the raised exception\"\n    ^self exception description",
          "literals": [],
          "methodName": "description",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "unwindTo:": {
          "src": "unwindTo: aContext\n    thisContext\n\tscanBacktraceFor: #(#on:do: #on:do:on:do:\n\t\t#on:do:on:do:on:do: #on:do:on:do:on:do:on:do: \n\t\t#on:do:on:do:on:do:on:do:on:do: #activateHandler:)\n\tdo: [ :context |\n\t    context receiver class == BlockClosure\n\t\tifTrue: [\n\t\t    context == aContext ifTrue: [ ^self ]\n\t\t]\n\t\tifFalse: [\n\t\t    context receiver resetHandler\n\t\t].\n\t]",
          "literals": [],
          "methodName": "unwindTo:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "primError:": {
          "src": "primError: message\n\n    \"This might start the debugger... Note that we use #basicPrint\n     'cause #printOn: might invoke an error.\"\n\n    Transcript initialize.    \n    stdout flush.\n    RegressionTesting ifFalse: [ self basicPrint ].\n    stdout\n\tnextPutAll: ' error: ';\n\tdisplay: message;\n\tnl.\n\n    RegressionTesting ifFalse: [ ContextPart backtraceOn: stdout ].\n    stdout flush.\n    ContextPart unwind",
          "literals": [],
          "methodName": "primError:",
          "className": "Object",
          "category": "built ins",
          "byteCodes": []
        },
        "handles:": {
          "src": "handles: exception\n    \"Answer whether the receiver handles `exception'.\"\n\n    ^collection\n\tanySatisfy: [ :someItem | someItem handles: exception ]",
          "literals": [],
          "methodName": "handles:",
          "className": "ExceptionSet",
          "category": "built ins",
          "byteCodes": []
        },
        "messageText:": {
          "src": "messageText: aString\n    \"Set an exception's message text.\"\n    messageText := aString",
          "literals": [],
          "methodName": "messageText:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "newChild": {
          "src": "newChild\n    \"Answer a child exception of the receiver. Its properties are set to those\n     of the receiver\"\n\n    ^self species basicNew\n\tdescription: self description copy;\n\tisResumable: self isResumable;\n\tdepth: self depth + 1;\n\tdefaultHandler: nil;\n\tparent: self;\n\tsignalClass: Signal;\n\tyourself",
          "literals": [],
          "methodName": "newChild",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "tag:": {
          "src": "tag: anObject\n    \"Set an exception's tag value.  If nil, the tag value will\n     be the same as the message text.\"\n    tag := anObject",
          "literals": [],
          "methodName": "tag:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "noTag": {
          "src": "noTag\n    NoTag isNil ifTrue: [ NoTag := Object new ].\n    ^NoTag",
          "literals": [],
          "methodName": "noTag",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "copy": {
          "src": "copy\n    \"Answer a copy of the receiver\"\n    ^super copy\n\tdescription: self description copy;\n\tyourself",
          "literals": [],
          "methodName": "copy",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "collection:": {
          "src": "collection: aSet\n    \"Private - Set the collection of exception included in the receiver to\n     aSet\"\n    collection := aSet.\n    ^self",
          "literals": [],
          "methodName": "collection:",
          "className": "ExceptionSet",
          "category": "built ins",
          "byteCodes": []
        },
        "on:do:on:do:on:do:on:do:on:do:": {
          "src": "on: e1 do: b1 on: e2 do: b2 on: e3 do: b3 on: e4 do: b4 on: e5 do: b5\n    \"Evaluate the receiver; when e1, e2, e3, e4 or e5 are signaled, evaluate\n     respectively b1, b2, b3, b4 or b5, passing a Signal describing the exception.\n     Answer either the result of evaluating the receiver or the parameter of a\n     Signal>>#return:\"\n\n    | active |\n    active := 0.\n    ^self value",
          "literals": [],
          "methodName": "on:do:on:do:on:do:on:do:on:do:",
          "className": "BlockClosure",
          "category": "built ins",
          "byteCodes": []
        },
        "retry": {
          "src": "retry\n    \"Re-execute the receiver of the #on:do: message. All handlers are\n     reinstated: watch out, this can easily cause an infinite loop.\"\n\n    onDoBlock isNil ifTrue: [\n\tself primError: 'No exception handler effective - #retry failed'\n    ].\n    CoreException resetAllHandlers.\n    self return: onDoBlock value",
          "literals": [],
          "methodName": "retry",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "onDoBlock:handlerBlock:onDoContext:nested:previousState:": {
          "src": "onDoBlock: wdBlock handlerBlock: hBlock onDoContext: ctx nested: aBoolean previousState: anInteger\n    \"Initialize the receiver's instance variables.\"\n    nested := aBoolean.\n    previousState := anInteger.\n    context := ctx.\n    onDoBlock := wdBlock.\n    handlerBlock := hBlock.\n    ^self",
          "literals": [],
          "methodName": "onDoBlock:handlerBlock:onDoContext:nested:previousState:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "signalWith:with:": {
          "src": "signalWith: arg with: arg2\n    \"Raise the exception described by the receiver, passing the parameters arg\n     and arg2\"\n\n    \"This is not refactored to avoid too long backtraces\"\n    | signal |\n    signal := signalClass new\n\tinitArguments: {arg. arg2};\n\tinitException: self.\n\n    self instantiateNextHandler: signal.\n    ^signal activateHandler: self isResumable",
          "literals": [],
          "methodName": "signalWith:with:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "resume": {
          "src": "resume\n    \"If the exception is resumable, resume the execution of the block that\n     raised the exception; the method that was used to signal the exception\n     will answer the receiver.\n     Use this method IF AND ONLY IF you know who caused the exception and if\n     it is possible to resume it in that particular case\"\n\n    self isResumable ifFalse: [\n\tself primError: 'Exception not resumable - #resume failed'\n    ].\n\n    self resetHandler.\n    resumeBlock value: self",
          "literals": [],
          "methodName": "resume",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "on:do:on:do:": {
          "src": "on: e1 do: b1 on: e2 do: b2\n    \"Evaluate the receiver; when e1 or e2 are signaled, evaluate respectively\n     b1 or b2, passing a Signal describing the exception. Answer either the\n     result of evaluating the receiver or the argument of a Signal>>#return:\"\n\n    | active |\n    active := 0.\n    ^self value",
          "literals": [],
          "methodName": "on:do:on:do:",
          "className": "BlockClosure",
          "category": "built ins",
          "byteCodes": []
        },
        "on:do:on:do:on:do:on:do:": {
          "src": "on: e1 do: b1 on: e2 do: b2 on: e3 do: b3 on: e4 do: b4\n    \"Evaluate the receiver; when e1, e2, e3 or e4 are signaled, evaluate\n     respectively b1, b2, b3 or b4, passing a Signal describing the exception.\n     Answer either the result of evaluating the receiver or the parameter of a\n     Signal>>#return:\"\n\n    | active |\n    active := 0.\n    ^self value",
          "literals": [],
          "methodName": "on:do:on:do:on:do:on:do:",
          "className": "BlockClosure",
          "category": "built ins",
          "byteCodes": []
        },
        "activateHandler:": {
          "src": "activateHandler: resumeBoolean\n    \"Run the handler, passing to it aSignal, an instance of Signal.  aBoolean\n     indicates the action (either resuming the receiver of #on:do:... or\n     exiting it) to be taken upon leaving from the handler block.\"\n\n    | result |\n    resumeBlock := [ :object |\n\tself resetHandler.\n\t^object ].\n\n    result := handlerBlock value: self.\n    resumeBoolean\n\tifTrue: [\n\t    self resetHandler.\n\t    ^result\n\t].\n\n    \"CoreException unwindTo: context.\"\n    context parentContext continue: result",
          "literals": [],
          "methodName": "activateHandler:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "parent:": {
          "src": "parent: anException\n    \"Private - Set the parent of the receiver to anException\"\n    parent := anException",
          "literals": [],
          "methodName": "parent:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "resetAllHandlers": {
          "src": "resetAllHandlers\n    \"Private, class - Reset the handlers for all the exceptions; that is, the\n     next handlers used will be the first to be declared\"\n\n    thisContext\n\tscanBacktraceFor: #(#on:do: #on:do:on:do:\n\t\t#on:do:on:do:on:do: #on:do:on:do:on:do:on:do: \n\t\t#on:do:on:do:on:do:on:do:on:do:)\n\tdo: [ :context |\n\t    context receiver class == BlockClosure ifTrue: [\n\t\tcontext at: context numArgs + 1 put: 0\n\t    ]\n\t]",
          "literals": [],
          "methodName": "resetAllHandlers",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "isNested": {
          "src": "isNested\n    \"Answer whether the current exception handler is within the scope of\n     another handler for the same exception.\"\n    ^nested",
          "literals": [],
          "methodName": "isNested",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "resignalAs:": {
          "src": "resignalAs: replacementException\n    \"Reinstate all handlers and execute the handler for `replacementException';\n     control does not return to the currently active exception handler. The\n     new Signal object that is created has the same arguments as the receiver\n     (this might or not be correct -- if it isn't you can use an idiom such\n     as `sig retryUsing: [ replacementException signal ])\"\n\n    CoreException resetAllHandlers.\n    replacementException passFor: self",
          "literals": [],
          "methodName": "resignalAs:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "on:do:": {
          "src": "on: anException do: aBlock\n    \"Evaluate the receiver; when anException is signaled, evaluate aBlock\n     passing a Signal describing the exception. Answer either the result of\n     evaluating the receiver or the parameter of a Signal>>#return:\"\n\n    | active |\n    active := 0.\n    ^self value",
          "literals": [],
          "methodName": "on:do:",
          "className": "BlockClosure",
          "category": "built ins",
          "byteCodes": []
        },
        "depth": {
          "src": "depth\n    \"Private - Answer the depth of the receiver in the exception hierarchy\"\n    ^depth",
          "literals": [],
          "methodName": "depth",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "return:": {
          "src": "return: anObject\n    \"Exit the #on:do: snippet, answering anObject to its caller\"\n\n    context isNil ifTrue: [\n\tself primError: 'No exception handler effective - #return failed'\n    ].\n    context parentContext continue: anObject.",
          "literals": [],
          "methodName": "return:",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "defaultHandler": {
          "src": "defaultHandler\n    \"Answer the default handler for the receiver\"\n\n    ^defaultHandler",
          "literals": [],
          "methodName": "defaultHandler",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "signalFor:": {
          "src": "signalFor: aSignal\n    \"Private - Raise the exception described by the receiver, passing a\n     Signal modeled after aSignal.\"\n\n    \"This is not refactored to avoid too long backtraces\"\n    | signal |\n    signal := signalClass new\n\tinitException: self;\n\tcopyFrom: aSignal.\n\n    self instantiateNextHandler: signal.\n    ^signal activateHandler: self isResumable",
          "literals": [],
          "methodName": "signalFor:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "arguments": {
          "src": "arguments\n    \"Answer the arguments of the receiver\"\n    ^arguments",
          "literals": [],
          "methodName": "arguments",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "signalClass:": {
          "src": "signalClass: aClass\n    \"Set which subclass of Signal is to be passed to handler blocks\n     that handle the receiver\"\n    signalClass := aClass",
          "literals": [],
          "methodName": "signalClass:",
          "className": "CoreException",
          "category": "built ins",
          "byteCodes": []
        },
        "return": {
          "src": "return\n    \"Exit the #on:do: snippet, answering anObject to its caller\"\n\n    context isNil ifTrue: [\n\tself primError: 'No exception handler effective - #return failed'\n    ].\n    context parentContext continue: nil.",
          "literals": [],
          "methodName": "return",
          "className": "Signal",
          "category": "built ins",
          "byteCodes": []
        },
        "ifError:": {
          "src": "ifError: aBlock\n    \"Evaluate the receiver; when #error: is called, pass to aBlock the receiver\n     and the parameter, and answer the result of evaluating aBlock.  If another\n     exception is raised, it is passed to an outer handler; if no exception is\n     raised, the result of evaluating the receiver is returned.\"\n\n    ^self on: ExError do: [ :sig |\n\tsig return: (aBlock valueWithArguments: sig arguments)\n    ]",
          "literals": [],
          "methodName": "ifError:",
          "className": "BlockClosure",
          "category": "built ins",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "Exception",
          "instance_methods": {
            "signalOn:useInstead:": {
              "src": "signalOn: selector useInstead: aSymbol\n    \"Raise an exception, signaling which selector was sent and suggesting\n     a valid alternative.\"\n    ^self new\n\tselector: selector;\n\tsuggestedSelector: aSymbol;\n\tsignal",
              "literals": [],
              "methodName": "signalOn:useInstead:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "signalOn:withIndex:": {
              "src": "signalOn: aCollection withIndex: value\n    \"The given index was out of range in aCollection.\"\n    ^self new\n\tcollection: aCollection;\n\tvalue: value;\n\tsignal",
              "literals": [],
              "methodName": "signalOn:withIndex:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "selector:": {
              "src": "selector: aSymbol\n    \"Set which selector was sent.\"\n    selector := aSymbol",
              "literals": [],
              "methodName": "selector:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "doesNotUnderstand:": {
              "src": "doesNotUnderstand: aMessage\n    \"Called by the system when a selector was not found. message is a\n     Message containing information on the receiver\"\n\n    ^MessageNotUnderstood new\n\tmessage: aMessage receiver: self;\n\tsignal",
              "literals": [],
              "methodName": "doesNotUnderstand:",
              "className": "Object",
              "category": "accessing",
              "byteCodes": []
            },
            "copyFrom:": {
              "src": "copyFrom: aSignal\n    \"Private - Initialize from another instance of Signal\"\n\n    (aSignal isKindOf: Exception) ifTrue: [ self initialize: aSignal creator ].\n    super copyFrom: aSignal.",
              "literals": [],
              "methodName": "copyFrom:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "arithmeticError:": {
              "src": "arithmeticError: msg\n    \"Raise an ArithmeticError exception having msg as its message text.\"\n    ^ArithmeticError new signal: msg",
              "literals": [],
              "methodName": "arithmeticError:",
              "className": "Number",
              "category": "accessing",
              "byteCodes": []
            },
            "signalOn:": {
              "src": "signalOn: value\n    \"Answer an exception reporting the parameter as invalid.\"\n    ^self new\n\tvalue: value;\n\tsignal",
              "literals": [],
              "methodName": "signalOn:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "value:": {
              "src": "value: anObject\n    \"Set the object that was found to be invalid.\"\n    value := anObject",
              "literals": [],
              "methodName": "value:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "suggestedSelector": {
              "src": "suggestedSelector\n    \"Answer a valid alternative to the selector that was used.\"\n    ^suggestedSelector",
              "literals": [],
              "methodName": "suggestedSelector",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "high": {
              "src": "high\n    \"Answer the highest value that was permitted.\"\n    ^high",
              "literals": [],
              "methodName": "high",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "signalOn:what:": {
              "src": "signalOn: value what: aString\n    \"Raise an exception; aString specifies what was not found (a key,\n     an object, a class, and so on).\"\n    ^self new\n\tvalue: value;\n\tsignal: aString, ' not found'",
              "literals": [],
              "methodName": "signalOn:what:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "signalOn:mustBe:": {
              "src": "signalOn: anObject mustBe: aClassOrArray\n    \"Raise an exception.  The given object should have been an instance\n     of one of the classes indicated by aClassOrArray (which should be\n     a single class or an array of classes).  Whether instances of\n     subclasses are allowed should be clear from the context, though\n     in general (i.e. with the exception of a few system messages)\n     they should be.\"\n\n    (aClassOrArray isKindOf: Collection) ifFalse: [\n\t^self signalOn: anObject mustBe: { aClassOrArray } ].\n\n    ^self new\n\tvalidClasses: aClassOrArray;\n\tvalue: anObject;\n\tsignal",
              "literals": [],
              "methodName": "signalOn:mustBe:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "signal": {
              "src": "signal\n    \"Raise the exceptional event represented by the receiver\"\n    self exception instantiateNextHandler: self.\n    ^self activateHandler: self isResumable",
              "literals": [],
              "methodName": "signal",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "new": {
              "src": "new\n    \"Create a new ZeroDivide object; the dividend is conventionally\n     set to zero.\"\n    ^super new dividend: 0",
              "literals": [],
              "methodName": "new",
              "className": "ZeroDivide",
              "category": "accessing",
              "byteCodes": []
            },
            "messageText": {
              "src": "messageText\n    \"Answer an exception's message text.\"\n    ^'%1, use %2 instead'\n\tbindWith: self basicMessageText\n\twith: self suggestedSelector storeString",
              "literals": [],
              "methodName": "messageText",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "receiver": {
              "src": "receiver\n    \"Answer the object to whom the message send was directed\"\n    ^receiver",
              "literals": [],
              "methodName": "receiver",
              "className": "MessageNotUnderstood",
              "category": "accessing",
              "byteCodes": []
            },
            "initialize:": {
              "src": "initialize: anObject\n    \"Initialize the receiver's instance variables.\"\n    \n    creator := anObject.\n    self\n\tinitArguments: #();\n\tinitException: self class coreException;\n\tmessageText: self description",
              "literals": [],
              "methodName": "initialize:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "collection": {
              "src": "collection\n    \"Answer the collection that triggered the error\"\n    ^collection",
              "literals": [],
              "methodName": "collection",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            ",": {
              "src": ", aTrappableEvent\n    \"Answer an ExceptionCollection containing all the exceptions in the\n     receiver and all the exceptions in aTrappableEvent\"\n\n    ^ExceptionSet new\n\tadd: self coreException;\n\tadd: aTrappableEvent;\n\tyourself",
              "literals": [],
              "methodName": ",",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "validClasses": {
              "src": "validClasses\n    \"Answer the list of classes whose instances would have been valid.\"\n    ^validClasses",
              "literals": [],
              "methodName": "validClasses",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "high:": {
              "src": "high: aMagnitude\n    \"Set the highest value that was permitted.\"\n    high := aMagnitude",
              "literals": [],
              "methodName": "high:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "defaultAction": {
              "src": "defaultAction\n    \"Do the default action for notifications, which is to resume execution\n     of the context which signaled the exception.\"\n    self resume: nil",
              "literals": [],
              "methodName": "defaultAction",
              "className": "Notification",
              "category": "accessing",
              "byteCodes": []
            },
            "coreException": {
              "src": "coreException\n    \"Private - Answer the coreException which represents instances of\n     the receiver\"\n\n    coreException isNil ifFalse: [ ^coreException ].\n\n    ^coreException := self superclass coreException newChild\n\tdefaultHandler: [ :sig | sig defaultAction ];\n\tsignalClass: self;\n\tyourself",
              "literals": [],
              "methodName": "coreException",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "allExceptionsDo:": {
              "src": "allExceptionsDo: aBlock\n    \"Private - Pass the coreException to aBlock\"\n    \n    aBlock value: self coreException",
              "literals": [],
              "methodName": "allExceptionsDo:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "dividend:": {
              "src": "dividend: aNumber\n    dividend := aNumber",
              "literals": [],
              "methodName": "dividend:",
              "className": "ZeroDivide",
              "category": "accessing",
              "byteCodes": []
            },
            "message:receiver:": {
              "src": "message: aMessage receiver: anObject\n    message := aMessage.\n    receiver := anObject.\n\n    self messageText: ('did not understand ', message selector printString)",
              "literals": [],
              "methodName": "message:receiver:",
              "className": "MessageNotUnderstood",
              "category": "accessing",
              "byteCodes": []
            },
            "=": {
              "src": "= anObject\n    \"Answer whether the receiver is equal to anObject.  This is true if\n     either the receiver or its coreException are the same object as anObject.\"\n\n    \"This definition is needed to make #handles: work for ExceptionCollections.\n     `(Error, Warning) handles: Error new' must work even if the\n     ExceptionCollections contains the coreExceptions associated to Error\n     and Warning (see Exception class>>#,).\"\n    ^self == anObject or: [ self exception == anObject ]",
              "literals": [],
              "methodName": "=",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "hash": {
              "src": "hash\n    \"Answer an hash value for the receiver.\"\n    ^self exception hash",
              "literals": [],
              "methodName": "hash",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "isResumable": {
              "src": "isResumable\n    \"Answer true.  #halt exceptions are by default resumable.\"\n    ^true",
              "literals": [],
              "methodName": "isResumable",
              "className": "Halt",
              "category": "accessing",
              "byteCodes": []
            },
            "goodness:": {
              "src": "goodness: anException\n    \"Answer how good the receiver is at handling the given exception.  A\n     negative value indicates that the receiver is not able to handle\n     the exception.\"\n\n    ^self coreException goodness: anException",
              "literals": [],
              "methodName": "goodness:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "description": {
              "src": "description\n    \"Answer a textual description of the exception.\"\n    ^'method is responsibility of a subclass'",
              "literals": [],
              "methodName": "description",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "suggestedSelector:": {
              "src": "suggestedSelector: aSymbol\n    \"Set a valid alternative to the selector that was used.\"\n    suggestedSelector := aSymbol",
              "literals": [],
              "methodName": "suggestedSelector:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "handles:": {
              "src": "handles: anException\n    \"Answer whether the receiver handles `anException'.\"\n\n    ^(anException isKindOf: Exception)\n\tifTrue: [ anException isKindOf: self ]\n\tifFalse: [ self coreException handles: anException ]",
              "literals": [],
              "methodName": "handles:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "signalOn:mustBeBetween:and:": {
              "src": "signalOn: value mustBeBetween: low and: high\n    \"Raise the exception.  The given value was not between low and high.\"\n    | errorString |\n    errorString := RegressionTesting\n\tifTrue: [ 'argument out of range' ]\n\tifFalse: [ 'argument must be between ', low printString,\n\t\t' and ', high printString ].\n\n    ^self new\n\tvalue: value;\n\tlow: low;\n\thigh: high;\n\tsignal: errorString",
              "literals": [],
              "methodName": "signalOn:mustBeBetween:and:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "low:": {
              "src": "low: aMagnitude\n    \"Set the lowest value that was permitted.\"\n    low := aMagnitude",
              "literals": [],
              "methodName": "low:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "stream": {
              "src": "stream\n    \"Answer the stream whose end was reached.\"\n    ^stream",
              "literals": [],
              "methodName": "stream",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "low": {
              "src": "low\n    \"Answer the lowest value that was permitted.\"\n    ^low",
              "literals": [],
              "methodName": "low",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "validClassesString": {
              "src": "validClassesString\n    \"Answer the list of classes whose instances would have been valid,\n    formatted as a string.\"\n    ^String streamContents: [ :str |\n\tvalidClasses keysAndValuesDo: [ :idx :class |\n\t    | name |\n\t    idx > 1 ifTrue: [\n\t\tidx = validClasses size\n\t\t    ifFalse: [ str nextPutAll: ', ' ]\n\t\t    ifTrue: [ str nextPutAll: ' or ' ]\n\t    ].\n\t    name := class nameIn: Namespace current.\n\t    name first isVowel\n\t\tifTrue: [ str nextPutAll: 'an ' ]\n\t\tifFalse: [ str nextPutAll: 'a ' ].\n\n\t    str nextPutAll: name\n\t]\n    ]",
              "literals": [],
              "methodName": "validClassesString",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "dividend": {
              "src": "dividend\n    \"Answer the number that was being divided by zero\"\n    ^dividend",
              "literals": [],
              "methodName": "dividend",
              "className": "ZeroDivide",
              "category": "accessing",
              "byteCodes": []
            },
            "selector": {
              "src": "selector\n    \"Answer which selector was sent.\"\n    ^selector",
              "literals": [],
              "methodName": "selector",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "validClasses:": {
              "src": "validClasses: aCollection\n    \"Set the list of classes whose instances would have been valid.\"\n    validClasses := aCollection",
              "literals": [],
              "methodName": "validClasses:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "collection:": {
              "src": "collection: anObject\n    \"Set the collection that triggered the error\"\n    collection := anObject",
              "literals": [],
              "methodName": "collection:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "value": {
              "src": "value\n    \"Answer the object that was found to be invalid.\"\n    ^value",
              "literals": [],
              "methodName": "value",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "zeroDivide": {
              "src": "zeroDivide\n    \"Raise a division-by-zero (ZeroDivide) exception whose dividend\n     is the receiver.\"\n    ^(ZeroDivide dividend: self) signal",
              "literals": [],
              "methodName": "zeroDivide",
              "className": "Number",
              "category": "accessing",
              "byteCodes": []
            },
            "whenSignalledIn:do:exitBlock:": {
              "src": "whenSignalledIn: onDoBlock do: handlerBlock exitBlock: exitBlock\n    \"Private - Create an ExceptionHandler from the arguments and register it\"\n\n    self coreException\n\twhenSignalledIn: onDoBlock\n\tdo: handlerBlock\n\texitBlock: exitBlock",
              "literals": [],
              "methodName": "whenSignalledIn:do:exitBlock:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "creator": {
              "src": "creator\n    ^creator",
              "literals": [],
              "methodName": "creator",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "error:": {
              "src": "error: message\n    \"Display a walkback for the receiver, with the given error message.\n     Signal an `Error' exception (you can trap it the old way too, with\n     `ExError'\"\n    ^Error new\n\tsignal: message",
              "literals": [],
              "methodName": "error:",
              "className": "Object",
              "category": "accessing",
              "byteCodes": []
            },
            "signal:": {
              "src": "signal: messageText\n    \"Raise the exceptional event represented by the receiver, setting\n     its message text to messageText.\"\n    ^self messageText: messageText; signal",
              "literals": [],
              "methodName": "signal:",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "message": {
              "src": "message\n    \"Answer the message that wasn't understood\"\n    ^message",
              "literals": [],
              "methodName": "message",
              "className": "MessageNotUnderstood",
              "category": "accessing",
              "byteCodes": []
            },
            "stream:": {
              "src": "stream: anObject\n    \"Set the stream whose end was reached.\"\n    stream := anObject",
              "literals": [],
              "methodName": "stream:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "signalOn:reason:": {
              "src": "signalOn: value reason: reason\n    \"Answer an exception reporting `value' as invalid, for the given\n     reason.\"\n    ^self new\n\tvalue: value;\n\tsignal: reason",
              "literals": [],
              "methodName": "signalOn:reason:",
              "className": "SystemExceptions",
              "category": "accessing",
              "byteCodes": []
            },
            "initialize": {
              "src": "initialize\n    \"Initialize the `links' between the core exception handling system\n     and the ANSI exception handling system.\"\n\n    \"Usually, a coreException has no defined `resumable' state, because\n     Exception overrides Signal>>#isResumable and gives an answer without\n     asking the core exception.  For backwards compatibility, however, we\n     must give a state to these (in case someone uses `on: ExAll do: ...').\"\n\n    (ExAll := CoreException basicNew)\n\tdefaultHandler: [ :sig | self primError: sig messageText ];\n\tdepth: 0;\n\tsignalClass: Signal;\n\tisResumable: true;\n\tyourself.\n\n    (coreException := ExAll newChild)\n\tdefaultHandler: [ :sig | sig defaultAction ];\n\tsignalClass: self;\n\tisResumable: true;\n\tyourself.\n\n    (ExError := Error coreException)\n\tisResumable: false.\n\n    (ExDoesNotUnderstand := MessageNotUnderstood coreException)\n\tisResumable: true.\n\n    (ExHalt := Halt coreException)\n\tisResumable: true.\n\n    (ExUserBreak := SystemExceptions UserInterrupt coreException)\n\tisResumable: false.",
              "literals": [],
              "methodName": "initialize",
              "className": "Exception",
              "category": "accessing",
              "byteCodes": []
            },
            "halt:": {
              "src": "halt: message\n    \"Display a walkback for the receiver, with the given error message.\n     Signal an `Halt' exception (you can trap it the old way too, with\n     `ExHalt')\"\n    ^Halt new\n\tsignal: message",
              "literals": [],
              "methodName": "halt:",
              "className": "Object",
              "category": "accessing",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        }
      ]
    },
    {
      "className": "Stream",
      "instance_methods": {
        "next": {
          "src": "next\n    \"Return the next object in the receiver\"\n    self subclassResponsibility",
          "literals": [],
          "methodName": "next",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "<<": {
          "src": "<< anObject\n    \"This method is a short-cut for #display:; it prints anObject on the\n     receiver by sending displayOn: to anObject. This method is provided\n     so that you can use cascading and obtain better-looking code\"\n\n    anObject displayOn: self",
          "literals": [],
          "methodName": "<<",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nextAvailable:": {
          "src": "nextAvailable: anInteger\n    \"Return up to anInteger objects in the receiver, stopping if\n     the end of the stream is reached\"\n    | stream |\n    stream := WriteStream on: (self species new: anInteger).\n    anInteger timesRepeat: [\n\tself atEnd ifTrue: [ ^stream contents ].\n\tstream nextPut: self next ].\n    ^stream contents",
          "literals": [],
          "methodName": "nextAvailable:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nextPutAll:": {
          "src": "nextPutAll: aCollection\n    \"Write all the objects in aCollection to the receiver\"\n    aCollection do: [ :element | self nextPut: element ].\n    ^aCollection",
          "literals": [],
          "methodName": "nextPutAll:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "splitAt:": {
          "src": "splitAt: anObject\n    \"Answer an OrderedCollection of parts of the receiver. A new (possibly\n     empty) part starts at the start of the receiver, or after every\n     occurrence of an object which is equal to anObject (as compared by\n     #=).\"\n    | result |\n    result := OrderedCollection new: 10.\n    [ self atEnd ] whileFalse: [\n\tresult addLast: (self upTo: anObject)\n    ].\n    ^result",
          "literals": [],
          "methodName": "splitAt:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "display:": {
          "src": "display: anObject\n    \"Print anObject on the receiver by sending displayOn: to anObject. This\n     method is provided so that you can use cascading and obtain\n     better-looking code\"\n    anObject displayOn: self",
          "literals": [],
          "methodName": "display:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "skipToAll:": {
          "src": "skipToAll: aCollection\n    \"If there is a sequence of objects remaining in the stream that is\n     equal to the sequence in aCollection, set the stream position just\n     past that sequence and answer true. Else, set the stream position\n     to its end and answer false.\"\n    | buffer next nextSource pos |\n\n    buffer := ReadWriteStream on: (self species new: 8).\n    buffer truncate.\n    [   [   nextSource := self nextWithBuffer: buffer.\n\t    nextSource isNil ifTrue: [ ^false ].\n\t    next := nextSource next.\n\t    next = aCollection first\n\t]   whileFalse.\n\n\t\"Push back the first character of the (possible) match\"\n\tnextSource == self ifTrue: [ buffer nextPut: next ].\n\tpos := buffer position.\n\tbuffer skip: -1.\n\n\taCollection allSatisfy: [ :each |\n\t    nextSource := self nextWithBuffer: buffer.\n\t    nextSource isNil ifTrue: [ ^false ].\n\t    next := nextSource next.\n\t    nextSource == self ifTrue: [ buffer nextPut: next ].\n\t    each = next\n\t].\n    ]   whileFalse: [ buffer position: pos ].\n    ^true",
          "literals": [],
          "methodName": "skipToAll:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "do:": {
          "src": "do: aBlock\n    \"Evaluate aBlock once for every object in the receiver\"\n    [self atEnd] whileFalse:\n    \t[aBlock value: self next ]",
          "literals": [],
          "methodName": "do:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "crTab": {
          "src": "crTab\n    \"Store a cr and a tab on the receiver\"\n    self cr.\n    self tab",
          "literals": [],
          "methodName": "crTab",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "space": {
          "src": "space\n    \"Store a space on the receiver\"\n    self nextPut: Character space",
          "literals": [],
          "methodName": "space",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "tab": {
          "src": "tab\n    \"Store a tab on the receiver\"\n    self nextPut: Character tab",
          "literals": [],
          "methodName": "tab",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "flush": {
          "src": "flush\n    \"Do nothing. This is provided for consistency with file streams\"",
          "literals": [],
          "methodName": "flush",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "next:": {
          "src": "next: anInteger\n    \"Return the next anInteger objects in the receiver\"\n    | data |\n    data := self species new: anInteger.\n    1 to: anInteger do: [ :i | data at: i put: self next ].\n    ^data",
          "literals": [],
          "methodName": "next:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "close": {
          "src": "close\n    \"Do nothing. This is provided for consistency with file streams\"",
          "literals": [],
          "methodName": "close",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "skipTo:": {
          "src": "skipTo: anObject\n    \"Move the current position to after the next occurrence of anObject\n    and return true if anObject was found.  If anObject doesn't exist, the \n    pointer is atEnd, and false is returned.\"\n\n    [ self atEnd ] whileFalse: [\n    \tself next = anObject ifTrue: [ ^true ]\n    ].\n    ^false",
          "literals": [],
          "methodName": "skipTo:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nextMatchFor:": {
          "src": "nextMatchFor: anObject\n    \"Answer whether the next object is equal to anObject. Even if it does\n     not, anObject is lost\"\n    ^anObject = self next",
          "literals": [],
          "methodName": "nextMatchFor:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "upTo:": {
          "src": "upTo: anObject\n    \"Returns a collection of the same type that the stream accesses, up to \n    but not including the object anObject.  Returns the entire rest of the \n    stream's contents if anObject is not present. \"\n    | next ws |\n    ws := WriteStream on: (self species new: 8).\n    [ self atEnd or: [ (next := self next) = anObject ] ] whileFalse: [\n\tws nextPut: next\n    ].\n    ^ws contents",
          "literals": [],
          "methodName": "upTo:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "space:": {
          "src": "space: n\n    \"Store n spaces on the receiver\"\n    self next: n put: Character space",
          "literals": [],
          "methodName": "space:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "atEnd": {
          "src": "atEnd\n    \"Answer whether the stream has got to an end\"\n    self subclassResponsibility",
          "literals": [],
          "methodName": "atEnd",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nextLine": {
          "src": "nextLine\n    \"Returns a collection of the same type that the stream accesses, up to \n    but not including the object anObject.  Returns the entire rest of the \n    stream's contents if anObject is not present. \"\n    | next ws cr nl |\n    ws := WriteStream on: (self species new: 40).\n    cr := Character cr.\n    nl := Character nl.\n    [ self atEnd or: [ (next := self next) == cr | (next == nl) | next isNil ] ]\n\twhileFalse: [ ws nextPut: next ].\n\n    next == cr ifTrue: [ self peekFor: nl ].\n    ^ws contents",
          "literals": [],
          "methodName": "nextLine",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "store:": {
          "src": "store: anObject\n    \"Print Smalltalk code compiling to anObject on the receiver, by sending\n     storeOn: to anObject. This method is provided so that you can use\n     cascading and obtain better-looking code\"\n    anObject storeOn: self",
          "literals": [],
          "methodName": "store:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "fileOut:": {
          "src": "fileOut: aClass\n    \"File out aClass on the receiver. If aClass is not a metaclass, file out\n     class and instance methods; if aClass is a metaclass, file out only the\n     class methods\"\n\n    aClass fileOutOn: self",
          "literals": [],
          "methodName": "fileOut:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "upToEnd": {
          "src": "upToEnd\n    \"Answer every item in the collection on which the receiver is\n     streaming, from the next one to the last\"\n    | ws |\n    ws := WriteStream on: (self species new: 8).\n    [ self atEnd ] whileFalse: [ ws nextPut: self next ].\n    ^ws contents",
          "literals": [],
          "methodName": "upToEnd",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "cr": {
          "src": "cr\n    \"Store a cr on the receiver\"\n    self nextPut: Character cr",
          "literals": [],
          "methodName": "cr",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "next:put:": {
          "src": "next: anInteger put: anObject\n    \"Write anInteger copies of anObject to the receiver\"\n    anInteger timesRepeat: [ self nextPut: anObject ].\n    ^anObject",
          "literals": [],
          "methodName": "next:put:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "tab:": {
          "src": "tab: n\n    \"Store n tabs on the receiver\"\n    self next: n put: Character tab",
          "literals": [],
          "methodName": "tab:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "contents": {
          "src": "contents\n    \"Answer the whole contents of the receiver, from the next object to\n     the last\"\n    | stream |\n\n    stream := WriteStream on: (self species new: 10).\n    self do: [ :each | stream nextPut: each ].\n    ^stream contents",
          "literals": [],
          "methodName": "contents",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "species": {
          "src": "species\n    ^Array",
          "literals": [],
          "methodName": "species",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nlTab": {
          "src": "nlTab\n    \"Store a new line and a tab on the receiver\"\n    self nl.\n    self tab",
          "literals": [],
          "methodName": "nlTab",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nextWithBuffer:": {
          "src": "nextWithBuffer: buffer\n    \"Answer whether the next character must be read from the receiver\n     or from the read-ahead buffer contained in buffer (another Po-\n     sitionableStream). If both the receiver and the buffer contain\n     no data, nil is answered, else the correct stream is answered.\"\n    ^buffer atEnd\n\tifTrue: [\n\t    self atEnd ifTrue: [ nil ] ifFalse: [ self ]\n\t]\n\tifFalse: [ buffer ]",
          "literals": [],
          "methodName": "nextWithBuffer:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nextPut:": {
          "src": "nextPut: anObject\n    \"Write anObject to the receiver\"\n    self subclassResponsibility",
          "literals": [],
          "methodName": "nextPut:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "upToAll:": {
          "src": "upToAll: aCollection\n    \"If there is a sequence of objects remaining in the stream that is\n     equal to the sequence in aCollection, set the stream position just\n     past that sequence and answer the elements up to, but not including,\n     the sequence. Else, set the stream position to its end and answer\n     all the remaining elements.\"\n    | buffer next nextSource pos ws first |\n\n    buffer := ReadWriteStream on: (self species new: 8).\n    buffer truncate.\n    ws := WriteStream on: (self species new: 8).\n    first := aCollection at: 1.\n    [   [   nextSource := self nextWithBuffer: buffer.\n\t    nextSource isNil ifTrue: [ ^ws contents ].\n\t    ws nextPut: (next := nextSource next).\n\t    next = first\n\t]   whileFalse.\n\n\t\"Push back the first character of the (possible) match\"\n\tnextSource == self ifTrue: [ buffer nextPut: next ].\n\tpos := buffer position.\n\tbuffer skip: -1.\n\n\taCollection allSatisfy: [ :each |\n\t    nextSource := self nextWithBuffer: buffer.\n\t    nextSource isNil ifTrue: [ ^ws contents ].\n\t    next := nextSource next.\n\t    nextSource == self ifTrue: [ buffer nextPut: next ].\n\t    each = next\n\t].\n    ]   whileFalse: [ buffer position: pos ].\n    \"Remove from the answered stream the first element of aCollection\"\n    ^ws\n\tskip: -1;\n\tcontents",
          "literals": [],
          "methodName": "upToAll:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "print:": {
          "src": "print: anObject\n    \"Print anObject on the receiver by sending printOn: to anObject. This\n     method is provided so that you can use cascading and obtain\n     better-looking code\"\n    anObject printOn: self",
          "literals": [],
          "methodName": "print:",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        },
        "nl": {
          "src": "nl\n    \"Store a new line on the receiver\"\n    self nextPut: Character nl",
          "literals": [],
          "methodName": "nl",
          "className": "Stream",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": [
        {
          "className": "ObjectDumper",
          "instance_methods": {
            "next": {
              "src": "next\n    \"Load an object from the underlying stream\"\n    ^self load",
              "literals": [],
              "methodName": "next",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "nextAsciiz": {
              "src": "nextAsciiz\n    \"Private - Get a Null-terminated string from stream and answer it\"\n\n    | ch answer |\n    answer := WriteStream on: (String new: 30). \"Hopefully large enough\"\n\n    [\n\tch := stream next. ch asciiValue = 0 ] whileFalse: [\n\tanswer nextPut: ch\n    ].\n    ^answer contents",
              "literals": [],
              "methodName": "nextAsciiz",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "dumpTo:": {
              "src": "dumpTo: anObjectDumper\n    \"Dump the object stored in the proxy to anObjectDumper\"\n    \n    anObjectDumper dumpContentsOf: self object",
              "literals": [],
              "methodName": "dumpTo:",
              "className": "NullProxy",
              "category": "<unknown>",
              "byteCodes": []
            },
            "lookupIndex:": {
              "src": "lookupIndex: index\n    \"Private - If index is a valid index into the toObjects map, evaluate\n     return the object associated to it.  Else, fail.\"\n\n    ^toObjects at: index",
              "literals": [],
              "methodName": "lookupIndex:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "proxyFor:": {
              "src": "proxyFor: anObject\n    \"Answer a valid proxy for an object, or the object itself if none could\n     be found\"\n    Proxies keysAndValuesDo: [ :key :value |\n\t(anObject isKindOf: key) ifTrue: [ ^value on: anObject ]\n    ].\n    ^anObject",
              "literals": [],
              "methodName": "proxyFor:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "object:": {
              "src": "object: theObject\n    \"Set the object to be dumped to theObject.  This should not be\n     overridden.\"\n    object := theObject",
              "literals": [],
              "methodName": "object:",
              "className": "AlternativeObjectProxy",
              "category": "<unknown>",
              "byteCodes": []
            },
            "primLoad:": {
              "src": "primLoad: index\n    \"Private - Basic code to load an object from the stream associated with the\n     receiver, assuming it doesn't use proxies and the like.  The first four\n     bytes of the encoding are in index\"\n\n    | object class |\n    index > 0 ifTrue: [ ^self lookupIndex: index ].\n\n    class := self loadClass.\n    class isMetaclass ifTrue: [ ^class instanceClass ].\n\n    object := self loadFixedPart: class.\n\n    class isVariable ifFalse: [ ^object ].\n\n    class isPointers\n\tifTrue: [ ^self load: object through: [ self load ] ].\n\n    class isBytes\n\tifFalse: [ ^self load: object through: [ stream nextUlong ] ].\n\n    ^class == String\n\tifTrue: [ self load: object through: [ stream next ] ]\n\tifFalse: [ self load: object through: [ stream nextByte ] ]",
              "literals": [],
              "methodName": "primLoad:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "initializeStream:": {
              "src": "initializeStream: aStream\n    \"Private - Initialize the receiver's instance variables\"\n\n    stream := aStream.\n    self flush.\n    ^self",
              "literals": [],
              "methodName": "initializeStream:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "store:through:": {
              "src": "store: anObject through: aBlock\n    \"Private - Store anObject's indexed instance variables into the stream.\n     To store a variable, pass its value to aBlock.\"\n\n    1 to: anObject basicSize do: [ :i |\n\taBlock value: (anObject basicAt: i)\n    ].\n    ^anObject",
              "literals": [],
              "methodName": "store:through:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "isSmallInteger:": {
              "src": "isSmallInteger: anObject\n    \"Private - Answer true if the receiver is a small integer (<2^30\n     in GNU Smalltalk)\"\n\n    ^anObject class == SmallInteger",
              "literals": [],
              "methodName": "isSmallInteger:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "example": {
              "src": "example\n    \"This is a real torture test: it outputs recursive objects,\n     identical objects multiple times, classes, metaclasses,\n     integers, characters and proxies (which is also a test of more\n     complex objects)!\"\n\n    | file test dumper method |\n    Transcript nextPutAll: 'Must print true without errors.'; nl.\n    file := FileStream open: 'dumptest' mode: FileStream write.\n    test := Array new: 1. test at: 1 put: test.\n    method := thisContext method.\n\n    (ObjectDumper on: file)\n\tdump: 'asdf';\t\t\"String\"\n\tdump: #('asdf' 1 2 $a);\t\"Array\"\n\tdump: Array;\t\t\"Class\"\n\tdump: 'asdf';\t\t\"String (must be identical to the first)\"\n\tdump: Array class;\t\"Metaclass\"\n\tdump: test;\t\t\"Circular reference\"\n\tdump: Processor;\t\"SingletonProxy\"\n\tdump: Processor;\t\"SingletonProxy\"\n\tdump: method;\t\t\"PluggableProxy\"\n\tdump: method.\t\t\"PluggableProxy\"\n    file close.\n\n    file := FileStream open: 'dumptest' mode: FileStream read.\n    dumper := ObjectDumper on: file.\n    ((test := dumper load) = 'asdf') printNl.\n    (dumper load = #('asdf' 1 2 $a)) printNl.\n    (dumper load == Array) printNl.\n    (dumper load == test) printNl.\n    (dumper load == Array class) printNl.\n    test := dumper load.\n    (test == (test at: 1)) printNl.\n    (dumper load == Processor) printNl.\n    (dumper load == Processor) printNl.\n    (dumper load == method) printNl.\n    (dumper load == method) printNl.\n    file close",
              "literals": [],
              "methodName": "example",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "loadFixedPart:": {
              "src": "loadFixedPart: class\n    \"Private - Load the fixed instance variables of a new instance of class\"\n\n    | object |\n    object := class isVariable\n\tifTrue: [ class basicNew: stream nextLong ]\n\tifFalse: [ class basicNew ].\n\n    self register: object.\n\n    1 to: class instSize do: [ :i |\n\tobject instVarAt: i put: self load\n    ].\n    ^object",
              "literals": [],
              "methodName": "loadFixedPart:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "storeGlobal:": {
              "src": "storeGlobal: anObject\n    | namespace |\n    (self lookup: anObject) ifTrue: [ ^anObject ].\n\n    (anObject respondsTo: #environment)\n\tifTrue: [ namespace := anObject environment ]\n\n\tifFalse: [\n\t    (anObject respondsTo: #superspace)\n\t\tifTrue: [ namespace := anObject superspace ]\n\t\tifFalse: [ namespace := nil \"read as `Smalltalk' upon load.\" ]\n\t].\n\n    self\n\tdump: namespace;\n\tregister: anObject.\n\n    stream\n\tnextPutAll: anObject name;\n\tnextPutByte: 0",
              "literals": [],
              "methodName": "storeGlobal:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "disableProxyFor:": {
              "src": "disableProxyFor: aClass\n    \"Disable proxies for instances of aClass and its descendants\"\n    self registerProxyClass: NullProxy for: aClass",
              "literals": [],
              "methodName": "disableProxyFor:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "load": {
              "src": "load\n    \"Load an object from the stream associated with the receiver and answer\n     it\"\n\n    | index |\n\n    \"Special-case metaclasses and other objects\"\n    index := stream nextLong.\n    ^index < 0\n\tifTrue: [ self specialCaseLoad: index ]\n\tifFalse: [ self primLoad: index ]",
              "literals": [],
              "methodName": "load",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "flush": {
              "src": "flush\n    \"`Forget' any information on previously stored objects.\"\n    toObjects := OrderedCollection new.\n    fromObjects := IdentityDictionary new.",
              "literals": [],
              "methodName": "flush",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "stream": {
              "src": "stream\n    \"Answer the ByteStream to which the ObjectDumper will write\n     and from which it will read.\"\n    ^stream",
              "literals": [],
              "methodName": "stream",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "lookup:": {
              "src": "lookup: anObject\n    | index |\n    index := fromObjects at: anObject ifAbsent: [ 0 ].\n    stream nextPutLong: index.\n    ^index > 0",
              "literals": [],
              "methodName": "lookup:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "primDump:": {
              "src": "primDump: anObject\n    \"Private - Basic code to dump anObject on the stream associated with the\n     receiver, without using proxies and the like.\"\n\n    | class |\n    self storeClass: (class := anObject class).\n    self register: anObject.\n\n    class isVariable ifTrue: [ stream nextPutLong: anObject basicSize ].\n\n    1 to: class instSize do: [ :i |\n\tself dump: (anObject instVarAt: i)\n    ].\n\n    class isVariable ifFalse: [ ^self ].\n\n    class isPointers\n\tifTrue: [ ^self store: anObject through: [ :obj | self dump: obj ] ].\n\n    class isBytes\n\tifFalse: [ ^self store: anObject through: [ :long | stream nextPutLong: long ] ].\n\n    ^anObject isString\n\tifTrue: [ self store: anObject through: [ :char | stream nextPut: char ] ]\n\tifFalse: [ self store: anObject through: [ :byte | stream nextPutByte: byte ] ]",
              "literals": [],
              "methodName": "primDump:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "specialCaseDump:": {
              "src": "specialCaseDump: anObject\n    \"Private - Store special-cased objects. These include booleans, integers,\n     nils, characters, classes and Processor. Answer true if object belongs\n     to one of these categories, else do nothing and answer false\"\n\n    SpecialCaseDump keysAndValuesDo: [ :index :each |\n\t((each key) value: anObject) ifTrue: [\n\t    stream skip: -4; nextPutLong: index negated.\n\t    (each value) value: self value: anObject.\n\t    self register: anObject.\n\t    ^true\n\t]\n    ].\n    ^false",
              "literals": [],
              "methodName": "specialCaseDump:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "register:": {
              "src": "register: anObject\n    \"Private - Register the anObject in the fromObjects and toObjects maps.\n     Assumes that anObject is absent in these maps. Answer anObject\"\n\n    \"(fromObject includesKey: anObject) ifTrue: [\n\t^self error: 'Huh?!? Assertion failed' ].   \"\n\n    toObjects addLast: anObject.\n    fromObjects at: anObject put: toObjects size.\n    ^anObject",
              "literals": [],
              "methodName": "register:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "specialCaseLoad:": {
              "src": "specialCaseLoad: index\n\n    \"Private - The first 4 bytes in the file were less than 0.\n     Load the remaining info about the object and answer it.\"\n\n    | object |\n    index > SpecialCaseLoad size ifTrue: [ ^self error: 'error in file' ].\n\n    object := (SpecialCaseLoad at: index negated) value: self.\n    ^self register: object",
              "literals": [],
              "methodName": "specialCaseLoad:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "loadGlobal": {
              "src": "loadGlobal\n    \"Private - Load a global object from the stream\"\n\n    | object space index |\n    index := stream nextLong.\n    index > 0 ifTrue: [ ^self lookupIndex: index ].\n\n    space := self load.\n    space isNil ifTrue: [ space := Smalltalk ].\n\n    object := space\n\tat: self nextAsciiz asGlobalKey\n\tifAbsent: [ ^self error: 'Unknown global referenced' ].\n\n    ^self register: object",
              "literals": [],
              "methodName": "loadGlobal",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "new": {
              "src": "new\n    self shouldNotImplement",
              "literals": [],
              "methodName": "new",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "loadFromVersion:fixedSize:": {
              "src": "loadFromVersion: version fixedSize: instSize\n    \"Private - Basic code to load an object from a stream associated with\n     the receiver, calling the class'\n     #convertFromVersion:withFixedVariables:instanceVariables:for: method.\n     version will be the first parameter to that method, while instSize\n     will be the size of the second parameter.  The object returned by\n     that method is registered and returned.\"\n\n    | object class realSize size fixed indexed placeholder index |\n    index := stream nextLong.\n    index > 0 ifTrue: [ ^self lookupIndex: index ].\n\n    self register: (placeholder := Object new).\n    class := self loadClass.\n    class isVariable ifTrue: [ size := stream nextUlong ].\n\n    realSize := instSize isNil\n\tifTrue: [ class nonVersionedInstSize ]\n\tifFalse: [ instSize ].\n\n    (1 to: realSize) collect: [ :i | self load ].\n\n    class isVariable ifTrue: [\n\tclass isPointers\n\t    ifTrue: [ indexed := (1 to: size) collect: [ :i | self load ] ].\n\n\tclass == String\n\t    ifTrue: [ indexed := (1 to: size) collect: [ :i | stream next ] ].\n\n\t(class isBytes and: [ indexed isNil ])\n\t    ifTrue: [ indexed := (1 to: size) collect: [ :i | stream nextByte ] ].\n\n\tindexed isNil\n\t    ifTrue: [ indexed := (1 to: size) collect: [ :i | stream nextUlong ] ].\n    ].\n\n    placeholder become: (class\n\tconvertFromVersion: version\n\twithFixedVariables: fixed\n\tindexedVariables: indexed\n\tfor: self).\n\n    ^placeholder",
              "literals": [],
              "methodName": "loadFromVersion:fixedSize:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "atEnd": {
              "src": "atEnd\n    \"Answer whether the underlying stream is at EOF\"\n    ^stream atEnd",
              "literals": [],
              "methodName": "atEnd",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "primObject": {
              "src": "primObject\n    \"Reconstruct the object stored in the proxy and answer it.  This\n     method must not be overridden\"\n    ^object",
              "literals": [],
              "methodName": "primObject",
              "className": "AlternativeObjectProxy",
              "category": "<unknown>",
              "byteCodes": []
            },
            "registerProxyClass:for:": {
              "src": "registerProxyClass: aProxyClass for: aClass\n    \"Register the proxy class aProxyClass - descendent of DumperProxy -\n     to be used for instances of aClass and its descendants\"\n    (aProxyClass acceptUsageForClass: aClass)\n\tifFalse: [ self error: 'registration request denied' ].\n\n    Proxies at: aClass put: aProxyClass",
              "literals": [],
              "methodName": "registerProxyClass:for:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "dump:to:": {
              "src": "dump: anObject to: aFileStream\n    \"Dump anObject to aFileStream. Answer anObject\"\n\n    ^(self on: aFileStream) dump: anObject",
              "literals": [],
              "methodName": "dump:to:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "stream:": {
              "src": "stream: aByteStream\n    \"Set the ByteStream to which the ObjectDumper will write\n     and from which it will read.\"\n    stream := aByteStream",
              "literals": [],
              "methodName": "stream:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "dumpContentsOf:": {
              "src": "dumpContentsOf: anObject\n    \"Dump anObject on the stream associated with the receiver. Answer\n     anObject\"\n\n    | index |\n    (self lookup: anObject) ifTrue: [ ^anObject ].\n\n    anObject preStore.\n    [ self primDump: anObject ] ensure: [ anObject postStore ].\n    ^self register: anObject",
              "literals": [],
              "methodName": "dumpContentsOf:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "isClass:": {
              "src": "isClass: loadedClass\n    \"Private - Answer whether loadedClass is really a class; only use\n    optimized selectors to avoid mess with objects that do not inherit\n    from Object.\"\n\n    ^loadedClass class class == Metaclass",
              "literals": [],
              "methodName": "isClass:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "acceptUsageForClass:": {
              "src": "acceptUsageForClass: aClass\n    \"The receiver was asked to be used as a proxy for the class aClass.\n     The registration is fine if the class is actually a singleton.\"\n    | singleton |\n    singleton := aClass someInstance.\n    singleton nextInstance isNil ifFalse: [ ^false ].\n    Singletons isNil ifTrue: [ Singletons := IdentityDictionary new ].\n    Singletons at: aClass put: singleton.\n    ^true",
              "literals": [],
              "methodName": "acceptUsageForClass:",
              "className": "SingletonProxy",
              "category": "<unknown>",
              "byteCodes": []
            },
            "proxyClassFor:": {
              "src": "proxyClassFor: anObject\n    \"Answer the class of a valid proxy for an object, or nil if none could\n     be found\"\n    Proxies keysAndValuesDo: [ :key :value |\n\t(anObject isKindOf: key) ifTrue: [ ^value ]\n    ].\n    ^nil",
              "literals": [],
              "methodName": "proxyClassFor:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "loadClass": {
              "src": "loadClass\n    \"Private - Load the next object's class from stream\"\n\n    | isMeta loadedClass |\n\n    isMeta := stream nextByte = 0.\n    loadedClass := self loadGlobal.\n    (self isClass: loadedClass) ifFalse: [ ^self error: 'Bad class'. ].\n    ^isMeta \n\tifTrue: [ loadedClass class ]\n\tifFalse: [ loadedClass ]",
              "literals": [],
              "methodName": "loadClass",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "hasProxyFor:": {
              "src": "hasProxyFor: aClass\n    \"Answer whether a proxy class has been registered for instances\n     of aClass.\"\n    Proxies keysDo: [ :any |\n\t(aClass inheritsFrom: any) ifTrue: [ ^true ].\n\taClass == any ifTrue: [ ^true ]\n    ].\n    ^false",
              "literals": [],
              "methodName": "hasProxyFor:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "loadFrom:": {
              "src": "loadFrom: anObjectDumper\n    \"Retrieve the object.  If the version number doesn't match the\n     #binaryRepresentationVersion answered by the class, call the class'\n     #convertFromVersion:withFixedVariables:instanceVariables:for: method.\n     The stored version number will be the first parameter to that method\n     (or nil if the stored object did not employ a VersionableObjectProxy),\n     the remaining parameters will be respectively the fixed instance\n     variables, the indexed instance variables (or nil if the class is\n     fixed), and the ObjectDumper itself.\n     If no VersionableObjectProxy, the class is sent #nonVersionedInstSize\n     to retrieve the number of fixed instance variables stored for the\n     non-versioned object.\"\n\n    | version object instSize |\n    version := anObjectDumper stream nextLong.\n    version := version >= 0\n\tifTrue: [\n\t    \"The version was actually an object index -- move back in the stream.\"\n\t    anObjectDumper stream skip: -4.\n\t    instSize := nil.\n\t    nil ]\n\tifFalse: [\n\t    instSize := anObjectDumper stream nextUlong.\n\t    -1 - version\n\t].\n\t    \n    ^version == self object class binaryRepresentationVersion\n\tifTrue: [ anObjectDumper load ]\n\tifFalse: [ anObjectDumper loadFromVersion: version fixedSize: instSize ]",
              "literals": [],
              "methodName": "loadFrom:",
              "className": "VersionableObjectProxy",
              "category": "<unknown>",
              "byteCodes": []
            },
            "specialCaseIf:dump:load:": {
              "src": "specialCaseIf: aBlock dump: dumpBlock load: loadBlock\n    \"Private - This method establishes a condition on which a particular\n     method must be used to save an object.\n     An application should not use this method, since it might cause\n     failure to load file that set the special-case blocks differently;\n     instead, you should use ObjectDumper's higher level proxy feature,\n     i.e. its #registerProxyClass:for: method - which builds on the\n     low-level feature enabled by this method but without its inherent\n     problems.\"\n\n    SpecialCaseDump addLast: aBlock -> dumpBlock.\n    SpecialCaseLoad addLast: loadBlock",
              "literals": [],
              "methodName": "specialCaseIf:dump:load:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "on:": {
              "src": "on: anObject\n    \"Answer a proxy to be used to save anObject.  The proxy\n     stores the class and restores the object by looking into\n     a dictionary of class -> singleton objects.\"\n\n    (Singletons includesKey: anObject class)\n\tifTrue: [ ^super on: anObject class ].\n\n    self error: 'class not registered within SingletonProxy'",
              "literals": [],
              "methodName": "on:",
              "className": "SingletonProxy",
              "category": "<unknown>",
              "byteCodes": []
            },
            "nextPut:": {
              "src": "nextPut: anObject\n    \"Store an object on the underlying stream\"\n    self dump: anObject",
              "literals": [],
              "methodName": "nextPut:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "initialize": {
              "src": "initialize\n    \"Initialize the ObjectDumper class\"\n    Proxies := IdentityDictionary new.\n    SpecialCaseDump := OrderedCollection new.\n    SpecialCaseLoad := OrderedCollection new.\n\n    \"We can only use #isNil, #==, #class here\"\n    self\n\tspecialCaseIf: [ :object | object isNil ]\n\tdump: [ :client :object | ]\n\tload: [ :client | nil ];\n\n\tspecialCaseIf: [ :object | object == true ]\n\tdump: [ :client :object | ]\n\tload: [ :client | true ];\n\n\tspecialCaseIf: [ :object | object == false ]\n\tdump: [ :client :object | ]\n\tload: [ :client | false ];\n\n\tspecialCaseIf: [ :object | self isSmallInteger: object ]\n\tdump: [ :client :object | client stream nextPutLong: object ]\n\tload: [ :client | client stream nextLong ];\n\n\tspecialCaseIf: [ :object | object class == Character ]\n\tdump: [ :client :object | client stream nextPut: object ]\n\tload: [ :client | client stream next ];\n\n\tspecialCaseIf: [ :object | object class class == Metaclass ]\n\tdump: [ :client :object | client storeGlobal: object ]\n\tload: [ :client | client loadGlobal ];\n\n\tspecialCaseIf: [ :object | object class == Metaclass ]\n\tdump: [ :client :object | client storeGlobal: object asClass ]\n\tload: [ :client | client loadGlobal class ];\n\n\tspecialCaseIf: [ :object | object == Smalltalk ]\n\tdump: [ :client :object | ]\n\tload: [ :client | Smalltalk ];\n\n\tspecialCaseIf: [ :object | object class == Namespace ]\n\tdump: [ :client :object | client storeGlobal: object ]\n\tload: [ :client | client loadGlobal ];\n\n\tspecialCaseIf: [ :object | object class == RootNamespace ]\n\tdump: [ :client :object | client storeGlobal: object ]\n\tload: [ :client | client loadGlobal ];\n\n\tspecialCaseIf: [ :object | object class == Symbol ]\n\tdump: [ :client :object | client stream nextPutAll: object; nextPutByte: 0 ]\n\tload: [ :client | client nextAsciiz asSymbol ];\n\n\tspecialCaseIf: [ :object | self hasProxyFor: object class ]\n\tdump: [ :client :object || class |\n\t    (client lookup: object) ifFalse: [\n\t\tclient storeGlobal: (class := self proxyClassFor: object).\n\t\t(class on: object) dumpTo: client.\n\t\tclient register: object\n\t    ]\n\t]\n\tload: [ :client |\n\t    | index placeholder object |\n\n\t    \"Special-case metaclasses and other objects\"\n\t    index := client stream nextLong.\n\t    index = 0\n\t\tifTrue: [ client register: (client loadGlobal loadFrom: client) ]\n\t\tifFalse: [ client lookupIndex: index ]\n\t]",
              "literals": [],
              "methodName": "initialize",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "load:through:": {
              "src": "load: anObject through: aBlock\n    \"Private - Fill anObject's indexed instance variables from the stream.\n     To get a variable, evaluate aBlock. Answer anObject\"\n\n    1 to: anObject basicSize do: [ :i |\n\tanObject\n\t    basicAt: i\n\t    put: aBlock value\n    ].\n    ^anObject postLoad; yourself",
              "literals": [],
              "methodName": "load:through:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "storeClass:": {
              "src": "storeClass: aClass\n    \"Private - Store the aClass class in stream. The format is:\n\t- for a metaclass, a 0 followed by the asciiz name of its instance\n\t- for a class, a 1 followed by its asciiz name\"\n\n    \"We don't register metaclasses; instead we register their instance\n     (the class) and use a byte to distinguish between the two cases.\"\n\n    aClass isMetaclass\n\tifTrue: [ stream nextPutByte: 0 ]\n\tifFalse: [ stream nextPutByte: 1 ].\n\n    self storeGlobal: aClass asClass",
              "literals": [],
              "methodName": "storeClass:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "dump:": {
              "src": "dump: anObject\n    \"Dump anObject on the stream associated with the receiver. Answer\n     anObject\"\n\n    (self lookup: anObject) ifTrue: [ ^anObject ].\n    (self specialCaseDump: anObject) ifFalse: [\n\tanObject preStore.\n\t[ self primDump: anObject ] ensure: [ anObject postStore ]\n    ].",
              "literals": [],
              "methodName": "dump:",
              "className": "ObjectDumper",
              "category": "<unknown>",
              "byteCodes": []
            },
            "object": {
              "src": "object\n    \"Reconstruct the object stored in the proxy and answer it;\n     the binaryRepresentationObject is sent the\n     #reconstructOriginalObject message, and the resulting\n     object is sent the #postLoad message.\"\n\n    ^Singletons at: super object ifAbsent: [\n\tself error: 'class not registered within SingletonProxy' ]",
              "literals": [],
              "methodName": "object",
              "className": "SingletonProxy",
              "category": "<unknown>",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "PositionableStream",
          "instance_methods": {
            "next": {
              "src": "next\n    \"Answer the next item of the receiver.  Returns nil when at end of stream.\"\n\n    | element |\n    (access bitAnd: 1) = 0\n    \tifTrue: [ ^self shouldNotImplement ].\n    self atEnd ifTrue: [ ^nil ].\n    element := collection at: ptr.\n    ptr := ptr + 1.\n    ^element",
              "literals": [],
              "methodName": "next",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "basicAtEnd": {
              "src": "basicAtEnd\n    \"Answer whether the objects in the stream have reached an end.\n     This method must NOT be overridden.\"\n    ^ptr > endPtr",
              "literals": [],
              "methodName": "basicAtEnd",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "beWriteOnly": {
              "src": "beWriteOnly\n    access := 2",
              "literals": [],
              "methodName": "beWriteOnly",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "reverseContents": {
              "src": "reverseContents\n    \"Returns a collection of the same type that the stream accesses, up to \n    and including the final element, but in reverse order.\"\n    | newCollection |\n    newCollection := self species new: endPtr.\n    1 to: endPtr do:\n\t[ :i | newCollection at: i put: (collection at: endPtr - i + 1) ].\n    ^newCollection",
              "literals": [],
              "methodName": "reverseContents",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "beReadWrite": {
              "src": "beReadWrite\n    access := 3",
              "literals": [],
              "methodName": "beReadWrite",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "copyFrom:to:": {
              "src": "copyFrom: start to: end\n    \"Answer the collection on which the receiver is streaming, from\n     the start-th item to the end-th\"\n\n    ^collection copyFrom: start to: end",
              "literals": [],
              "methodName": "copyFrom:to:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "truncate": {
              "src": "truncate\n    \"Truncate the receiver to the current position - only valid\n     for writing streams\"\n\n    (access bitAnd: 2) = 0\n\tifTrue: [ self shouldNotImplement ]\n\tifFalse: [ endPtr := ptr - 1 ]",
              "literals": [],
              "methodName": "truncate",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "close": {
              "src": "close\n    \"Disassociate a stream from its backing store.\"\n    self flush.\n    collection := nil.\n    endPtr := nil.\n    ptr := nil.\n    access := nil",
              "literals": [],
              "methodName": "close",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "skip:": {
              "src": "skip: anInteger\n    \"Move the current position by anInteger places, either forwards or\n    backwards.\"\n    self position: ((self position + anInteger max: 0) min: endPtr).",
              "literals": [],
              "methodName": "skip:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "setToEnd": {
              "src": "setToEnd\n    \"Move the current position to the end of the stream.\"\n    ptr := endPtr + 1",
              "literals": [],
              "methodName": "setToEnd",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "basicPosition:": {
              "src": "basicPosition: anInteger\n    \"Move the stream pointer to the anInteger-th object\"\n    (anInteger between: 0 and: endPtr)\n\tifTrue: [ ptr := anInteger + 1 ]\n\tifFalse: [ SystemExceptions IndexOutOfRange signalOn: self withIndex: ptr ]",
              "literals": [],
              "methodName": "basicPosition:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "atEnd": {
              "src": "atEnd\n    \"Answer whether the objects in the stream have reached an end\"\n    ^ptr > endPtr",
              "literals": [],
              "methodName": "atEnd",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "status:": {
              "src": "status: aString\n    \"When working with a stream on strings, this method can be useful!\n     Format of the output:\n\t'ABCDEFG'   aString\n\t   ^\t\t    \"\n    Transcript\n\tprint: (collection copyFrom: 1 to: endPtr);\n\tnextPutAll: '    ';\n\tnextPutAll: aString;\n\tnl;\n\tnext: self position put: Character space;\n\tnextPut: $^;\n\tnl",
              "literals": [],
              "methodName": "status:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "isEmpty": {
              "src": "isEmpty\n    \"Answer whether the stream has no objects\"\n    ^endPtr = 0",
              "literals": [],
              "methodName": "isEmpty",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "collection": {
              "src": "collection\n    ^collection",
              "literals": [],
              "methodName": "collection",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "isExternalStream": {
              "src": "isExternalStream\n    \"We stream on a collection residing in the image, so answer false\"\n    ^false",
              "literals": [],
              "methodName": "isExternalStream",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "peek": {
              "src": "peek\n    \"Returns the next element of the stream without moving the pointer.\n    Returns nil when at end of stream.\"\n    \n    (access bitAnd: 1) = 0\n    \tifTrue: [ ^self shouldNotImplement ].\n    self atEnd ifTrue: [ ^nil ].\n    ^collection at: ptr",
              "literals": [],
              "methodName": "peek",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "position:": {
              "src": "position: anInteger\n    \"Move the stream pointer to the anInteger-th object\"\n    (anInteger between: 0 and: endPtr)\n\tifTrue: [ ptr := anInteger + 1 ]\n\tifFalse: [ SystemExceptions IndexOutOfRange signalOn: self withIndex: ptr ]",
              "literals": [],
              "methodName": "position:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "size": {
              "src": "size\n    \"Answer the size of data on which we are streaming.\"\n    ^endPtr",
              "literals": [],
              "methodName": "size",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "contents": {
              "src": "contents\n    \"Returns a collection of the same type that the stream accesses, up to \n    and including the final element.\"\n    ^collection copyFrom: 1 to: endPtr",
              "literals": [],
              "methodName": "contents",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "species": {
              "src": "species\n    \"The collections returned by #upTo: etc. are the same kind as\n    those returned by the collection with methods such as #select:\"\n    ^collection species",
              "literals": [],
              "methodName": "species",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "on:from:to:": {
              "src": "on: aCollection from: firstIndex to: lastIndex\n    \"Answer an instance of the receiver streaming from\n     the firstIndex-th item of aCollection to the lastIndex-th\"\n    ^self on: (aCollection copyFrom: firstIndex to: lastIndex)",
              "literals": [],
              "methodName": "on:from:to:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "skipSeparators": {
              "src": "skipSeparators\n    \"Advance the receiver until we find a character that is not a\n     separator.  Answer false if we reach the end of the stream,\n     else answer true; in this case, sending #next will return the\n     first non-separator character (possibly the same to which the\n     stream pointed before #skipSeparators was sent).\"\n    [   self atEnd ifTrue: [^false].\n\tself peek isSeparator ] whileTrue: [ self next ].\n\n    ^true",
              "literals": [],
              "methodName": "skipSeparators",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "reset": {
              "src": "reset\n    \"Move the stream back to its first element. For write-only streams,\n    the stream is truncated there.\"\n    self position: 0",
              "literals": [],
              "methodName": "reset",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "on:": {
              "src": "on: aCollection\n    \"Answer an instance of the receiver streaming on the\n    whole contents of aCollection\"\n    self subclassResponsibility",
              "literals": [],
              "methodName": "on:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "beReadOnly": {
              "src": "beReadOnly\n    access := 1",
              "literals": [],
              "methodName": "beReadOnly",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "peekFor:": {
              "src": "peekFor: anObject\n    \"Returns true and gobbles the next element from the stream of it is\n    equal to anObject, returns false and doesn't gobble the next element\n    if the next element is not equal to anObject.\"\n    self atEnd ifTrue: [ ^false ].\n    ^self next = anObject\n    \tifTrue: [ true ]\n    \tifFalse: [ self skip: -1. false ]",
              "literals": [],
              "methodName": "peekFor:",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            },
            "position": {
              "src": "position\n    \"Answer the current value of the stream pointer\"\n    ^ptr - 1",
              "literals": [],
              "methodName": "position",
              "className": "PositionableStream",
              "category": "class type methods",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": [
            {
              "className": "ReadStream",
              "instance_methods": {
                "size": {
                  "src": "size\n    \"Answer the receiver's size.\"\n    ^collection size",
                  "literals": [],
                  "methodName": "size",
                  "className": "ReadStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "on:": {
                  "src": "on: aCollection\n    \"Answer a new stream working on aCollection from its start.\"\n    ^(self basicNew initCollection: aCollection) beReadOnly",
                  "literals": [],
                  "methodName": "on:",
                  "className": "ReadStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "reverseContents": {
                  "src": "reverseContents\n    \"May be faster than generic stream reverseContents.\"\n    | aCollection i numElts |\n    numElts := collection size.\n    aCollection := collection copyEmpty: numElts.\n    i := 0.\n    [ i := i + 1. \n      i <= endPtr ] whileTrue:\n    \t[ aCollection at: numElts - i + 1\n\t    \t      put: (collection at: i) ].\n    ^aCollection",
                  "literals": [],
                  "methodName": "reverseContents",
                  "className": "ReadStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "initCollection:": {
                  "src": "initCollection: aCollection\n    collection := aCollection.\n    ptr := 1.\n    endPtr := collection size",
                  "literals": [],
                  "methodName": "initCollection:",
                  "className": "ReadStream",
                  "category": "private methods",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": []
            },
            {
              "className": "WriteStream",
              "instance_methods": {
                "with:from:to:": {
                  "src": "with: aCollection from: firstIndex to: lastIndex\n    \"Answer a new instance of the receiver which streams from the\n     firstIndex-th item of aCollection to the lastIndex-th. The\n     pointer is moved to the last item in that range.\"\n    ^self with: (aCollection copyFrom: firstIndex to: lastIndex).",
                  "literals": [],
                  "methodName": "with:from:to:",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "growCollection": {
                  "src": "growCollection\n   \"Private - Double the size of the collection or, if its size < 8,\n    grow it to 8 places\"\n   | size |\n   size := collection size.\n\n   \"Guess which collection is which :-)\"\n   collection := ((collection copyEmpty: (size * 2 max: 8))\n\treplaceFrom: 1 to: collection size with: collection startingAt: 1;\n\tyourself).",
                  "literals": [],
                  "methodName": "growCollection",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "size": {
                  "src": "size\n    \"Answer how many objects have been written\"\n    ^ptr - 1",
                  "literals": [],
                  "methodName": "size",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "contents": {
                  "src": "contents\n    \"Returns a collection of the same type that the stream accesses, up to \n    and including the final element.\"\n    ^collection copyFrom: 1 to: ptr - 1",
                  "literals": [],
                  "methodName": "contents",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "on:": {
                  "src": "on: aCollection\n    \"Answer a new instance of the receiver which streams on aCollection.\n     Every item of aCollection is discarded.\"\n    ^(self basicNew initCollection: aCollection)\n\tbeWriteOnly; \n\ttruncate;\n\tyourself",
                  "literals": [],
                  "methodName": "on:",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "with:": {
                  "src": "with: aCollection\n    \"Answer a new instance of the receiver which streams from the end\n     of aCollection.\"\n    ^(self basicNew initCollection: aCollection)\n\tbeWriteOnly; \n\tmoveToEnd;\n\tyourself",
                  "literals": [],
                  "methodName": "with:",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "nextPut:": {
                  "src": "nextPut: anObject\n    \"Store anObject as the next item in the receiver. Grow the\n     collection if necessary\"\n\n    \"(access bitAnd: 2) = 0\n       ifTrue: [ ^self shouldNotImplement ].\"\n    ptr > collection size ifTrue: [ self growCollection ].\n    collection at: ptr put: anObject.\n    ptr > endPtr ifTrue: [ endPtr := ptr ].\n    ptr := ptr + 1.\n    ^anObject",
                  "literals": [],
                  "methodName": "nextPut:",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "reverseContents": {
                  "src": "reverseContents\n    \"Returns a collection of the same type that the stream accesses, up to \n    and including the final element, but in reverse order.\"\n    | newCollection |\n    newCollection := self species new: ptr - 1.\n    1 to: endPtr do:\n\t[ :i | newCollection at: i put: (collection at: ptr - i) ].\n    ^newCollection",
                  "literals": [],
                  "methodName": "reverseContents",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "initCollection:": {
                  "src": "initCollection: aCollection\n    collection := aCollection.\n    ptr := 1.\n    endPtr := 0.",
                  "literals": [],
                  "methodName": "initCollection:",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                },
                "moveToEnd": {
                  "src": "moveToEnd\n    endPtr := collection size.\n    self setToEnd",
                  "literals": [],
                  "methodName": "moveToEnd",
                  "className": "WriteStream",
                  "category": "private methods",
                  "byteCodes": []
                }
              },
              "class_methods": {},
              "subclasses": [
                {
                  "className": "ReadWriteStream",
                  "instance_methods": {
                    "position:": {
                      "src": "position: anInteger\n    \"Unlike WriteStreams, ReadWriteStreams don't truncate the stream\"\n    self basicPosition: anInteger",
                      "literals": [],
                      "methodName": "position:",
                      "className": "ReadWriteStream",
                      "category": "private",
                      "byteCodes": []
                    },
                    "useWholeStream": {
                      "src": "useWholeStream\n    \"Private - Makes sure that the contents message to this object\n     returns the whole contents, not just that which has been written\n     so far.\"\n    endPtr := collection size",
                      "literals": [],
                      "methodName": "useWholeStream",
                      "className": "ReadWriteStream",
                      "category": "private",
                      "byteCodes": []
                    },
                    "on:": {
                      "src": "on: aCollection\n    \"Answer a new stream working on aCollection from its start. The\n    stream starts at the front of aCollection\"\n    ^(super on: aCollection) beReadWrite; useWholeStream",
                      "literals": [],
                      "methodName": "on:",
                      "className": "ReadWriteStream",
                      "category": "private",
                      "byteCodes": []
                    },
                    "with:": {
                      "src": "with: aCollection\n    \"Answer a new instance of the receiver which streams from the end\n     of aCollection.\"\n    ^(super with: aCollection) beReadWrite",
                      "literals": [],
                      "methodName": "with:",
                      "className": "ReadWriteStream",
                      "category": "private",
                      "byteCodes": []
                    },
                    "skip:": {
                      "src": "skip: anInteger\n    \"Unlike WriteStreams, ReadWriteStreams don't truncate the stream\"\n    self basicPosition: ((self position + anInteger max: 0) min: endPtr).",
                      "literals": [],
                      "methodName": "skip:",
                      "className": "ReadWriteStream",
                      "category": "private",
                      "byteCodes": []
                    }
                  },
                  "class_methods": {},
                  "subclasses": [
                    {
                      "className": "ByteStream",
                      "instance_methods": {
                        "next": {
                          "src": "next\n    \"Return the next *character* in the ByteArray\"\n\n    ^Character value: super next",
                          "literals": [],
                          "methodName": "next",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextUlong": {
                          "src": "nextUlong\n    \"Return the next 4 bytes in the byte array, interpreted as a 32 bit unsigned int\"\n    ^self nextBytes: 4 signed: false",
                          "literals": [],
                          "methodName": "nextUlong",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPutAll:": {
                          "src": "nextPutAll: aCollection\n    \"Write all the objects in aCollection to the receiver\"\n    | collEnd relative lastCopied |\n    aCollection isEmpty ifTrue: [ ^self ].\n\n    collEnd := ptr + aCollection size - 1.\n    relative := ptr - 1.\n\n    [ \n\tlastCopied := collEnd min: collection size.\n\tcollection\n\t    replaceFrom: ptr\n\t    to: lastCopied\n\t    with: aCollection\n\t    startingAt: ptr - relative.\n\t\n\t(ptr := lastCopied + 1) > collEnd\n    ]   whileFalse: [\n\tptr > endPtr ifTrue: [ endPtr := ptr ].\n\tself growCollection\n    ].",
                          "literals": [],
                          "methodName": "nextPutAll:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextByte": {
                          "src": "nextByte\n    \"Return the next byte in the byte array\"\n    ^super next",
                          "literals": [],
                          "methodName": "nextByte",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextUshort": {
                          "src": "nextUshort\n    \"Return the next 2 bytes in the byte array, interpreted as a 16 bit unsigned int\"\n    ^self nextBytes: 2 signed: false",
                          "literals": [],
                          "methodName": "nextUshort",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPutLong:": {
                          "src": "nextPutLong: anInteger\n    \"Store anInteger (range: -2^31..2^32-1) on the byte array as 4 bytes\"\n    self nextPutBytes: 4 of: anInteger",
                          "literals": [],
                          "methodName": "nextPutLong:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "basicNextByte": {
                          "src": "basicNextByte\n    \"Private - Return the next byte in the stream\"\n    ^super next",
                          "literals": [],
                          "methodName": "basicNextByte",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "basicNextPutByte:": {
                          "src": "basicNextPutByte: anInteger\n    \"Private - Store a byte in the stream\"\n    | int |\n    int := anInteger.\n    int:= (anInteger < 0)\n\tifTrue: [ (anInteger negated - 1) bitXor: 255 ]\n\tifFalse: [ anInteger ].\n\n    ^super nextPut: (int bitAnd: 255)",
                          "literals": [],
                          "methodName": "basicNextPutByte:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextBytes:signed:": {
                          "src": "nextBytes: n signed: signed\n    \"Private - Get an integer out of the next anInteger bytes in the stream\"\n\n    | int msb |\n    int := 0.\n    0 to: n * 8 - 16 by: 8 do: [ :i |\n\tint := int + (self nextByte bitShift: i).\n    ].\n\n    msb := self nextByte.\n    (signed and: [ msb > 127 ]) ifTrue: [ msb := msb - 256 ].\n    ^int + (msb bitShift: n * 8 - 8)",
                          "literals": [],
                          "methodName": "nextBytes:signed:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextByteArray:": {
                          "src": "nextByteArray: numBytes\n    \"Return the next numBytes bytes in the byte array\"\n    ^(self next: numBytes) asByteArray",
                          "literals": [],
                          "methodName": "nextByteArray:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextLong": {
                          "src": "nextLong\n    \"Return the next 4 bytes in the byte array, interpreted as a 32 bit signed int\"\n    ^self nextBytes: 4 signed: true",
                          "literals": [],
                          "methodName": "nextLong",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPutBytes:of:": {
                          "src": "nextPutBytes: n of: anInteger\n    \"Private - Store the n least significant bytes of int in little-endian format\"\n    | int |\n\n    int := anInteger.\n    n timesRepeat: [\n\tself nextPutByte: (int bitAnd: 255).\n\tint := int bitShift: -8.\n\t(int = 0 and: [ anInteger < 0 ]) ifTrue: [ int := 255 ].\n    ].",
                          "literals": [],
                          "methodName": "nextPutBytes:of:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextSignedByte": {
                          "src": "nextSignedByte\n    \"Return the next byte in the byte array, interpreted as a 8 bit signed number\"\n    ^self nextBytes: 1 signed: true",
                          "literals": [],
                          "methodName": "nextSignedByte",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPutByte:": {
                          "src": "nextPutByte: anInteger\n    \"Store anInteger (range: -128..255) on the byte array\"\n    | int |\n    int := anInteger.\n    int:= (anInteger < 0)\n\tifTrue: [ (anInteger negated - 1) bitXor: 255 ]\n\tifFalse: [ anInteger ].\n\n    ^super nextPut: (int bitAnd: 255)",
                          "literals": [],
                          "methodName": "nextPutByte:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "species": {
                          "src": "species\n    ^String",
                          "literals": [],
                          "methodName": "species",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextShort": {
                          "src": "nextShort\n    \"Return the next 2 bytes in the byte array, interpreted as a 16 bit signed int\"\n    ^self nextBytes: 2 signed: true",
                          "literals": [],
                          "methodName": "nextShort",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPutByteArray:": {
                          "src": "nextPutByteArray: aByteArray\n    \"Store aByteArray on the byte array\"\n    ^self nextPutAll: aByteArray",
                          "literals": [],
                          "methodName": "nextPutByteArray:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPutShort:": {
                          "src": "nextPutShort: anInteger\n    \"Store anInteger (range: -32768..65535) on the byte array as 2 bytes\"\n    self nextPutBytes: 2 of: anInteger",
                          "literals": [],
                          "methodName": "nextPutShort:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        },
                        "nextPut:": {
                          "src": "nextPut: aChar\n    \"Store aChar on the byte array\"\n    aChar isCharacter\n\tifTrue: [ super nextPut: aChar value ]\n\tifFalse: [ SystemExceptions WrongClass signalOn: aChar mustBe: Character ]",
                          "literals": [],
                          "methodName": "nextPut:",
                          "className": "ByteStream",
                          "category": "private",
                          "byteCodes": []
                        }
                      },
                      "class_methods": {},
                      "subclasses": [
                        {
                          "className": "FileDescriptor",
                          "instance_methods": {
                            "popen:dir:ifFail:": {
                              "src": "popen: commandName dir: direction ifFail: aBlock\n    \"Open a pipe on the given command and evaluate aBlock\n     file cannot be opened. Else answer a new FileStream.\n     The pipe will not be automatically closed upon GC, even if the object\n     is not referenced anymore, because when you close a pipe you have to wait\n     for the associated process to terminate. To enforce automatic closing of\n     the pipe, send it #addToBeFinalized.\n     direction is interpreted from the point of view of Smalltalk: reading\n     means that Smalltalk reads the standard output of the command, writing\n     means that Smalltalk writes the standard input of the command\"\n\n    ^self basicNew\n\tfileOp: 7 with: commandName with: direction ifFail: [ ^aBlock value ];\n\tinitialize;\n\tyourself",
                              "literals": [],
                              "methodName": "popen:dir:ifFail:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextPutAll:": {
                              "src": "nextPutAll: aCollection\n    \"Put all the characters in aCollection in the file\"\n    self write: aCollection asString",
                              "literals": [],
                              "methodName": "nextPutAll:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "newBuffer": {
                              "src": "newBuffer\n    \"Private - Answer a String to be used as the receiver's buffer\"\n    ^String new: 1",
                              "literals": [],
                              "methodName": "newBuffer",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "reverseContents": {
                              "src": "reverseContents\n    \"Return the contents of the file from the last byte to the first\"\n    ^self contents reverse",
                              "literals": [],
                              "methodName": "reverseContents",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextByteArray:": {
                              "src": "nextByteArray: anInteger\n    \"Return the next 'anInteger' bytes from the stream, as a ByteArray.\"\n    ^(self next: anInteger) asByteArray",
                              "literals": [],
                              "methodName": "nextByteArray:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "copyFrom:to:": {
                              "src": "copyFrom: from to: to\n    \"Answer the contents of the file between the two given positions\"\n    | offset fromPos toPos savePos |\n    from > to ifTrue: [\n        from = to + 1 ifTrue: [ ^self species new ].\n        ^SystemExceptions ArgumentOutOfRange signalOn: from mustBeBetween: 1 and: to + 1\n    ].\n    savePos := self fileOp: 5.\n    ^[\n        self position: fromPos.\n        self next: toPos - fromPos + 1\n    ] ensure: [\n        self position: savePos\n    ]",
                              "literals": [],
                              "methodName": "copyFrom:to:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "read:": {
                              "src": "read: byteArray\n    \"Ignoring any buffering, try to fill byteArray with the\n     contents of the file\"\n    | count |\n    self ensureReadable.\n    count := self\n\tfileOp: 3\n\twith: byteArray\n        with: 1\n\twith: byteArray size\n\tifFail: [ File checkError. ^0 ].\n\n    count = 0 ifTrue: [ atEnd := true ].\n    ^count",
                              "literals": [],
                              "methodName": "read:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "open:mode:ifFail:": {
                              "src": "open: fileName mode: fileMode ifFail: aBlock\n    \"Open fileName in the required mode - answered by #append, #create,\n     #readWrite, #read or #write - and evaluate aBlock if the file cannot\n     be opened. Else answer a new instance of the receiver. For mode\n     anyway you can use any standard C non-binary fopen mode.  fileName\n     can be a `virtual filesystem' path, including URLs and '#' suffixes\n     that are inspected by the virtual filesystem layers and replaced with\n     tasks such as un-gzipping a file or extracting a file from an\n     archive.\n\n     The file will be automatically closed upon GC if the object is not\n     referenced anymore, but it is better to close it as soon as you're\n     finished with it anyway, using #close. To keep a file open even when\n     no references exist anymore, send it #removeToBeFinalized\"\n\n    ^(VFS VFSHandler for: fileName)\n\topen: self mode: fileMode ifFail: aBlock",
                              "literals": [],
                              "methodName": "open:mode:ifFail:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextPutByte:": {
                              "src": "nextPutByte: anInteger\n    \"Store the byte, anInteger, on the file\"\n    self nextPut: anInteger asCharacter",
                              "literals": [],
                              "methodName": "nextPutByte:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "truncate": {
                              "src": "truncate\n    \"Truncate the file at the current position\"\n    self\n\tcheckIfPipe;\n\tfileOp: 10.",
                              "literals": [],
                              "methodName": "truncate",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "update:": {
                              "src": "update: aspect\n    \"Close open files before quitting\"\n    aspect == #afterEvaluation ifTrue: [\n\tstdin flush. stdout flush. stderr flush\n    ].\n    aspect == #aboutToQuit ifTrue: [\n        self allSubinstancesDo: [ :each |\n\t    each isOpen ifTrue: [ each close ]\n\t]\n    ]",
                              "literals": [],
                              "methodName": "update:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "setFD:": {
                              "src": "setFD: fd\n    access := 3.\n    file := fd.\n    name := 'descriptor #', fd printString.\n    isPipe := nil",
                              "literals": [],
                              "methodName": "setFD:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "create": {
                              "src": "create\n    \"Open for reading and writing.  The file is created if it does not exist,\n    otherwise it is truncated.  The stream is positioned at the beginning of\n    the file.\"\n\n    ^'w+'",
                              "literals": [],
                              "methodName": "create",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "next:": {
                              "src": "next: anInteger\n    \"Return the next 'anInteger' characters from the stream, as a String.\"\n    | result n |\n    result := self species new: anInteger.\n    n := self read: result.\n\n    n = 0\n\tifTrue: [ atEnd := true ].\n    ^n < anInteger\n\tifTrue: [ collection copyFrom: 1 to: n ]\n\tifFalse: [ collection ].",
                              "literals": [],
                              "methodName": "next:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "write": {
                              "src": "write\n    \"Truncate file to zero length or create text file for writing.  The stream\n    is positioned at the beginning of the file.\"\n    ^'w'",
                              "literals": [],
                              "methodName": "write",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "skip:": {
                              "src": "skip: anInteger\n    \"Skip anInteger bytes in the file\"\n    | pos |\n    pos := ((self position + anInteger) max: 0) min: self size - 1.\n    self position: pos",
                              "literals": [],
                              "methodName": "skip:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "read": {
                              "src": "read\n    \"Open text file for reading.  The stream is positioned at the beginning of\n    the file.\"\n    ^'r'",
                              "literals": [],
                              "methodName": "read",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "atEnd": {
                              "src": "atEnd\n    \"Answer whether data has come to an end\"\n    self isOpen ifFalse: [ ^true ].\n    self isPipe ifFalse: [ ^self fileOp: 6 ].\n    atEnd isNil ifTrue: [ atEnd := false ].\n    ^atEnd",
                              "literals": [],
                              "methodName": "atEnd",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "write:from:to:": {
                              "src": "write: byteArray from: position to: end\n    \"Ignoring any buffering, try to write to the file the given range\n     of byteArray, starting at index position.\"\n    self ensureWriteable.\n    ^self\n\tfileOp: 2\n\twith: byteArray\n        with: position\n\twith: (end min: byteArray size)\n\tifFail: [ File checkError. 0 ].",
                              "literals": [],
                              "methodName": "write:from:to:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "isBinary": {
                              "src": "isBinary\n    \"We answer characters, so answer false\"\n    ^false",
                              "literals": [],
                              "methodName": "isBinary",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "popen:dir:": {
                              "src": "popen: commandName dir: direction\n    \"Open a pipe on the given command and fail if the file cannot be opened.\n     Else answer a new FileStream.\n     The pipe will not be automatically closed upon GC, even if the object\n     is not referenced anymore, because when you close a pipe you have to wait\n     for the associated process to terminate. To enforce automatic closing of\n     the pipe, send it #addToBeFinalized.\n     direction is returned by #read or #write ('r' or 'w') and is interpreted\n     from the point of view of Smalltalk: reading means Smalltalk reads the\n     standard output of the command, writing means Smalltalk writes the standard input of the command. The other channel\n     (stdin when reading, stdout when writing) is the same as GST's, unless\n     commandName alters it.\"\n\n    ^self basicNew\n\tfileOp: 7 with: commandName with: direction ifFail: [\n\t    SystemExceptions FileError signal: 'could not open pipe on', commandName ];\n\tinitialize;\n\tyourself",
                              "literals": [],
                              "methodName": "popen:dir:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "ensureReadable": {
                              "src": "ensureReadable\n    \"If the file is open, wait until data can be read from it.  The wait\n     allows other Processes to run.\"\n    self isPipe ifFalse: [ ^self ].\n    self isOpen ifFalse: [ ^self ].\n\n    self fileOp: 14 with: 0 with: Semaphore new.\n    self fileOp: 13 with: 0 ifFail: [ self close ].",
                              "literals": [],
                              "methodName": "ensureReadable",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "isOpen": {
                              "src": "isOpen \n    \"Answer whether the file is still open\"\n    ^file isInteger and: [ file positive ]",
                              "literals": [],
                              "methodName": "isOpen",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "write:": {
                              "src": "write: byteArray\n    \"Ignoring any buffering, try to write the contents of byteArray in the\n     file\"\n    self ensureWriteable.\n    ^self\n\tfileOp: 2\n\twith: byteArray\n        with: 1\n\twith: byteArray size\n\tifFail: [ File checkError. 0 ].",
                              "literals": [],
                              "methodName": "write:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "size": {
                              "src": "size\n    \"Return the current size of the file, in bytes\"\n    ^self\n\tcheckIfPipe;\n\tfileOp: 9",
                              "literals": [],
                              "methodName": "size",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "printOn:": {
                              "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream\"\n    | text |\n    text := name isNil\n\tifTrue: [ 'File descriptor #', file printString ]\n\tifFalse: [ (self isPipe ifTrue: ['Pipe on '] ifFalse: ['File ']),\n\t\t   name ].\n\n    aStream\n\tnextPut: $<;\n\tnextPutAll: text;\n\tnextPut: $>",
                              "literals": [],
                              "methodName": "printOn:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "contents": {
                              "src": "contents\n    \"Answer the whole contents of the file\"\n    | contents ch |\n    ^self isPipe\n\tifTrue: [\n\t    contents := WriteStream on: (self species new: 1).\n\t    [ (ch := self next) isNil ]\n\t\twhileFalse: [ contents nextPut: ch ].\n\t    contents contents\n\t]\n\tifFalse: [ ^self next: self size - self position ]",
                              "literals": [],
                              "methodName": "contents",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "name": {
                              "src": "name\n    \"Return the name of the file\"\n    ^name",
                              "literals": [],
                              "methodName": "name",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "reset": {
                              "src": "reset\n    \"Reset the stream to its beginning\"\n    self\n\tcheckIfPipe;\n\tposition: 0",
                              "literals": [],
                              "methodName": "reset",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "on:": {
                              "src": "on: fd\n    \"Open a FileDescriptor on the given file descriptor.  Read-write access\n     is assumed.\"\n    ^self basicNew setFD: fd; initialize",
                              "literals": [],
                              "methodName": "on:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "position": {
                              "src": "position\n    \"Answer the zero-based position from the start of the file\"\n    ^self\n\tcheckIfPipe;\n\tfileOp: 5",
                              "literals": [],
                              "methodName": "position",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "exceptionalCondition": {
                              "src": "exceptionalCondition\n    \"Answer whether the file is open and an exceptional condition (such\n     as presence of out of band data) has occurred on it\"\n    | result |\n    self isOpen ifFalse: [ ^false ].\n    result := self fileOp: 13 with: 2 ifFail: [ self close. 1 ].\n    ^result == 1",
                              "literals": [],
                              "methodName": "exceptionalCondition",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "fd": {
                              "src": "fd\n    \"Return the OS file descriptor of the file\"\n    ^file",
                              "literals": [],
                              "methodName": "fd",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "read:from:to:": {
                              "src": "read: byteArray from: position to: end\n    \"Ignoring any buffering, try to fill the given range of byteArray\n     with the contents of the file\"\n    | count |\n    self ensureReadable.\n    count := self\n\tfileOp: 3\n\twith: byteArray\n        with: position\n\twith: (end min: byteArray size)\n\tifFail: [ File checkError. ^0 ].\n\n    count = 0 ifTrue: [ atEnd := true ].\n    ^count",
                              "literals": [],
                              "methodName": "read:from:to:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "next": {
                              "src": "next\n    \"Return the next character in the file, or nil at eof\"\n    | result | \n    result := self read: collection.\n    ^result > 0\n\tifTrue: [ collection at: 1 ]\n\tifFalse: [ atEnd := true. nil ].",
                              "literals": [],
                              "methodName": "next",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextByte": {
                              "src": "nextByte\n    \"Return the next byte in the file, or nil at eof\"\n\n    | a |\n    a := self next.\n    ^a isNil ifTrue: [ a ] ifFalse: [ a asInteger ]",
                              "literals": [],
                              "methodName": "nextByte",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "canRead": {
                              "src": "canRead\n    \"Answer whether the file is open and we can read from it\"\n    | result |\n    self isOpen ifFalse: [ ^false ].\n    result := self fileOp: 13 with: 0 ifFail: [ self close. 1 ].\n    ^result == 1",
                              "literals": [],
                              "methodName": "canRead",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "write:numBytes:": {
                              "src": "write: byteArray numBytes: anInteger\n    \"Ignoring any buffering, try to write to the file the first anInteger\n     bytes of byteArray\"\n    self ensureWriteable.\n    ^self\n\tfileOp: 2\n\twith: byteArray\n        with: 1\n\twith: (anInteger min: byteArray size)\n\tifFail: [ File checkError. 0 ].",
                              "literals": [],
                              "methodName": "write:numBytes:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextPutByteArray:": {
                              "src": "nextPutByteArray: aByteArray\n    \"Store aByteArray on the file\"\n    ^self nextPutAll: aByteArray asString",
                              "literals": [],
                              "methodName": "nextPutByteArray:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "readWrite": {
                              "src": "readWrite\n    \"Open for reading and writing.  The stream is positioned at the beginning\n     of the file.\"\n\n    ^'r+'",
                              "literals": [],
                              "methodName": "readWrite",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "fopen:mode:ifFail:": {
                              "src": "fopen: fileName mode: fileMode ifFail: aBlock\n    \"Open fileName in the required mode - answered by #append, #create,\n     #readWrite, #read or #write - and evaluate aBlock if the file cannot\n     be opened. Else answer a new FileStream. For mode anyway you can use any\n     The file will be automatically closed upon GC if the object is not\n     referenced anymore, but it is better to close it as soon as you're\n     finished with it anyway, using #close. To keep a file open even when\n     no references exist anymore, send it #removeToBeFinalized\"\n\n    ^self basicNew\n\tfileOp: 0 with: fileName with: fileMode ifFail: [ ^aBlock value ];\n\tinitialize;\n\tyourself",
                              "literals": [],
                              "methodName": "fopen:mode:ifFail:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "close": {
                              "src": "close\n    \"Close the file\"\n    self flush.\n    self fileOp: 1.\n    self removeToBeFinalized.\n    self invalidate",
                              "literals": [],
                              "methodName": "close",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "isText": {
                              "src": "isText\n    \"We answer characters, so answer true\"\n    ^true",
                              "literals": [],
                              "methodName": "isText",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "isPipe": {
                              "src": "isPipe\n    \"Answer whether the file is a pipe or an actual disk file\"\n    isPipe isNil ifTrue: [ isPipe := self fileOp: 15 ].\n    ^isPipe",
                              "literals": [],
                              "methodName": "isPipe",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "setToEnd": {
                              "src": "setToEnd\n    \"Reset the file pointer to the end of the file\"\n    self position: self size",
                              "literals": [],
                              "methodName": "setToEnd",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "open:": {
                              "src": "open: fileName\n    \"Open fileName in read-write mode - fail if the file cannot be opened.\n     Else answer a new FileStream.\n     The file will be automatically closed upon GC if the object is not\n     referenced anymore, but you should close it with #close anyway.\n     To keep a file open, send it #removeToBeFinalized\"\n    ^self open: fileName mode: FileStream readWrite",
                              "literals": [],
                              "methodName": "open:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "waitForException": {
                              "src": "waitForException\n    \"If the file is open, wait until an exceptional condition (such\n     as presence of out of band data) has occurred on it.  The wait\n     allows other Processes to run.\"\n    self isPipe ifFalse: [ ^self ].\n    self isOpen ifFalse: [ ^self ].\n\n    self fileOp: 14 with: 2 with: Semaphore new.\n    self fileOp: 13 with: 2 ifFail: [ self close ].",
                              "literals": [],
                              "methodName": "waitForException",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "read:numBytes:": {
                              "src": "read: byteArray numBytes: anInteger\n    \"Ignoring any buffering, try to fill anInteger bytes of byteArray\n     with the contents of the file\"\n    | count |\n    self ensureReadable.\n    count := self\n\tfileOp: 3\n\twith: byteArray\n        with: 1\n\twith: (anInteger min: byteArray size)\n\tifFail: [ File checkError. ^0 ].\n\n    count = 0 ifTrue: [ atEnd := true ].\n    ^count",
                              "literals": [],
                              "methodName": "read:numBytes:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "openTemporaryFile:": {
                              "src": "openTemporaryFile: baseName\n    \"Open for writing a file whose name starts with baseName, followed\n     by six random alphanumeric characters.  The file is created with mode\n     read/write and permissions 0666 or 0600 on most recent operating\n     systems (beware, the former behavior might constitute a security\n     problem).  The file is opened with the O_EXCL flag, guaranteeing that\n     when the method returns successfully we are the only user.\"\n\n    ^self basicNew\n\tfileOp: 16 with: baseName ifFail: [\n \t    SystemExceptions FileError signal: 'could not open temporary file' ];\n\tinitialize;\n\tyourself",
                              "literals": [],
                              "methodName": "openTemporaryFile:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "isEmpty": {
                              "src": "isEmpty\n    \"Answer whether the receiver is empty\"\n    ^self size == 0",
                              "literals": [],
                              "methodName": "isEmpty",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "canWrite": {
                              "src": "canWrite\n    \"Answer whether the file is open and we can write from it\"\n    | result |\n    self isOpen ifFalse: [ ^false ].\n    result := self fileOp: 13 with: 1 ifFail: [ self close. 1 ].\n    ^result == 1",
                              "literals": [],
                              "methodName": "canWrite",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "basicNextByte": {
                              "src": "basicNextByte\n    \"Private - Return the next byte in the stream, or nil at eof\"\n\n    | a |\n    a := self next.\n    ^a isNil ifTrue: [ a ] ifFalse: [ a asInteger ]",
                              "literals": [],
                              "methodName": "basicNextByte",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "basicNextPutByte:": {
                              "src": "basicNextPutByte: anInteger\n    \"Private - Store anInteger in the file\"\n\n    self nextPut: anInteger asCharacter",
                              "literals": [],
                              "methodName": "basicNextPutByte:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "invalidate": {
                              "src": "invalidate\n    \"Invalidate a file descriptor\"\n    file := nil",
                              "literals": [],
                              "methodName": "invalidate",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "isExternalStream": {
                              "src": "isExternalStream\n    \"We stream on an external entity (a file), so answer true\"\n    ^true",
                              "literals": [],
                              "methodName": "isExternalStream",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "peek": {
                              "src": "peek\n    \"Returns the next element of the stream without moving the pointer.\n    Returns nil when at end of stream.\"\n\n    | result |\n    result := self read: collection.\n    self skip: -1.\n    ^result > 0\n\tifTrue: [ collection at: 1 ]\n\tifFalse: [ atEnd := true. nil ]",
                              "literals": [],
                              "methodName": "peek",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "position:": {
                              "src": "position: n\n    \"Set the file pointer to the zero-based position n\"\n    self\n\tcheckIfPipe;\n\tfileOp: 4 with: n.",
                              "literals": [],
                              "methodName": "position:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "fopen:mode:": {
                              "src": "fopen: fileName mode: fileMode\n    \"Open fileName in the required mode - answered by #append, #create,\n     #readWrite, #read or #write - and fail if the file cannot be opened.\n     Else answer a new FileStream. For mode anyway you can use any\n     standard C non-binary fopen mode.\n     The file will be automatically closed upon GC if the object is not\n     referenced anymore, but it is better to close it as soon as you're\n     finished with it anyway, using #close. To keep a file open even when\n     no references exist anymore, send it #removeToBeFinalized\"\n\n    ^self basicNew\n\tfileOp: 0 with: fileName with: fileMode ifFail: [\n \t    SystemExceptions FileError signal: 'could not open ', fileName ];\n\tinitialize;\n\tyourself",
                              "literals": [],
                              "methodName": "fopen:mode:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "checkIfPipe": {
                              "src": "checkIfPipe\n    self isPipe ifTrue: [\n\tSystemExceptions FileError signal:\n\t    'cannot do that to a pipe or socket.' ]",
                              "literals": [],
                              "methodName": "checkIfPipe",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "finalize": {
                              "src": "finalize\n    \"Close the file if it is still open by the time the object becomes\n    garbage.\"\n    file isNil ifFalse: [ self close ].",
                              "literals": [],
                              "methodName": "finalize",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextPut:": {
                              "src": "nextPut: aCharacter\n    \"Store aCharacter on the file\"\n\n    self write: aCharacter numBytes: 1",
                              "literals": [],
                              "methodName": "nextPut:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "initialize": {
                              "src": "initialize\n    \"Initialize the receiver's instance variables\"\n    self addToBeFinalized.\n    collection := self newBuffer.\n    ptr := 1.\n    endPtr := 0.\n    access isNil ifTrue: [ access := 3 ].\n    atEnd := false.",
                              "literals": [],
                              "methodName": "initialize",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "ensureWriteable": {
                              "src": "ensureWriteable\n    \"If the file is open, wait until we can write to it.  The wait\n     allows other Processes to run.\"\n\n    \"2002-02-07 commented out the code below because not all devices\n     support sending SIGIO's when they become writeable -- notably,\n     tty's under Linux :-(\"\n\n    \"self isPipe ifFalse: [ ^self ].\n    self isOpen ifFalse: [ ^self ].\n\n    self fileOp: 14 with: 1 with: Semaphore new\"\n    self fileOp: 13 with: 1 ifFail: [ self close ].",
                              "literals": [],
                              "methodName": "ensureWriteable",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "nextHunk": {
                              "src": "nextHunk\n    \"Answer the next buffers worth of stuff in the Stream represented\n     by the receiver.  Do at most one actual input operation.\"\n\n    | answer count |\n    count := self fileOp: 3\n        with: collection\n        with: endPtr + 1\n        with: collection size - endPtr\n\tifFail: [ File checkError. 0 ].\n\n    count = 0 ifTrue: [ atEnd := true. ].\n    endPtr := endPtr + count.\n    answer := collection copyFrom: ptr to: endPtr.\n    ptr := 1.\n    endPtr := 0.\n    ^answer",
                              "literals": [],
                              "methodName": "nextHunk",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "append": {
                              "src": "append\n    \"Open for writing.  The file is created if it does not exist.  The stream\n     is positioned at the end of the file.\"\n\n    ^'a'",
                              "literals": [],
                              "methodName": "append",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            },
                            "open:mode:": {
                              "src": "open: fileName mode: fileMode\n    \"Open fileName in the required mode - answered by #append, #create,\n     #readWrite, #read or #write - and fail if the file cannot be opened.\n     Else answer a new FileStream. For mode anyway you can use any\n     standard C non-binary fopen mode.  fileName can be a `virtual\n     filesystem' path, including URLs and '#' suffixes that are\n     inspected by the virtual filesystem layers and replaced with\n     tasks such as un-gzipping a file or extracting a file from an\n     archive.\n\n     The file will be automatically closed upon GC if the object is not\n     referenced anymore, but it is better to close it as soon as you're\n     finished with it anyway, using #close. To keep a file open even when\n     no references exist anymore, send it #removeToBeFinalized\"\n\n    ^(VFS VFSHandler for: fileName)\n\topen: self mode: fileMode ifFail: [\n \t    SystemExceptions FileError signal: 'could not open ', fileName ]",
                              "literals": [],
                              "methodName": "open:mode:",
                              "className": "FileDescriptor",
                              "category": "<unknown>",
                              "byteCodes": []
                            }
                          },
                          "class_methods": {},
                          "subclasses": [
                            {
                              "className": "FileStream",
                              "instance_methods": {
                                "next": {
                                  "src": "next\n    \"Return the next character in the file, or nil at eof\"\n\n    | element |\n    (access bitAnd: 1) = 0\n    \tifTrue: [ ^self shouldNotImplement ].\n\n    self pendingWrite ifTrue: [ self basicFlush ].\n    self basicAtEnd ifTrue: [\n\tself fill.\n\tself atEnd ifTrue: [ ^nil ].\n    ].\n    element := collection at: ptr.\n    ptr := ptr + 1.\n    ^element",
                                  "literals": [],
                                  "methodName": "next",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "pendingWrite": {
                                  "src": "pendingWrite\n    \"Answer whether the output buffer is full\"\n    ^writePtr notNil",
                                  "literals": [],
                                  "methodName": "pendingWrite",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "stdin": {
                                  "src": "stdin\n    \"Answer a FileStream that is attached the Smalltalk program's standard\n     input file handle, which is the normal source of input for the program.\"\n    ^stdin",
                                  "literals": [],
                                  "methodName": "stdin",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextPutAll:": {
                                  "src": "nextPutAll: aCollection\n    \"Put all the characters in aCollection in the file\"\n    | n storedCollection |\n    writePtr isNil\n        ifTrue: [ writePtr := ptr. writeEnd := ptr - 1 ].\n\n    storedCollection := aCollection asString.\n    n := storedCollection size.\n    writeEnd + n > collection size ifFalse: [\n        collection\n            replaceFrom: writeEnd + 1\n            to: writeEnd + n\n            with: storedCollection\n            startingAt: 1.\n\n\twriteEnd := writeEnd + n.\n\tptr := writeEnd + 1.\n        ^self\n    ].\n\n    self basicFlush.\n    self write: storedCollection.",
                                  "literals": [],
                                  "methodName": "nextPutAll:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "bufferSize:": {
                                  "src": "bufferSize: bufSize\n    \"Flush the file and set the buffer's size to bufSize\"\n    self flush.\n    collection := self species new: bufSize",
                                  "literals": [],
                                  "methodName": "bufferSize:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "stdout": {
                                  "src": "stdout\n    \"Answer a FileStream that is attached the Smalltalk program's standard\n     output file handle; this is used for normal output from the program.\"\n    ^stdout",
                                  "literals": [],
                                  "methodName": "stdout",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "newBuffer": {
                                  "src": "newBuffer\n    \"Private - Answer a String to be used as the receiver's buffer\"\n    ^String new: 1024",
                                  "literals": [],
                                  "methodName": "newBuffer",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextByte": {
                                  "src": "nextByte\n    \"Return the next byte in the file, or nil at eof\"\n\n    | a |\n    a := self next.\n    ^a isNil ifTrue: [ a ] ifFalse: [ a asInteger ]",
                                  "literals": [],
                                  "methodName": "nextByte",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "recursiveGenerateOnto:with:": {
                                  "src": "recursiveGenerateOnto: aStream with: includeCollection\n    \"Private - Generate a make file for the file in information in\n     includeCollection. Store it on aStream\"\n\n    includeCollection isNil ifTrue: [ ^self ].\n    includeCollection do: [ :include |\n\tinclude value size > 0 ifTrue: [\n\t    aStream\n\t\tnextPutAll: include key;\n\t\tnextPutAll: ': '.\n\t\n\t    include value do: [ :subinclude |\n\t\taStream nextPutAll: subinclude key; space\n\t    ].\n\t    aStream nl; nl.\n\t    self recursiveGenerateOnto: aStream with: include value\n\t]\n    ]",
                                  "literals": [],
                                  "methodName": "recursiveGenerateOnto:with:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fileIn": {
                                  "src": "fileIn\n    \"File in the contents of the receiver.\n     During a file in operation, global variables (starting with an\n     uppercase letter) that are not declared don't yield an `unknown\n     variable' error. Instead, they are defined as nil in the `Undeclared'\n     dictionary (a global variable residing in Smalltalk).\n     As soon as you add the variable to a namespace (for example by creating\n     a class) the Association will be removed from Undeclared and reused\n     in the namespace, so that the old references will automagically point\n     to the new value.\"\n\n    self clean.\n    self fileOp: 11 ifFail: [\n        file isNil ifTrue: [ SystemExceptions FileError signal: 'file already closed' ].\n        File checkError.\n        ^nil\n    ]",
                                  "literals": [],
                                  "methodName": "fileIn",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fileInLine:fileName:at:": {
                                  "src": "fileInLine: lineNum fileName: aString at: charPosInt\n    \"Private - Much like a preprocessor #line directive; it is used\n     by the Emacs Smalltalk mode.\"\n\n    self clean.\n    self fileOp: 12 with: lineNum with: aString with: charPosInt ifFail: [\n        file isNil ifTrue: [ SystemExceptions FileError signal: 'file already closed' ].\n        File checkError.\n        ^nil\n    ]",
                                  "literals": [],
                                  "methodName": "fileInLine:fileName:at:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextByteArray:": {
                                  "src": "nextByteArray: anInteger\n    \"Return the next 'anInteger' bytes from the stream, as a ByteArray.\"\n    | answer from n |\n    self pendingWrite ifTrue: [ self basicFlush ].\n\n    n := anInteger.\n    answer := ByteArray new: n.\n    from := 1.\n    [ (ptr + n - 1) > endPtr ] whileFalse: [\n        answer\n            replaceFrom: from\n            to: from + (endPtr - ptr)\n            with: collection\n            startingAt: ptr.\n\n        from := from + endPtr - ptr - 1.\n\tn := n - ptr + endPtr - 1.\n        self fill.\n    ].\n    answer\n        replaceFrom: from\n        to: answer size\n        with: collection\n        startingAt: ptr.\n\n    ^answer",
                                  "literals": [],
                                  "methodName": "nextByteArray:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "record:": {
                                  "src": "record: recordFlag\n    \"Set whether Smalltalk should record information aboutnested file-ins.\n     When recording is enabled, use #generateMakefileOnto: to automatically\n     generate a valid makefile for the intervening file-ins.\"\n    | oldRecord |\n    oldRecord := Record.\n    Record := recordFlag.\n    Includes := Record \n\tifTrue: [ OrderedCollection new ]\n\tifFalse: [ nil ].\n    ^oldRecord",
                                  "literals": [],
                                  "methodName": "record:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "generateMakefileOnto:": {
                                  "src": "generateMakefileOnto: aStream\n    \"Generate a make file for the file-ins since record was last set to true.\n     Store it on aStream\"\n    aStream nextPutAll: \n'\n#\n# Automatically generated Smalltalk dependencies\n#\n\n'.\n    self recursiveGenerateOnto: aStream with: Includes.\n    aStream nextPutAll: \n'#\n# End automatically generated Smalltalk dependencies\n#\n\n'.",
                                  "literals": [],
                                  "methodName": "generateMakefileOnto:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fileIn:ifMissing:": {
                                  "src": "fileIn: aFileName ifMissing: aSymbol\n    \"Conditionally do a file in, only if the key (often a class) specified\n     by 'aSymbol' is not present in the Smalltalk system dictionary already.\n     During a file in operation, global variables (starting with an\n     uppercase letter) that are not declared don't yield an `unknown\n     variable' error. Instead, they are defined as nil in the `Undeclared'\n     dictionary (a global variable residing in Smalltalk).\n     As soon as you add the variable to a namespace (for example by creating\n     a class) the Association will be removed from Undeclared and reused\n     in the namespace, so that the old references will automagically point\n     to the new value.\"\n\n    Smalltalk at: aSymbol\n\t      ifAbsent: [ self fileIn: aFileName ]",
                                  "literals": [],
                                  "methodName": "fileIn:ifMissing:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fileIn:": {
                                  "src": "fileIn: aFileName\n    \"File in the aFileName file. During a file in operation, global variables\n     (starting with an uppercase letter) that are not declared yet don't yield\n     an `unknown variable' error. Instead, they are defined as nil in the\n     `Undeclared' dictionary (a global variable residing in Smalltalk).\n     As soon as you add the variable to a namespace (for example by creating\n     a class) the Association will be removed from Undeclared and reused\n     in the namespace, so that the old references will automagically point\n     to the new value.\"\n\n    | oldIncludes newCollection file |\n    Verbose ifTrue: [ Transcript nextPutAll: 'Loading ', aFileName; nl ].\n\n    Record ifTrue: [\n\tnewCollection := OrderedCollection new.\n\tIncludes add: aFileName -> newCollection.\n\toldIncludes := Includes.\n\tIncludes := newCollection\n    ].\n\n    (self open: aFileName mode: FileStream read)\n\tfileIn;\n\tclose.\n\n    Record ifTrue: [ Includes := oldIncludes ].",
                                  "literals": [],
                                  "methodName": "fileIn:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fileIn:line:from:at:": {
                                  "src": "fileIn: aFileName line: lineInteger from: realFileName at: aCharPos\n    \"File in the aFileName file giving errors such as if it was loaded\n     from the given line, file name and starting position (instead of 1).\"\n\n    (self open: aFileName mode: FileStream read)\n\tfileInLine: lineInteger fileName: realFileName at: aCharPos;\n\tclose.",
                                  "literals": [],
                                  "methodName": "fileIn:line:from:at:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "copyFrom:to:": {
                                  "src": "copyFrom: from to: to\n    \"Answer the contents of the file between the two given positions\"\n    | offset fromPos toPos savePos |\n    from > to ifTrue: [\n        from = to + 1 ifTrue: [ ^self species new ].\n        ^SystemExceptions ArgumentOutOfRange signalOn: from mustBeBetween: 1 and: to + 1\n    ].\n\n    savePos := self fileOp: 5.\n    offset := savePos - endPtr + 1.\n    fromPos := from - offset.\n    toPos := to - offset.\n\n    (fromPos >= 1 and: [ toPos <= collection size ])\n        ifTrue: [ ^collection copyFrom: fromPos to: toPos ].\n\n    ^[\n        self position: fromPos.\n        self next: toPos - fromPos + 1\n    ] ensure: [\n        self position: savePos\n    ]",
                                  "literals": [],
                                  "methodName": "copyFrom:to:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextPutByte:": {
                                  "src": "nextPutByte: anInteger\n    \"Store the byte, anInteger, on the file\"\n    self nextPut: anInteger asCharacter",
                                  "literals": [],
                                  "methodName": "nextPutByte:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "truncate": {
                                  "src": "truncate\n    \"Truncate the file at the current position\"\n    self pendingWrite ifTrue: [ self basicFlush ].\n    super truncate",
                                  "literals": [],
                                  "methodName": "truncate",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "flush": {
                                  "src": "flush\n    \"Flush the output buffer\"\n    self pendingWrite ifTrue: [ self basicFlush ].",
                                  "literals": [],
                                  "methodName": "flush",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextPutByteArray:": {
                                  "src": "nextPutByteArray: aByteArray\n    \"Store aByteArray on the file\"\n    ^self nextPutAll: aByteArray asString",
                                  "literals": [],
                                  "methodName": "nextPutByteArray:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "next:": {
                                  "src": "next: anInteger\n    \"Return the next 'anInteger' characters from the stream, as a String.\"\n    | answer from n |\n    self pendingWrite ifTrue: [ self basicFlush ].\n\n    n := anInteger.\n    answer := self species new: n.\n    from := 1.\n    [ (ptr + n - 1) > endPtr ] whileTrue: [\n        answer\n            replaceFrom: from\n            to: from + (endPtr - ptr)\n            with: collection\n            startingAt: ptr.\n\n        from := from + (endPtr - ptr + 1).\n\tn := n - (endPtr - ptr + 1).\n        self fill.\n    ].\n    answer\n        replaceFrom: from\n        to: answer size\n        with: collection\n        startingAt: ptr.\n\n    ptr := ptr + (answer size - from + 1).\n    ^answer",
                                  "literals": [],
                                  "methodName": "next:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fileIn:ifTrue:": {
                                  "src": "fileIn: aFileName ifTrue: aBoolean\n    \"Conditionally do a file in, only if the supplied boolean is true.\n     During a file in operation, global variables (starting with an\n     uppercase letter) that are not declared don't yield an `unknown\n     variable' error. Instead, they are defined as nil in the `Undeclared'\n     dictionary (a global variable residing in Smalltalk).\n     As soon as you add the variable to a namespace (for example by creating\n     a class) the Association will be removed from Undeclared and reused\n     in the namespace, so that the old references will automagically point\n     to the new value.\"\n\t\t\t\t\t\t\t       \n    aBoolean \n\tifTrue: [ self fileIn: aFileName ]",
                                  "literals": [],
                                  "methodName": "fileIn:ifTrue:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "require:": {
                                  "src": "require: assoc\n    \"Conditionally do a file in from the value of assoc, only if the\n     key of assoc is not present in the Smalltalk system dictionary already.\n     During a file in operation, global variables (starting with an\n     uppercase letter) that are not declared don't yield an `unknown\n     variable' error. Instead, they are defined as nil in the `Undeclared'\n     dictionary (a global variable residing in Smalltalk).\n     As soon as you add the variable to a namespace (for example by creating\n     a class) the Association will be removed from Undeclared and reused\n     in the namespace, so that the old references will automagically point\n     to the new value.\"\n    Smalltalk at: assoc key\n\t      ifAbsent: [ self fileIn: assoc value ]",
                                  "literals": [],
                                  "methodName": "require:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "atEnd": {
                                  "src": "atEnd\n    \"Answer whether data has come to an end\"\n    ^self basicAtEnd and: [ super atEnd ]",
                                  "literals": [],
                                  "methodName": "atEnd",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "basicFlush": {
                                  "src": "basicFlush\n    \"Private - Flush the output buffer, fail if it is empty\"\n    | move |\n    move := 8.\n\n    endPtr + 1 = writePtr ifFalse: [\n\tself fileOp: move with: writePtr - endPtr - 1\n    ].\n    self write: collection from: writePtr to: writeEnd.\n    writeEnd + 1 = ptr ifFalse: [\n\tself fileOp: move with: ptr - writeEnd - 1.\n    ].\n\n    writePtr := nil.\n    ptr := 1.\n    endPtr := 0.",
                                  "literals": [],
                                  "methodName": "basicFlush",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "stderr": {
                                  "src": "stderr\n    \"Answer a FileStream that is attached the Smalltalk program's standard\n     error file handle, which can be used for error messages and diagnostics\n     issued by the program.\"\n    ^stderr",
                                  "literals": [],
                                  "methodName": "stderr",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "clean": {
                                  "src": "clean\n    \"Synchronize the file descriptor's state with the object's state.\"\n    self pendingWrite ifTrue: [ self basicFlush ].\n    self position: self position.",
                                  "literals": [],
                                  "methodName": "clean",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "fill": {
                                  "src": "fill\n    \"Private - Fill the input buffer\"\n    ptr := 1.\n    endPtr := self read: collection.",
                                  "literals": [],
                                  "methodName": "fill",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "peek": {
                                  "src": "peek\n    \"Return the next character in the file, or nil at eof\"\n\n    | element |\n    (access bitAnd: 1) = 0\n    \tifTrue: [ ^self shouldNotImplement ].\n\n    self pendingWrite ifTrue: [ self basicFlush ].\n    self basicAtEnd ifTrue: [\n\tself fill.\n\tself atEnd ifTrue: [ ^nil ].\n    ].\n    element := collection at: ptr.\n    ^element",
                                  "literals": [],
                                  "methodName": "peek",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "position:": {
                                  "src": "position: n\n    \"Set the file pointer to the zero-based position n\"\n    self pendingWrite ifTrue: [ self basicFlush ].\n    ptr := 1.\n    endPtr := 0.\n    super position: n.",
                                  "literals": [],
                                  "methodName": "position:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "size": {
                                  "src": "size\n    \"Return the current size of the file, in bytes\"\n    self pendingWrite ifTrue: [ self basicFlush ].\n    ^super size",
                                  "literals": [],
                                  "methodName": "size",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "verbose:": {
                                  "src": "verbose: verboseFlag\n    \"Set whether Smalltalk should output debugging messages when filing in\"\n    | oldVerbose |\n    oldVerbose := Verbose.\n    Verbose := verboseFlag.\n    ^oldVerbose",
                                  "literals": [],
                                  "methodName": "verbose:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextPut:": {
                                  "src": "nextPut: aCharacter\n    \"Store aCharacter on the file\"\n\n    (access bitAnd: 2) = 0\n    \tifTrue: [ ^self shouldNotImplement ].\n\n    ptr > collection size ifTrue: [ self flush ].\n\n    writePtr isNil\n        ifTrue: [ writePtr := writeEnd := ptr ]\n        ifFalse: [ writeEnd := writeEnd + 1 ].\n\n    collection at: ptr put: aCharacter.\n    ptr := ptr + 1.",
                                  "literals": [],
                                  "methodName": "nextPut:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "initialize": {
                                  "src": "initialize\n    \"Private - Initialize the receiver's class variables\"\n    Record := Verbose := false.",
                                  "literals": [],
                                  "methodName": "initialize",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "position": {
                                  "src": "position\n    \"Answer the zero-based position from the start of the file\"\n    ^super position + (ptr - 1) - endPtr",
                                  "literals": [],
                                  "methodName": "position",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextPutAllFlush:": {
                                  "src": "nextPutAllFlush: aCollection\n    \"Put all the characters in aCollection in the file, then flush the\n     file buffers\"\n    | n storedCollection |\n    self pendingWrite ifTrue: [ self basicFlush ].\n\n    storedCollection := aCollection asString.\n    self write: storedCollection.\n    ptr := 1.\n    endPtr := 0.",
                                  "literals": [],
                                  "methodName": "nextPutAllFlush:",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "nextHunk": {
                                  "src": "nextHunk\n    \"Answer the next buffers worth of stuff in the Stream represented\n     by the receiver.  Do at most one actual input operation.\"\n\n    | answer |\n    endPtr := endPtr + (self fileOp: 3\n        with: collection\n        with: endPtr + 1\n        with: collection size - endPtr\n\tifFail: [ File checkError. 0 ]).\n\n    answer := collection copyFrom: ptr to: endPtr.\n    ptr := 1.\n    endPtr := 0.\n    ^answer",
                                  "literals": [],
                                  "methodName": "nextHunk",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                },
                                "bufferSize": {
                                  "src": "bufferSize\n    \"Answer the file's current buffer\"\n    ^collection size",
                                  "literals": [],
                                  "methodName": "bufferSize",
                                  "className": "FileStream",
                                  "category": "<unknown>",
                                  "byteCodes": []
                                }
                              },
                              "class_methods": {},
                              "subclasses": []
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "className": "Random",
          "instance_methods": {
            "next": {
              "src": "next\n    \"Return the next random number in the sequence.\"\n    \"Found on an obscure Japanese manual. Turns out to be good!\"\n    ^seed := (seed + Float pi) squared squared fractionPart",
              "literals": [],
              "methodName": "next",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "new": {
              "src": "new\n    \"Create a new random number generator whose seed is given by the\n    current time on the millisecond clock\"\n    ^self basicNew setSeed",
              "literals": [],
              "methodName": "new",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "chiSquare": {
              "src": "chiSquare\n    \"Compute the chi-square of the random that this class generates.\"\n\n    \"the previous algorithm's chi-square was 93.4\"\n    ^self chiSquare: 1000 range: 100",
              "literals": [],
              "methodName": "chiSquare",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "atEnd": {
              "src": "atEnd\n    \"This stream never ends. Always answer false.\"\n    ^false",
              "literals": [],
              "methodName": "atEnd",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "between:and:": {
              "src": "between: low and: high\n    \"Return a random integer between low and high.\"\n    | i range |\n\n    range := high - low + 1.\n    i := (self next * range) truncated.\n    ^i + low",
              "literals": [],
              "methodName": "between:and:",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "chiSquare:range:": {
              "src": "chiSquare: n range: r\n    \"Return the chi-square deduced from calculating n random\n     numbers in the 0..r range.\"\n\n    | f t seed |\n    seed := 1234567.\n    f := Array new: r + 1.\n    1 to: r + 1 do: [ :i | f at: i put: 0 ].\n    n timesRepeat: [\n\tseed := (seed + Float pi) squared squared fractionPart.\n\tt := (seed * r) truncated.\n\tf at: t + 1 put: (f at: t + 1) + 1\n    ].\n    t := 0.\n    1 to: r do: [ :i | t := t + (f at: i) squared ].\n    ^r asFloat * t / n - n",
              "literals": [],
              "methodName": "chiSquare:range:",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "seed:": {
              "src": "seed: aFloat\n    \"Private - Set the random number seed to aFloat.\n    Ensure decent results even when integers are passed\"\n    seed := (aFloat / 100000.0 + aFloat) fractionPart.\n    self next.\n    self next",
              "literals": [],
              "methodName": "seed:",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "nextPut:": {
              "src": "nextPut: value\n    self shouldNotImplement",
              "literals": [],
              "methodName": "nextPut:",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            },
            "setSeed": {
              "src": "setSeed\n    \"Private - Set a random number seed.\"\n    seed := Time primSecondClock - Time primMillisecondClock.\n    seed := (seed / 16r3FFFFF.0) fractionPart.\n    self next.\n    self next",
              "literals": [],
              "methodName": "setSeed",
              "className": "Random",
              "category": "private",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "TextCollector",
          "instance_methods": {
            "new": {
              "src": "new\n    self shouldNotImplement",
              "literals": [],
              "methodName": "new",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "nextPutAll:": {
              "src": "nextPutAll: aString\n    \"Write aString to the Transcript\"\n    semaphore critical: [\n\tself primNextPutAll: aString.\n\tProcessor idle\n    ]",
              "literals": [],
              "methodName": "nextPutAll:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "storeOn:": {
              "src": "storeOn: aStream\n    \"Print Smalltalk code which evaluates to the receiver onto aStream\"\n    self == Transcript\n\tifTrue: [ aStream nextPutAll: 'Transcript' ]\n\tifFalse: [ super storeOn: aStream ]",
              "literals": [],
              "methodName": "storeOn:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "message:": {
              "src": "message: receiverToSelectorAssociation\n    \"Set the message to be sent to perform write operations\n     to the one represented by anAssociation.  anAssociation's key is the\n     receiver, while its value is the selector\"\n    receiver := receiverToSelectorAssociation key.\n    selector := receiverToSelectorAssociation value",
              "literals": [],
              "methodName": "message:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "showOnNewLine:": {
              "src": "showOnNewLine: aString\n    \"Write aString to the Transcript, preceded by a new-line character\"\n    semaphore critical: [\n\tself primNextPutAll: Character nl asString.\n\tself primNextPutAll: aString.\n\tProcessor idle\n    ]",
              "literals": [],
              "methodName": "showOnNewLine:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "message": {
              "src": "message\n    \"Answer an association representing the message to be sent\n    to perform write operations.  The key is the receiver, the value is the\n    selector\"\n    ^receiver -> selector",
              "literals": [],
              "methodName": "message",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "primNextPutAll:": {
              "src": "primNextPutAll: aString\n    \"Private - Forward the writing request to the actual object\"\n    receiver perform: selector with: aString",
              "literals": [],
              "methodName": "primNextPutAll:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "store:": {
              "src": "store: anObject\n    \"Print Smalltalk code which evaluates to anObject on the Transcript\"\n    semaphore critical: [\n\tself primNextPutAll: anObject storeString.\n\tProcessor idle\n    ]",
              "literals": [],
              "methodName": "store:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "cr": {
              "src": "cr\n    \"Emit a new-line (carriage return) to the Transcript\"\n    self nl",
              "literals": [],
              "methodName": "cr",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "next:put:": {
              "src": "next: anInteger put: anObject\n    \"Write anInteger copies of anObject to the Transcript\"\n    self nextPutAll: (String new: anInteger withAll: anObject)",
              "literals": [],
              "methodName": "next:put:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "printOn:": {
              "src": "printOn: aStream\n    \"Print a representation of the receiver onto aStream\"\n    self == Transcript\n\tifTrue: [ aStream nextPutAll: 'Transcript' ]\n\tifFalse: [ super printOn: aStream ]",
              "literals": [],
              "methodName": "printOn:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "show:": {
              "src": "show: aString\n    \"Write aString to the Transcript\"\n    semaphore critical: [\n\tself primNextPutAll: aString.\n\tProcessor idle\n    ]",
              "literals": [],
              "methodName": "show:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "showCr:": {
              "src": "showCr: aString\n    \"Write aString to the Transcript, followed by a new-line character\"\n    semaphore critical: [\n\tself primNextPutAll: aString.\n\tself primNextPutAll: Character nl asString.\n\tProcessor idle\n    ]",
              "literals": [],
              "methodName": "showCr:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "nextPut:": {
              "src": "nextPut: aCharacter\n    \"Emit aCharacter to the Transcript\"\n    self nextPutAll: (String with: aCharacter)",
              "literals": [],
              "methodName": "nextPut:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "print:": {
              "src": "print: anObject\n    \"Print anObject's representation to the Transcript\"\n    semaphore critical: [\n\tself primNextPutAll: anObject printString.\n\tProcessor idle\n    ]",
              "literals": [],
              "methodName": "print:",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "initialize": {
              "src": "initialize\n    \"Private - Initialize the receiver's instance variables\"\n    semaphore := Semaphore forMutualExclusion",
              "literals": [],
              "methodName": "initialize",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            },
            "endEntry": {
              "src": "endEntry\n    \"Emit two new-lines.  This method is present for compatibility with\n    VisualWorks.\"\n    self nl; nl",
              "literals": [],
              "methodName": "endEntry",
              "className": "TextCollector",
              "category": "<unknown>",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        },
        {
          "className": "TokenStream",
          "instance_methods": {
            "next": {
              "src": "next\n    \"Answer a new whitespace-separated token from the input stream\"\n    | char tokStream |\n    self atEnd ifTrue: [ ^nil ]. \"has the nice side effect of skipping\n    \t    \t    \t    \t  leading white space.\"\n    tokStream := WriteStream on: (String new: 1).\n    [ char := charStream peek.\n      (char notNil) and: [ (char isSeparator) not ] ]\n\twhileTrue: [ tokStream nextPut: (charStream next) ].\n    ^tokStream contents",
              "literals": [],
              "methodName": "next",
              "className": "TokenStream",
              "category": "private",
              "byteCodes": []
            },
            "onStream:": {
              "src": "onStream: aStream\n    \"Answer a TokenStream working on the collection on which aStream\n    is in turn streaming.\"\n    ^self new setStream: aStream",
              "literals": [],
              "methodName": "onStream:",
              "className": "TokenStream",
              "category": "private",
              "byteCodes": []
            },
            "atEnd": {
              "src": "atEnd\n    \"Answer whether the input stream has no more tokens.\"\n    | char |\n    [ char := charStream peek.\n      char isNil ] whileFalse:\n    \t[ (char isSeparator) ifFalse: [ ^false ].\n\t charStream next ].\n    ^true",
              "literals": [],
              "methodName": "atEnd",
              "className": "TokenStream",
              "category": "private",
              "byteCodes": []
            },
            "on:": {
              "src": "on: aString\n    \"Answer a TokenStream working on aString\"\n    ^self onStream: (ReadStream on: aString)",
              "literals": [],
              "methodName": "on:",
              "className": "TokenStream",
              "category": "private",
              "byteCodes": []
            },
            "nextPut:": {
              "src": "nextPut: anObject\n    self shouldNotImplement",
              "literals": [],
              "methodName": "nextPut:",
              "className": "TokenStream",
              "category": "private",
              "byteCodes": []
            },
            "setStream:": {
              "src": "setStream: aStream\n    charStream := aStream.",
              "literals": [],
              "methodName": "setStream:",
              "className": "TokenStream",
              "category": "private",
              "byteCodes": []
            }
          },
          "class_methods": {},
          "subclasses": []
        }
      ]
    },
    {
      "className": "UndefinedObject",
      "instance_methods": {
        "storeOn:": {
          "src": "storeOn: aStream\n    \"Store Smalltalk code compiling to the receiver on aStream.\"\n    self printOn: aStream",
          "literals": [],
          "methodName": "storeOn:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "release": {
          "src": "release\n\t\"Nil release is a no-op\"",
          "literals": [],
          "methodName": "release",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "mutate:startAt:newClass:": {
          "src": "mutate: instVarMap startAt: start newClass: class\n    \"Private - Do nothing, this is here in case the WeakArray garbage\n     collects an object that is to be mutated.\"",
          "literals": [],
          "methodName": "mutate:startAt:newClass:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "subclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "subclass: classNameString classInstanceVariableNames: stringClassInstVarNames instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tsubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
          "literals": [],
          "methodName": "subclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableByteSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "variableByteSubclass: classNameString classInstanceVariableNames: stringClassInstVarNames instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tvariableByteSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
          "literals": [],
          "methodName": "variableByteSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "variableSubclass: classNameString instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tvariableSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
          "literals": [],
          "methodName": "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
          "src": "variableWordSubclass: classNameString\n  instanceVariableNames: stringInstVarNames\n  classVariableNames: stringOfClassVarNames\n  poolDictionaries: stringOfPoolNames\n  category: categoryNameString\n    \"Define a word variable subclass of the receiver with the given\n     name, instance variables, class variables, pool dictionaries and\n     category. If the class is already defined, if necessary, recompile\n     everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t    environment: Namespace current\n\t    subclassOf: self\n\t    instanceVariableNames: stringInstVarNames\n\t    variable: true\n\t    words: true\n\t    pointers: false\n\t    classVariableNames: stringOfClassVarNames\n\t    poolDictionaries: stringOfPoolNames\n\t    category: categoryNameString",
          "literals": [],
          "methodName": "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "copy": {
          "src": "copy\n    ^self",
          "literals": [],
          "methodName": "copy",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "variableSubclass: classNameString classInstanceVariableNames: stringClassInstVarNames instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tvariableSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
          "literals": [],
          "methodName": "variableSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "shallowCopy": {
          "src": "shallowCopy\n    ^self",
          "literals": [],
          "methodName": "shallowCopy",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "ifNotNil:ifNil:": {
          "src": "ifNotNil: notNilBlock ifNil: nilBlock\n    \"Evaluate nilBlock if the receiver is nil, else evaluate\n     notNilBlock, passing the receiver.\"\n    ^nilBlock value",
          "literals": [],
          "methodName": "ifNotNil:ifNil:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "removeSubclass:": {
          "src": "removeSubclass: aClass\n\t\"Ignored -- necessary to support disjoint class hierarchies\"",
          "literals": [],
          "methodName": "removeSubclass:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
          "src": "variableByteSubclass: classNameString\n  instanceVariableNames: stringInstVarNames\n  classVariableNames: stringOfClassVarNames\n  poolDictionaries: stringOfPoolNames\n  category: categoryNameString\n    \"Define a byte variable subclass of the receiver with the given\n     name, instance variables, class variables, pool dictionaries\n     and category. If the class is already defined, if necessary,\n     recompile everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t    environment: Namespace current\n\t    subclassOf: self\n\t    instanceVariableNames: stringInstVarNames\n\t    variable: true\n\t    words: false\n\t    pointers: false\n\t    classVariableNames: stringOfClassVarNames\n\t    poolDictionaries: stringOfPoolNames\n\t    category: categoryNameString",
          "literals": [],
          "methodName": "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "ifNil:": {
          "src": "ifNil: nilBlock\n    \"Evaluate nilBlock if the receiver is nil, else answer nil\"\n    ^nilBlock value",
          "literals": [],
          "methodName": "ifNil:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "variableByteSubclass: classNameString instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tvariableByteSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
          "literals": [],
          "methodName": "variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "subclass:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "subclass: classNameString instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tsubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
          "literals": [],
          "methodName": "subclass:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "variableWordSubclass: classNameString instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^self\n\tvariableWordSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category'",
          "literals": [],
          "methodName": "variableWordSubclass:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "deepCopy": {
          "src": "deepCopy\n    ^self",
          "literals": [],
          "methodName": "deepCopy",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Print a representation of the receiver on aStream.\"\n    aStream nextPutAll: 'nil'",
          "literals": [],
          "methodName": "printOn:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "notNil": {
          "src": "notNil\n    \"Answer whether the receiver is not the undefined object nil. Always\n     answer false.\"\n    ^false",
          "literals": [],
          "methodName": "notNil",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
          "src": "subclass: classNameString\n    instanceVariableNames: stringInstVarNames\n    classVariableNames: stringOfClassVarNames\n    poolDictionaries: stringOfPoolNames\n    category: categoryNameString\n    \"Define a fixed subclass of the receiver with the given name, instance\n     variables, class variables, pool dictionaries and category. If the\n     class is already defined, if necessary, recompile everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t  environment: Namespace current\n\t  subclassOf: self\n\t  instanceVariableNames: stringInstVarNames\n\t  variable: false\n\t  words: false\n\t  pointers: true\n\t  classVariableNames: stringOfClassVarNames\n\t  poolDictionaries: stringOfPoolNames\n\t  category: categoryNameString",
          "literals": [],
          "methodName": "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "ifNil:ifNotNil:": {
          "src": "ifNil: nilBlock ifNotNil: notNilBlock\n    \"Evaluate nilBlock if the receiver is nil, else evaluate\n     notNilBlock, passing the receiver.\"\n    ^nilBlock value",
          "literals": [],
          "methodName": "ifNil:ifNotNil:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "addDependent:": {
          "src": "addDependent: ignored \n\t\"Refer to the comment in Object|dependents.\"\n\n\tself shouldNotImplement",
          "literals": [],
          "methodName": "addDependent:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:": {
          "src": "variableSubclass: classNameString\n    instanceVariableNames: stringInstVarNames\n    classVariableNames: stringOfClassVarNames\n    poolDictionaries: stringOfPoolNames\n    category: categoryNameString\n    \"Define a variable pointer subclass of the receiver with the given\n     name, instance variables, class variables, pool dictionaries and\n     category. If the class is already defined, if necessary, recompile\n     everything needed.\"\n\n    | meta |\n    KernelInitialized ifFalse: [\n\t^(Smalltalk at: classNameString) category: categoryNameString\n    ].\n\n    meta := self metaclassFor: classNameString.\n    ^meta name: classNameString\n\t  environment: Namespace current\n\t  subclassOf: self\n\t  instanceVariableNames: stringInstVarNames\n\t  variable: true\n\t  words: false\n\t  pointers: true\n\t  classVariableNames: stringOfClassVarNames\n\t  poolDictionaries: stringOfPoolNames\n\t    category: categoryNameString",
          "literals": [],
          "methodName": "variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "ifNotNil:": {
          "src": "ifNotNil: notNilBlock\n    \"Evaluate notNilBlock if the receiver is not nil, passing the receiver.\n     Else answer nil\"\n    ^nil",
          "literals": [],
          "methodName": "ifNotNil:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "variableWordSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:": {
          "src": "variableWordSubclass: classNameString classInstanceVariableNames: stringClassInstVarNames instanceVariableNames: stringInstVarNames classVariableNames: stringOfClassVarNames poolDictionaries: stringOfPoolNames\n    \"Don't use this, it is only present to file in from IBM Smalltalk\"\n    ^(self\n\tvariableWordSubclass: classNameString\n\tinstanceVariableNames: stringInstVarNames\n\tclassVariableNames: stringOfClassVarNames\n\tpoolDictionaries: stringOfPoolNames\n\tcategory: 'no category')\n\tclassInstanceVariableNames: stringClassInstVarNames;\n\tyourself",
          "literals": [],
          "methodName": "variableWordSubclass:classInstanceVariableNames:instanceVariableNames:classVariableNames:poolDictionaries:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        },
        "metaclassFor:": {
          "src": "metaclassFor: classNameString\n    \"Create a Metaclass object for the given class name. The metaclass\n     is a subclass of Class\"\n    | className class |\n    className := classNameString asSymbol.\n    class := Namespace current hereAt: className ifAbsent: [ nil ].\n\n    ^(class isNil or: [ class isClass not ])\n        ifTrue: [ Metaclass subclassOf: Class ]\n        ifFalse: [ class class ]",
          "literals": [],
          "methodName": "metaclassFor:",
          "className": "UndefinedObject",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    },
    {
      "className": "ValueAdaptor",
      "instance_methods": {
        "new": {
          "src": "new\n    \"Create a ValueHolder whose starting value is nil\"\n    ^self basicNew initialize",
          "literals": [],
          "methodName": "new",
          "className": "ValueHolder",
          "category": "private",
          "byteCodes": []
        },
        "on:index:": {
          "src": "on: anObject index: anIndex\n    \"Answer a PluggableAdaptor using anObject's #at: and #at:put:\n     message to implement #value and #value:; the first parameter\n     of #at: and #at:put: is anIndex\"\n\n    ^self\n\tgetBlock: [ anObject at: anIndex ]\n\tputBlock: [ :value | anObject at: anIndex put: value ]",
          "literals": [],
          "methodName": "on:index:",
          "className": "PluggableAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "with:": {
          "src": "with: anObject\n    \"Create a ValueHolder whose starting value is anObject\"\n    ^self new value: anObject",
          "literals": [],
          "methodName": "with:",
          "className": "ValueHolder",
          "category": "private",
          "byteCodes": []
        },
        "hasValue": {
          "src": "hasValue\n    \"Answer whether we already have a value.\"\n    ^sema isNil",
          "literals": [],
          "methodName": "hasValue",
          "className": "Promise",
          "category": "private",
          "byteCodes": []
        },
        "trigger": {
          "src": "trigger\n    \"Really set the value of the receiver.\"\n    delayed ifTrue: [\n\tdelayed := false.\n\tsuper value: value.\n    ]",
          "literals": [],
          "methodName": "trigger",
          "className": "DelayedAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "value:": {
          "src": "value: anObject\n    \"Set the value of the receiver - actually, the value is cached and\n     is not set until the #trigger method is sent.\"\n    value := anObject.\n    delayed := true.",
          "literals": [],
          "methodName": "value:",
          "className": "DelayedAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "on:aspect:": {
          "src": "on: anObject aspect: aSymbol\n    \"Answer a PluggableAdaptor using anObject's aSymbol message to\n     implement #value, and anObject's aSymbol: message (aSymbol\n     followed by a colon) to implement #value:\"\n\n    ^self\n\ton: anObject\n\tgetSelector: aSymbol\n\tputSelector: (aSymbol, ':') asSymbol",
          "literals": [],
          "methodName": "on:aspect:",
          "className": "PluggableAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "printOn:": {
          "src": "printOn: aStream\n    \"Print a representation of the receiver\"\n    aStream\n\tprint: self class;\n\tnextPut: $(;\n\tnextPutAll: (self hasValue\n\t\t\tifTrue: [ self value printString ]\n\t\t\tifFalse: [ '???' ]);\n\tnextPut: $)",
          "literals": [],
          "methodName": "printOn:",
          "className": "ValueAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "null": {
          "src": "null\n    self shouldNotImplement",
          "literals": [],
          "methodName": "null",
          "className": "Promise",
          "category": "private",
          "byteCodes": []
        },
        "getBlock:putBlock:": {
          "src": "getBlock: get putBlock: put\n    delayed := false.\n    ^super getBlock: get putBlock: put",
          "literals": [],
          "methodName": "getBlock:putBlock:",
          "className": "DelayedAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "on:getSelector:putSelector:": {
          "src": "on: anObject getSelector: getSelector putSelector: putSelector\n    \"Answer a PluggableAdaptor using anObject's getSelector message to\n     implement #value, and anObject's putSelector message to implement\n     #value:\"\n\n    ^self basicNew\n\tgetBlock: [ anObject perform: getSelector ]\n\tputBlock: [ :value | anObject perform: putSelector with: value ]",
          "literals": [],
          "methodName": "on:getSelector:putSelector:",
          "className": "PluggableAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "on:key:": {
          "src": "on: aDictionary key: aKey\n    \"Same as #on:index:. Provided for clarity and completeness.\"\n    ^self\n\ton: aDictionary\n\tindex: aKey",
          "literals": [],
          "methodName": "on:key:",
          "className": "PluggableAdaptor",
          "category": "private",
          "byteCodes": []
        },
        "initialize": {
          "src": "initialize\n    \"Private - set the initial state of the receiver\"\n    super initialize.\n    waiting := 0.\n    sema := Semaphore new.",
          "literals": [],
          "methodName": "initialize",
          "className": "Promise",
          "category": "private",
          "byteCodes": []
        },
        "value": {
          "src": "value\n    \"Get the value of the receiver.\"\n    ^delayed\n\tifTrue: [ value ]\n\tifFalse: [ getBlock value ]",
          "literals": [],
          "methodName": "value",
          "className": "DelayedAdaptor",
          "category": "private",
          "byteCodes": []
        }
      },
      "class_methods": {},
      "subclasses": []
    }
  ]
}